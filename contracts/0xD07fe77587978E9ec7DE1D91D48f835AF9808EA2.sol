contract main {




// =====================  Runtime code  =====================


#
#  - sub_4f08a863(?)
#  - tokenURI(uint256 arg1)
#
array of struct stor101;
array of struct stor102;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor106;
address owner;
mapping of struct sub_79ba2fa2;
mapping of uint256 sub_2b1331a8;
uint256 numMinted;
mapping of struct sub_be75288d;
uint256 presaleStartTime;
uint256 presaleEndTime;
uint8 transfersEnabled; offset 160
address _signerAddress;
uint256 launchTime;
uint256 sub_f9caa583;
address sub_cd38b90aAddress;
address sub_77b53eceAddress;
address sub_40c397daAddress;
address treasuryAddress;
address teamWalletAddress;
uint256 stor215;
uint8 paused;
array of uint256 stor315;

function getApproved(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function teamWalletAddress() payable {
    return teamWalletAddress
}

function totalSupply() payable {
    return numMinted
}

function presaleEndTime() payable {
    return presaleEndTime
}

function sub_2b1331a8(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[arg1][arg2]
}

function sub_30ec18c2(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[address(arg1)][arg2]
}

function sub_40c397da(?) payable {
    return sub_40c397daAddress
}

function paused() payable {
    return bool(paused)
}

function ownerOf(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function sub_77b53ece(?) payable {
    return sub_77b53eceAddress
}

function launchTime() payable {
    return launchTime
}

function sub_79ba2fa2(?) payable {
    require calldata.size - 4 >= 32
    return sub_79ba2fa2[arg1].field_512
}

function owner() payable {
    return owner
}

function presaleStartTime() payable {
    return presaleStartTime
}

function sub_be75288d(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[arg1].field_256
}

function transfersEnabled() payable {
    return bool(transfersEnabled)
}

function _signerAddress() payable {
    return _signerAddress
}

function treasuryAddress() payable {
    return treasuryAddress
}

function sub_cd38b90a(?) payable {
    return sub_cd38b90aAddress
}

function numMinted() payable {
    return numMinted
}

function sub_e31ffb63(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[stor201[arg1].field_0].field_1024
}

function isApprovedForAll(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor106[address(arg1)][address(arg2)])
}

function sub_f9caa583(?) payable {
    return sub_f9caa583
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setLaunchTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    launchTime = arg1
}

function setBondDiscount(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_f9caa583 = arg1
}

function sub_1593d8a5(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_256 = arg2
}

function sub_e345c564(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_512 = arg2
}

function sub_135ee927(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1536 = arg2
}

function sub_72c0ab83(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1024 = arg2
}

function sub_d010ad7f(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1280 = arg2
}

function pause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function setTreasuryAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    treasuryAddress = arg1
}

function setTeamWalletAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    teamWalletAddress = arg1
}

function sub_baabc801(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_cd38b90aAddress = address(arg1)
}

function sub_f3fd622f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_77b53eceAddress = address(arg1)
}

function setLiquidityPairAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_40c397daAddress = arg1
}

function sub_5c98f5e8(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_2b1331a8[address(arg1)][arg2] = arg3
}

function setApprovalForAll(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor106[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function Sweep(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call arg1 with:
       value arg2 wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with 0, 'Failed to send AVAX'
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function supportsInterface(bytes4 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor106[stor103[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function sub_b38344cf(?) payable {
    require ext_code.size(sub_cd38b90aAddress)
    staticcall sub_cd38b90aAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_77b53eceAddress)
    staticcall sub_77b53eceAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    return (1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0])
}

function getPendingRewards(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if sub_79ba2fa2[arg1].field_512 >= launchTime:
        if block.timestamp < sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        return ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600)
    if block.timestamp < launchTime:
        revert with 0, 17
    if block.timestamp - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime:
        revert with 0, 17
    return ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600)
}

function sub_3a0a52e4(?) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_be75288d[arg1].field_1792):
        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while sub_be75288d[arg1].field_1793 % 128 + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_d83b2611(?) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(sub_cd38b90aAddress)
    staticcall sub_cd38b90aAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_77b53eceAddress)
    staticcall sub_77b53eceAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if sub_be75288d[arg1].field_512 / 10^18 and 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] > -1 / sub_be75288d[arg1].field_512 / 10^18:
        revert with 0, 17
    if 100 < sub_f9caa583:
        revert with 0, 17
    if sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12 and -sub_f9caa583 + 100 > -1 / sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12:
        revert with 0, 17
    return ((100 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) - (sub_f9caa583 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) / 100)
}

function sub_d66fe70e(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= ('cd', 4).length:
            revert with 0, 50
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        approved[mem[(32 * idx) + 128]] = 0
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        emit Approval(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        if balanceOf[stor103[mem[(32 * idx) + 128]]] < 1:
            revert with 0, 17
        balanceOf[stor103[mem[(32 * idx) + 128]]]--
        ownerOf[mem[(32 * idx) + 128]] = 0
        emit Transfer(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        mem[0] = sub_79ba2fa2[mem[(32 * idx) + 128]].field_0
        mem[32] = sha3(ownerOf[mem[(32 * idx) + 128]], 202)
        if sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0] < 1:
            revert with 0, 17
        sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0]--
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
        if not ext_call.success:
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
        if not ext_call.success:
            if not return_data.size:
                if not arg4.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg4[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function name() payable {
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor101.length):
            if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor101.length):
                if 31 < uint255(stor101.length) * 0.5:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor101.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
        else:
            if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor101.length.field_1 % 128:
                if 31 < stor101.length.field_1 % 128:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while stor101.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
        mem[ceil32(uint255(stor101.length) * 0.5) + 192 len ceil32(uint255(stor101.length) * 0.5)] = mem[128 len ceil32(uint255(stor101.length) * 0.5)]
        if ceil32(uint255(stor101.length) * 0.5) > uint255(stor101.length) * 0.5:
            mem[(uint255(stor101.length) * 0.5) + ceil32(uint255(stor101.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)], mem[(2 * ceil32(uint255(stor101.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor101.length) * 0.5)]), 
    if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor101.length):
            if 31 < uint255(stor101.length) * 0.5:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while (uint255(stor101.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
    else:
        if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor101.length.field_1 % 128:
            if 31 < stor101.length.field_1 % 128:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while stor101.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
    mem[ceil32(stor101.length.field_1 % 128) + 192 len ceil32(stor101.length.field_1 % 128)] = mem[128 len ceil32(stor101.length.field_1 % 128)]
    if ceil32(stor101.length.field_1 % 128) > stor101.length.field_1 % 128:
        mem[stor101.length.field_1 % 128 + ceil32(stor101.length.field_1 % 128) + 192] = 0
    return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)], mem[(2 * ceil32(stor101.length.field_1 % 128)) + 192 len 2 * ceil32(stor101.length.field_1 % 128)]), 
}

function symbol() payable {
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor102.length):
            if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor102.length):
                if 31 < uint255(stor102.length) * 0.5:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor102.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
        else:
            if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor102.length.field_1 % 128:
                if 31 < stor102.length.field_1 % 128:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while stor102.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
        mem[ceil32(uint255(stor102.length) * 0.5) + 192 len ceil32(uint255(stor102.length) * 0.5)] = mem[128 len ceil32(uint255(stor102.length) * 0.5)]
        if ceil32(uint255(stor102.length) * 0.5) > uint255(stor102.length) * 0.5:
            mem[(uint255(stor102.length) * 0.5) + ceil32(uint255(stor102.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)], mem[(2 * ceil32(uint255(stor102.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor102.length) * 0.5)]), 
    if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor102.length):
            if 31 < uint255(stor102.length) * 0.5:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while (uint255(stor102.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
    else:
        if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor102.length.field_1 % 128:
            if 31 < stor102.length.field_1 % 128:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while stor102.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
    mem[ceil32(stor102.length.field_1 % 128) + 192 len ceil32(stor102.length.field_1 % 128)] = mem[128 len ceil32(stor102.length.field_1 % 128)]
    if ceil32(stor102.length.field_1 % 128) > stor102.length.field_1 % 128:
        mem[stor102.length.field_1 % 128 + ceil32(stor102.length.field_1 % 128) + 192] = 0
    return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)], mem[(2 * ceil32(stor102.length.field_1 % 128)) + 192 len 2 * ceil32(stor102.length.field_1 % 128)]), 
}

function sub_c35f6368(?) payable {
    require calldata.size - 4 >= 32
    if paused:
        revert with 0, 'Pausable: paused'
    if stor215 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor215 = 2
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1] != msg.sender:
        revert with 0, 'This is not your Node!'
    if this.address == msg.sender:
        revert with 0, 'Can't claim from the contract'
    if block.timestamp < launchTime:
        revert with 0, 'Not launched yet'
    if not launchTime:
        revert with 0, 'Not launched yet'
    if sub_79ba2fa2[arg1].field_512 >= launchTime:
        if 24 * 3600 > !sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp <= sub_79ba2fa2[arg1].field_512 + (24 * 3600):
            revert with 0, 'Must wait 24h to claim reward'
        if block.timestamp < sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600:
            revert with 0, 17
        sub_79ba2fa2[arg1].field_512 = block.timestamp
        if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
            revert with 0, 17
        require ext_code.size(sub_cd38b90aAddress)
        call sub_cd38b90aAddress.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
    else:
        if 24 * 3600 > !launchTime:
            revert with 0, 17
        if block.timestamp <= launchTime + (24 * 3600):
            revert with 0, 'Must wait 24h to claim reward'
        if block.timestamp < launchTime:
            revert with 0, 17
        if block.timestamp - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime:
            revert with 0, 17
        if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600:
            revert with 0, 17
        sub_79ba2fa2[arg1].field_512 = block.timestamp
        if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
            revert with 0, 17
        require ext_code.size(sub_cd38b90aAddress)
        call sub_cd38b90aAddress.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    stor215 = 1
}

function sub_ffeab7d1(?) payable {
    if paused:
        revert with 0, 'Pausable: paused'
    if stor215 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor215 = 2
    if stor315[msg.sender] <= 0:
        revert with 0, 'No nodes to claim'
    if stor315[msg.sender] < 1:
        revert with 0, 17
    if var116001 >= stor[var116002]:
        revert with 0, 50
    if block.timestamp < sub_79ba2fa2[var122001].field_512:
        if not var126001:
            revert with 0, 17
        if var136001 >= stor[var136002]:
            revert with 0, 50
        if block.timestamp >= sub_79ba2fa2[var142001].field_512:
            # nil
        else:
            if not var146001:
                revert with 0, 17
            # nil
    else:
        mem[64] = 128
        mem[96] = 0
        if not ownerOf[var130001]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if not ownerOf[var134001]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if msg.sender == address(var138001):
            if not ownerOf[var138008]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[var138008] != this.address:
                revert with 0, 'ERC721: transfer from incorrect owner'
            if not msg.sender:
                revert with 0, 'ERC721: transfer to the zero address'
            if not this.address:
                approved[var138008] = 0
                if not ownerOf[var138008]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                emit Approval(ownerOf[var138008], 0, var138008);
                if balanceOf[address(this.address)] < 1:
                    revert with 0, 17
                balanceOf[address(this.address)]--
                if balanceOf[address(msg.sender)] > -2:
                    revert with 0, 17
                balanceOf[address(msg.sender)]++
                mem[0] = var138008
                mem[32] = 103
                ownerOf[var138008] = msg.sender
                emit Transfer(this.address, msg.sender, var138008);
                if not ext_code.size(msg.sender):
                    if not stor315[msg.sender][1][var138016]:
                        if not var96001:
                            revert with 0, 17
                        # nil
                    else:
                        if stor315[msg.sender][1][var138016] < 1:
                            revert with 0, 17
                        if stor315[msg.sender] < 1:
                            revert with 0, 17
                        if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                            if not stor315[msg.sender]:
                                revert with 0, 49
                            stor315[msg.sender][stor315[msg.sender]] = 0
                            stor315[msg.sender]--
                            stor315[msg.sender][1][var138016] = 0
                            if not var104001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                revert with 0, 50
                            if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                revert with 0, 50
                            stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                            stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                            if not stor315[msg.sender]:
                                revert with 0, 49
                            stor315[msg.sender][stor315[msg.sender]] = 0
                            stor315[msg.sender]--
                            stor315[msg.sender][1][var138016] = 0
                            if not var107001:
                                revert with 0, 17
                            # nil
                else:
                    mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                    mem[132] = msg.sender
                    mem[164] = this.address
                    mem[196] = var138008
                    mem[228] = 128
                    _19310 = mem[var138007]
                    mem[260] = mem[var138007]
                    mem[292 len ceil32(_19310)] = mem[var138007 + 32 len ceil32(_19310)]
                    if ceil32(_19310) > _19310:
                        mem[_19310 + 292] = 0
                    require ext_code.size(msg.sender)
                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19310) + 32]
                    if not ext_call.success:
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    if not stor315[msg.sender][1][var138016]:
                        if not var117001:
                            revert with 0, 17
                        # nil
                    else:
                        if stor315[msg.sender][1][var138016] < 1:
                            revert with 0, 17
                        if stor315[msg.sender] < 1:
                            revert with 0, 17
                        if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                            if not stor315[msg.sender]:
                                revert with 0, 49
                            stor315[msg.sender][stor315[msg.sender]] = 0
                            stor315[msg.sender]--
                            stor315[msg.sender][1][var138016] = 0
                            if not var125001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                revert with 0, 50
                            if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                revert with 0, 50
                            stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                            stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                            if not stor315[msg.sender]:
                                revert with 0, 49
                            stor315[msg.sender][stor315[msg.sender]] = 0
                            stor315[msg.sender]--
                            stor315[msg.sender][1][var138016] = 0
                            if not var128001:
                                revert with 0, 17
                            # nil
            else:
                if not msg.sender:
                    approved[var138008] = 0
                    if not ownerOf[var138008]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[var138008], 0, var138008);
                    if balanceOf[address(this.address)] < 1:
                        revert with 0, 17
                    balanceOf[address(this.address)]--
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = var138008
                    mem[32] = 103
                    ownerOf[var138008] = msg.sender
                    emit Transfer(this.address, msg.sender, var138008);
                    if not ext_code.size(msg.sender):
                        if not stor315[msg.sender][1][var138016]:
                            if not var97001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var105001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var108001:
                                    revert with 0, 17
                                # nil
                    else:
                        mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[132] = msg.sender
                        mem[164] = this.address
                        mem[196] = var138008
                        mem[228] = 128
                        _19323 = mem[var138007]
                        mem[260] = mem[var138007]
                        mem[292 len ceil32(_19323)] = mem[var138007 + 32 len ceil32(_19323)]
                        if ceil32(_19323) > _19323:
                            mem[_19323 + 292] = 0
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19323) + 32]
                        if not ext_call.success:
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not stor315[msg.sender][1][var138016]:
                            if not var118001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var126001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var129001:
                                    revert with 0, 17
                                # nil
                else:
                    if not transfersEnabled:
                        revert with 0, 'Transfers not enabled yet'
                    approved[var138008] = 0
                    if not ownerOf[var138008]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[var138008], 0, var138008);
                    if balanceOf[address(this.address)] < 1:
                        revert with 0, 17
                    balanceOf[address(this.address)]--
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = var138008
                    mem[32] = 103
                    ownerOf[var138008] = msg.sender
                    emit Transfer(this.address, msg.sender, var138008);
                    if not ext_code.size(msg.sender):
                        if not stor315[msg.sender][1][var138016]:
                            if not var98001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var106001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var109001:
                                    revert with 0, 17
                                # nil
                    else:
                        mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[132] = msg.sender
                        mem[164] = this.address
                        mem[196] = var138008
                        mem[228] = 128
                        _19337 = mem[var138007]
                        mem[260] = mem[var138007]
                        mem[292 len ceil32(_19337)] = mem[var138007 + 32 len ceil32(_19337)]
                        if ceil32(_19337) > _19337:
                            mem[_19337 + 292] = 0
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19337) + 32]
                        if not ext_call.success:
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not stor315[msg.sender][1][var138016]:
                            if not var119001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var127001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var130001:
                                    revert with 0, 17
                                # nil
        else:
            if not ownerOf[var138004]:
                revert with 0, 'ERC721: approved query for nonexistent token'
            if approved[var138004] == msg.sender:
                if not ownerOf[var138008]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[var138008] != this.address:
                    revert with 0, 'ERC721: transfer from incorrect owner'
                if not msg.sender:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not this.address:
                    approved[var138008] = 0
                    if not ownerOf[var138008]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[var138008], 0, var138008);
                    if balanceOf[address(this.address)] < 1:
                        revert with 0, 17
                    balanceOf[address(this.address)]--
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = var138008
                    mem[32] = 103
                    ownerOf[var138008] = msg.sender
                    emit Transfer(this.address, msg.sender, var138008);
                    if not ext_code.size(msg.sender):
                        if not stor315[msg.sender][1][var138016]:
                            if not var100001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var108001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var111001:
                                    revert with 0, 17
                                # nil
                    else:
                        mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[132] = msg.sender
                        mem[164] = this.address
                        mem[196] = var138008
                        mem[228] = 128
                        _19368 = mem[var138007]
                        mem[260] = mem[var138007]
                        mem[292 len ceil32(_19368)] = mem[var138007 + 32 len ceil32(_19368)]
                        if ceil32(_19368) > _19368:
                            mem[_19368 + 292] = 0
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19368) + 32]
                        if not ext_call.success:
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not stor315[msg.sender][1][var138016]:
                            if not var121001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var129001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var132001:
                                    revert with 0, 17
                                # nil
                else:
                    if not msg.sender:
                        approved[var138008] = 0
                        if not ownerOf[var138008]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[var138008], 0, var138008);
                        if balanceOf[address(this.address)] < 1:
                            revert with 0, 17
                        balanceOf[address(this.address)]--
                        if balanceOf[address(msg.sender)] > -2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)]++
                        mem[0] = var138008
                        mem[32] = 103
                        ownerOf[var138008] = msg.sender
                        emit Transfer(this.address, msg.sender, var138008);
                        if not ext_code.size(msg.sender):
                            if not stor315[msg.sender][1][var138016]:
                                if not var101001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var109001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var112001:
                                        revert with 0, 17
                                    # nil
                        else:
                            mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[132] = msg.sender
                            mem[164] = this.address
                            mem[196] = var138008
                            mem[228] = 128
                            _19381 = mem[var138007]
                            mem[260] = mem[var138007]
                            mem[292 len ceil32(_19381)] = mem[var138007 + 32 len ceil32(_19381)]
                            if ceil32(_19381) > _19381:
                                mem[_19381 + 292] = 0
                            require ext_code.size(msg.sender)
                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19381) + 32]
                            if not ext_call.success:
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not stor315[msg.sender][1][var138016]:
                                if not var122001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var130001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var133001:
                                        revert with 0, 17
                                    # nil
                    else:
                        if not transfersEnabled:
                            revert with 0, 'Transfers not enabled yet'
                        approved[var138008] = 0
                        if not ownerOf[var138008]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[var138008], 0, var138008);
                        if balanceOf[address(this.address)] < 1:
                            revert with 0, 17
                        balanceOf[address(this.address)]--
                        if balanceOf[address(msg.sender)] > -2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)]++
                        mem[0] = var138008
                        mem[32] = 103
                        ownerOf[var138008] = msg.sender
                        emit Transfer(this.address, msg.sender, var138008);
                        if not ext_code.size(msg.sender):
                            if not stor315[msg.sender][1][var138016]:
                                if not var102001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var110001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var113001:
                                        revert with 0, 17
                                    # nil
                        else:
                            mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[132] = msg.sender
                            mem[164] = this.address
                            mem[196] = var138008
                            mem[228] = 128
                            _19389 = mem[var138007]
                            mem[260] = mem[var138007]
                            mem[292 len ceil32(_19389)] = mem[var138007 + 32 len ceil32(_19389)]
                            if ceil32(_19389) > _19389:
                                mem[_19389 + 292] = 0
                            require ext_code.size(msg.sender)
                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19389) + 32]
                            if not ext_call.success:
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not stor315[msg.sender][1][var138016]:
                                if not var123001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var131001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var134001:
                                        revert with 0, 17
                                    # nil
            else:
                if not stor106[address(var138001)][address(msg.sender)]:
                    revert with 0, 'ERC721: transfer caller is not owner nor approved'
                if not ownerOf[var138008]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[var138008] != this.address:
                    revert with 0, 'ERC721: transfer from incorrect owner'
                if not msg.sender:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not this.address:
                    approved[var138008] = 0
                    if not ownerOf[var138008]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[var138008], 0, var138008);
                    if balanceOf[address(this.address)] < 1:
                        revert with 0, 17
                    balanceOf[address(this.address)]--
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = var138008
                    mem[32] = 103
                    ownerOf[var138008] = msg.sender
                    emit Transfer(this.address, msg.sender, var138008);
                    if not ext_code.size(msg.sender):
                        if not stor315[msg.sender][1][var138016]:
                            if not var101001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var109001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var112001:
                                    revert with 0, 17
                                # nil
                    else:
                        mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[132] = msg.sender
                        mem[164] = this.address
                        mem[196] = var138008
                        mem[228] = 128
                        _19382 = mem[var138007]
                        mem[260] = mem[var138007]
                        mem[292 len ceil32(_19382)] = mem[var138007 + 32 len ceil32(_19382)]
                        if ceil32(_19382) > _19382:
                            mem[_19382 + 292] = 0
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19382) + 32]
                        if not ext_call.success:
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not stor315[msg.sender][1][var138016]:
                            if not var122001:
                                revert with 0, 17
                            # nil
                        else:
                            if stor315[msg.sender][1][var138016] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] < 1:
                                revert with 0, 17
                            if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var130001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                    revert with 0, 50
                                stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                if not stor315[msg.sender]:
                                    revert with 0, 49
                                stor315[msg.sender][stor315[msg.sender]] = 0
                                stor315[msg.sender]--
                                stor315[msg.sender][1][var138016] = 0
                                if not var133001:
                                    revert with 0, 17
                                # nil
                else:
                    if not msg.sender:
                        approved[var138008] = 0
                        if not ownerOf[var138008]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[var138008], 0, var138008);
                        if balanceOf[address(this.address)] < 1:
                            revert with 0, 17
                        balanceOf[address(this.address)]--
                        if balanceOf[address(msg.sender)] > -2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)]++
                        mem[0] = var138008
                        mem[32] = 103
                        ownerOf[var138008] = msg.sender
                        emit Transfer(this.address, msg.sender, var138008);
                        if not ext_code.size(msg.sender):
                            if not stor315[msg.sender][1][var138016]:
                                if not var102001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var110001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var113001:
                                        revert with 0, 17
                                    # nil
                        else:
                            mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[132] = msg.sender
                            mem[164] = this.address
                            mem[196] = var138008
                            mem[228] = 128
                            _19390 = mem[var138007]
                            mem[260] = mem[var138007]
                            mem[292 len ceil32(_19390)] = mem[var138007 + 32 len ceil32(_19390)]
                            if ceil32(_19390) > _19390:
                                mem[_19390 + 292] = 0
                            require ext_code.size(msg.sender)
                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19390) + 32]
                            if not ext_call.success:
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not stor315[msg.sender][1][var138016]:
                                if not var123001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var131001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var134001:
                                        revert with 0, 17
                                    # nil
                    else:
                        if not transfersEnabled:
                            revert with 0, 'Transfers not enabled yet'
                        approved[var138008] = 0
                        if not ownerOf[var138008]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[var138008], 0, var138008);
                        if balanceOf[address(this.address)] < 1:
                            revert with 0, 17
                        balanceOf[address(this.address)]--
                        if balanceOf[address(msg.sender)] > -2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)]++
                        mem[0] = var138008
                        mem[32] = 103
                        ownerOf[var138008] = msg.sender
                        emit Transfer(this.address, msg.sender, var138008);
                        if not ext_code.size(msg.sender):
                            if not stor315[msg.sender][1][var138016]:
                                if not var103001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var111001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var114001:
                                        revert with 0, 17
                                    # nil
                        else:
                            mem[128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[132] = msg.sender
                            mem[164] = this.address
                            mem[196] = var138008
                            mem[228] = 128
                            _19400 = mem[var138007]
                            mem[260] = mem[var138007]
                            mem[292 len ceil32(_19400)] = mem[var138007 + 32 len ceil32(_19400)]
                            if ceil32(_19400) > _19400:
                                mem[_19400 + 292] = 0
                            require ext_code.size(msg.sender)
                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, uint32(msg.sender), address(this.address), var138008, 128, mem[260 len ceil32(_19400) + 32]
                            if not ext_call.success:
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if not stor315[msg.sender][1][var138016]:
                                if not var124001:
                                    revert with 0, 17
                                # nil
                            else:
                                if stor315[msg.sender][1][var138016] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] < 1:
                                    revert with 0, 17
                                if stor315[msg.sender] - 1 == stor315[msg.sender][1][var138016] - 1:
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var132001:
                                        revert with 0, 17
                                    # nil
                                else:
                                    if stor315[msg.sender] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    if stor315[msg.sender][1][var138016] - 1 >= stor315[msg.sender]:
                                        revert with 0, 50
                                    stor315[msg.sender][stor315[msg.sender][1][var138016]] = stor315[msg.sender][stor315[msg.sender]]
                                    stor315[msg.sender][1][stor315[msg.sender][stor315[msg.sender]]] = stor315[msg.sender][1][var138016]
                                    if not stor315[msg.sender]:
                                        revert with 0, 49
                                    stor315[msg.sender][stor315[msg.sender]] = 0
                                    stor315[msg.sender]--
                                    stor315[msg.sender][1][var138016] = 0
                                    if not var135001:
                                        revert with 0, 17
                                    # nil
}

function sub_cf37c49a(?) payable {
    require calldata.size - 4 >= 32
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if 31 < uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if sub_be75288d[arg1].field_1793 % 128:
                                if 31 < sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793 % 128:
                            if 31 < sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if 31 < sub_be75288d[arg1].field_1 % 128:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if sub_be75288d[arg1].field_1793 % 128:
                                if 31 < sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793 % 128:
                            if 31 < sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1792 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
               sub_be75288d[arg1].field_256,
               sub_be75288d[arg1].field_512,
               sub_be75288d[arg1].field_768,
               sub_be75288d[arg1].field_1024,
               sub_be75288d[arg1].field_1280,
               sub_be75288d[arg1].field_1536,
               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
    if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                revert with 0, 34
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793 % 128:
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793 % 128:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if 31 < uint255(sub_be75288d[arg1].field_0) * 0.5:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793 % 128:
                            if 31 < sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1793 % 128:
                        if 31 < sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                    mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
    else:
        if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if not sub_be75288d[arg1].field_1 % 128:
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                revert with 0, 34
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793 % 128:
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793 % 128:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if 31 < sub_be75288d[arg1].field_1 % 128:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while sub_be75288d[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793 % 128:
                            if 31 < sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1793 % 128:
                        if 31 < sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                    mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1792 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
           sub_be75288d[arg1].field_256,
           sub_be75288d[arg1].field_512,
           sub_be75288d[arg1].field_768,
           sub_be75288d[arg1].field_1024,
           sub_be75288d[arg1].field_1280,
           sub_be75288d[arg1].field_1536,
           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
}

function sub_d871fea2(?) payable {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        mem[352] = uint255(sub_be75288d[arg1].field_0) * 0.5
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10147 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10147] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11803 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11803] = arg1
                                    mem[_11803 + 32] = 1000
                                    mem[_11803 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11803 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10147 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19611 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19611] == Mask(32, 224, mem[_19611])
                                    if Mask(32, 224, mem[_19611]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21771 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21771] = arg1
                                    mem[_21771 + 32] = 1000
                                    mem[_21771 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21771 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10149 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10149] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11804 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11804] = arg1
                                        mem[_11804 + 32] = 1000
                                        mem[_11804 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11804 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10149 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19613] == Mask(32, 224, mem[_19613])
                                        if Mask(32, 224, mem[_19613]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21776 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21776] = arg1
                                        mem[_21776 + 32] = 1000
                                        mem[_21776 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21776 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19405 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19405] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22875 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22875] = arg1
                                        mem[_22875 + 32] = 1000
                                        mem[_22875 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22875 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19405 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26923 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26923] == Mask(32, 224, mem[_26923])
                                        if Mask(32, 224, mem[_26923]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28587 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28587] = arg1
                                        mem[_28587 + 32] = 1000
                                        mem[_28587 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28587 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10150 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10150] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11805 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11805] = arg1
                                    mem[_11805 + 32] = 1000
                                    mem[_11805 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11805 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10150 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19615 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19615] == Mask(32, 224, mem[_19615])
                                    if Mask(32, 224, mem[_19615]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21780 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21780] = arg1
                                    mem[_21780 + 32] = 1000
                                    mem[_21780 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21780 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10152 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10152] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11806 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11806] = arg1
                                        mem[_11806 + 32] = 1000
                                        mem[_11806 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11806 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10152 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19617 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19617] == Mask(32, 224, mem[_19617])
                                        if Mask(32, 224, mem[_19617]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21785 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21785] = arg1
                                        mem[_21785 + 32] = 1000
                                        mem[_21785 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21785 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19410 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19410] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22876 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22876] = arg1
                                        mem[_22876 + 32] = 1000
                                        mem[_22876 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22876 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19410 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26925 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26925] == Mask(32, 224, mem[_26925])
                                        if Mask(32, 224, mem[_26925]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28591 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28591] = arg1
                                        mem[_28591 + 32] = 1000
                                        mem[_28591 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28591 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10153 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10153] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11807 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11807] = arg1
                                    mem[_11807 + 32] = 1000
                                    mem[_11807 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11807 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10153 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19619 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19619] == Mask(32, 224, mem[_19619])
                                    if Mask(32, 224, mem[_19619]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21789 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21789] = arg1
                                    mem[_21789 + 32] = 1000
                                    mem[_21789 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21789 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10155 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10155] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11808 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11808] = arg1
                                        mem[_11808 + 32] = 1000
                                        mem[_11808 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11808 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10155 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19621 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19621] == Mask(32, 224, mem[_19621])
                                        if Mask(32, 224, mem[_19621]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21794 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21794] = arg1
                                        mem[_21794 + 32] = 1000
                                        mem[_21794 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21794 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19415 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19415] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22877 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22877] = arg1
                                        mem[_22877 + 32] = 1000
                                        mem[_22877 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22877 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19415 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26927 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26927] == Mask(32, 224, mem[_26927])
                                        if Mask(32, 224, mem[_26927]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28595 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28595] = arg1
                                        mem[_28595 + 32] = 1000
                                        mem[_28595 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28595 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10156 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10156] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11809 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11809] = arg1
                                    mem[_11809 + 32] = 1000
                                    mem[_11809 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11809 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10156 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19623 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19623] == Mask(32, 224, mem[_19623])
                                    if Mask(32, 224, mem[_19623]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21798 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21798] = arg1
                                    mem[_21798 + 32] = 1000
                                    mem[_21798 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21798 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10158 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10158] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11810 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11810] = arg1
                                        mem[_11810 + 32] = 1000
                                        mem[_11810 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11810 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10158 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19625 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19625] == Mask(32, 224, mem[_19625])
                                        if Mask(32, 224, mem[_19625]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21803 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21803] = arg1
                                        mem[_21803 + 32] = 1000
                                        mem[_21803 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19420 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19420] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22878 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22878] = arg1
                                        mem[_22878 + 32] = 1000
                                        mem[_22878 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22878 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19420 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26929 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26929] == Mask(32, 224, mem[_26929])
                                        if Mask(32, 224, mem[_26929]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28599 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28599] = arg1
                                        mem[_28599 + 32] = 1000
                                        mem[_28599 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28599 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10159 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10159] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11814 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11814] = arg1
                                        mem[_11814 + 32] = 1000
                                        mem[_11814 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11814 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10159 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19631 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19631] == Mask(32, 224, mem[_19631])
                                        if Mask(32, 224, mem[_19631]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21823 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21823] = arg1
                                        mem[_21823 + 32] = 1000
                                        mem[_21823 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10161 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10161] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11815 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11815] = arg1
                                            mem[_11815 + 32] = 1000
                                            mem[_11815 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11815 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10161 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19633 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19633] == Mask(32, 224, mem[_19633])
                                            if Mask(32, 224, mem[_19633]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21828 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21828] = arg1
                                            mem[_21828 + 32] = 1000
                                            mem[_21828 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21828 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19437 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19437] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22887 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22887] = arg1
                                            mem[_22887 + 32] = 1000
                                            mem[_22887 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22887 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19437 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26947] == Mask(32, 224, mem[_26947])
                                            if Mask(32, 224, mem[_26947]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28639 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28639] = arg1
                                            mem[_28639 + 32] = 1000
                                            mem[_28639 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28639 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10162 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10162] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11816 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11816] = arg1
                                        mem[_11816 + 32] = 1000
                                        mem[_11816 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11816 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10162 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19635 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19635] == Mask(32, 224, mem[_19635])
                                        if Mask(32, 224, mem[_19635]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21832 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21832] = arg1
                                        mem[_21832 + 32] = 1000
                                        mem[_21832 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21832 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10164 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10164] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11817 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11817] = arg1
                                            mem[_11817 + 32] = 1000
                                            mem[_11817 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11817 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10164 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19637 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19637] == Mask(32, 224, mem[_19637])
                                            if Mask(32, 224, mem[_19637]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21837 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21837] = arg1
                                            mem[_21837 + 32] = 1000
                                            mem[_21837 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21837 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19442 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19442] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22888 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22888] = arg1
                                            mem[_22888 + 32] = 1000
                                            mem[_22888 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22888 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19442 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26949 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26949] == Mask(32, 224, mem[_26949])
                                            if Mask(32, 224, mem[_26949]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28643 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28643] = arg1
                                            mem[_28643 + 32] = 1000
                                            mem[_28643 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28643 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10165 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10165] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11818 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11818] = arg1
                                        mem[_11818 + 32] = 1000
                                        mem[_11818 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11818 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10165 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19639 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19639] == Mask(32, 224, mem[_19639])
                                        if Mask(32, 224, mem[_19639]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21841 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21841] = arg1
                                        mem[_21841 + 32] = 1000
                                        mem[_21841 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21841 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10167 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10167] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11819 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11819] = arg1
                                            mem[_11819 + 32] = 1000
                                            mem[_11819 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11819 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10167 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19641 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19641] == Mask(32, 224, mem[_19641])
                                            if Mask(32, 224, mem[_19641]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21846 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21846] = arg1
                                            mem[_21846 + 32] = 1000
                                            mem[_21846 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21846 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19447 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19447] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22889 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22889] = arg1
                                            mem[_22889 + 32] = 1000
                                            mem[_22889 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22889 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19447 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26951] == Mask(32, 224, mem[_26951])
                                            if Mask(32, 224, mem[_26951]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28647 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28647] = arg1
                                            mem[_28647 + 32] = 1000
                                            mem[_28647 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28647 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10168 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10168] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11820 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11820] = arg1
                                        mem[_11820 + 32] = 1000
                                        mem[_11820 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11820 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10168 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19643 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19643] == Mask(32, 224, mem[_19643])
                                        if Mask(32, 224, mem[_19643]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21850 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21850] = arg1
                                        mem[_21850 + 32] = 1000
                                        mem[_21850 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21850 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10170 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10170] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11821 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11821] = arg1
                                            mem[_11821 + 32] = 1000
                                            mem[_11821 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11821 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10170 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19645 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19645] == Mask(32, 224, mem[_19645])
                                            if Mask(32, 224, mem[_19645]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21855] = arg1
                                            mem[_21855 + 32] = 1000
                                            mem[_21855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19452 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19452] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22890 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22890] = arg1
                                            mem[_22890 + 32] = 1000
                                            mem[_22890 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22890 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19452 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26953 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26953] == Mask(32, 224, mem[_26953])
                                            if Mask(32, 224, mem[_26953]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28651 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28651] = arg1
                                            mem[_28651 + 32] = 1000
                                            mem[_28651 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28651 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19423 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19423] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22879 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22879] = arg1
                                        mem[_22879 + 32] = 1000
                                        mem[_22879 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22879 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19423 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26931] == Mask(32, 224, mem[_26931])
                                        if Mask(32, 224, mem[_26931]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28603 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28603] = arg1
                                        mem[_28603 + 32] = 1000
                                        mem[_28603 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28603 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19425 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19425] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22880 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22880] = arg1
                                            mem[_22880 + 32] = 1000
                                            mem[_22880 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22880 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19425 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26933 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26933] == Mask(32, 224, mem[_26933])
                                            if Mask(32, 224, mem[_26933]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28608 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28608] = arg1
                                            mem[_28608 + 32] = 1000
                                            mem[_28608 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28608 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26789 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26789] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29515 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29515] = arg1
                                            mem[_29515 + 32] = 1000
                                            mem[_29515 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29515 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26789 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30315 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30315] == Mask(32, 224, mem[_30315])
                                            if Mask(32, 224, mem[_30315]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30699 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30699] = arg1
                                            mem[_30699 + 32] = 1000
                                            mem[_30699 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30699 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19426 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19426] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22881 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22881] = arg1
                                        mem[_22881 + 32] = 1000
                                        mem[_22881 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22881 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19426 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26935 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26935] == Mask(32, 224, mem[_26935])
                                        if Mask(32, 224, mem[_26935]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28612 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28612] = arg1
                                        mem[_28612 + 32] = 1000
                                        mem[_28612 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28612 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19428 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19428] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22882 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22882] = arg1
                                            mem[_22882 + 32] = 1000
                                            mem[_22882 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22882 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19428 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26937 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26937] == Mask(32, 224, mem[_26937])
                                            if Mask(32, 224, mem[_26937]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28617 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28617] = arg1
                                            mem[_28617 + 32] = 1000
                                            mem[_28617 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28617 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26794 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26794] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29516 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29516] = arg1
                                            mem[_29516 + 32] = 1000
                                            mem[_29516 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29516 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26794 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30317 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30317] == Mask(32, 224, mem[_30317])
                                            if Mask(32, 224, mem[_30317]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30703] = arg1
                                            mem[_30703 + 32] = 1000
                                            mem[_30703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19429 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19429] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22883 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22883] = arg1
                                        mem[_22883 + 32] = 1000
                                        mem[_22883 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22883 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19429 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26939 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26939] == Mask(32, 224, mem[_26939])
                                        if Mask(32, 224, mem[_26939]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28621 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28621] = arg1
                                        mem[_28621 + 32] = 1000
                                        mem[_28621 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28621 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19431 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19431] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22884 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22884] = arg1
                                            mem[_22884 + 32] = 1000
                                            mem[_22884 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22884 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19431 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26941 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26941] == Mask(32, 224, mem[_26941])
                                            if Mask(32, 224, mem[_26941]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28626 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28626] = arg1
                                            mem[_28626 + 32] = 1000
                                            mem[_28626 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28626 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26799 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26799] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29517 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29517] = arg1
                                            mem[_29517 + 32] = 1000
                                            mem[_29517 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29517 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26799 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30319 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30319] == Mask(32, 224, mem[_30319])
                                            if Mask(32, 224, mem[_30319]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30707 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30707] = arg1
                                            mem[_30707 + 32] = 1000
                                            mem[_30707 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30707 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19432 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19432] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22885 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22885] = arg1
                                        mem[_22885 + 32] = 1000
                                        mem[_22885 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22885 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19432 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26943 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26943] == Mask(32, 224, mem[_26943])
                                        if Mask(32, 224, mem[_26943]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28630 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28630] = arg1
                                        mem[_28630 + 32] = 1000
                                        mem[_28630 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28630 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19434 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19434] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22886 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22886] = arg1
                                            mem[_22886 + 32] = 1000
                                            mem[_22886 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22886 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19434 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26945 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26945] == Mask(32, 224, mem[_26945])
                                            if Mask(32, 224, mem[_26945]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28635 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28635] = arg1
                                            mem[_28635 + 32] = 1000
                                            mem[_28635 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26804 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26804] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29518 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29518] = arg1
                                            mem[_29518 + 32] = 1000
                                            mem[_29518 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29518 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26804 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30321 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30321] == Mask(32, 224, mem[_30321])
                                            if Mask(32, 224, mem[_30321]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30711 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30711] = arg1
                                            mem[_30711 + 32] = 1000
                                            mem[_30711 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30711 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10171 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10171] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11822 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11822] = arg1
                                    mem[_11822 + 32] = 1000
                                    mem[_11822 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11822 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10171 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19647 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19647] == Mask(32, 224, mem[_19647])
                                    if Mask(32, 224, mem[_19647]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21859 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21859] = arg1
                                    mem[_21859 + 32] = 1000
                                    mem[_21859 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21859 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10173 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10173] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11823 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11823] = arg1
                                        mem[_11823 + 32] = 1000
                                        mem[_11823 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10173 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19649 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19649] == Mask(32, 224, mem[_19649])
                                        if Mask(32, 224, mem[_19649]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21864 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21864] = arg1
                                        mem[_21864 + 32] = 1000
                                        mem[_21864 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21864 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19457 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19457] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22891 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22891] = arg1
                                        mem[_22891 + 32] = 1000
                                        mem[_22891 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22891 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19457 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26955 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26955] == Mask(32, 224, mem[_26955])
                                        if Mask(32, 224, mem[_26955]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28655 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28655] = arg1
                                        mem[_28655 + 32] = 1000
                                        mem[_28655 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28655 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10174 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10174] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11824 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11824] = arg1
                                    mem[_11824 + 32] = 1000
                                    mem[_11824 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11824 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10174 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19651 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19651] == Mask(32, 224, mem[_19651])
                                    if Mask(32, 224, mem[_19651]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21868 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21868] = arg1
                                    mem[_21868 + 32] = 1000
                                    mem[_21868 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21868 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10176 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10176] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11825 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11825] = arg1
                                        mem[_11825 + 32] = 1000
                                        mem[_11825 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11825 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10176 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19653 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19653] == Mask(32, 224, mem[_19653])
                                        if Mask(32, 224, mem[_19653]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21873 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21873] = arg1
                                        mem[_21873 + 32] = 1000
                                        mem[_21873 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21873 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19462 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19462] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22892 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22892] = arg1
                                        mem[_22892 + 32] = 1000
                                        mem[_22892 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22892 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19462 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26957 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26957] == Mask(32, 224, mem[_26957])
                                        if Mask(32, 224, mem[_26957]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28659 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28659] = arg1
                                        mem[_28659 + 32] = 1000
                                        mem[_28659 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28659 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10177 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10177] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11826 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11826] = arg1
                                    mem[_11826 + 32] = 1000
                                    mem[_11826 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11826 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10177 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19655 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19655] == Mask(32, 224, mem[_19655])
                                    if Mask(32, 224, mem[_19655]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21877 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21877] = arg1
                                    mem[_21877 + 32] = 1000
                                    mem[_21877 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21877 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10179 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10179] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11827 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11827] = arg1
                                        mem[_11827 + 32] = 1000
                                        mem[_11827 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11827 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10179 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19657 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19657] == Mask(32, 224, mem[_19657])
                                        if Mask(32, 224, mem[_19657]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21882 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21882] = arg1
                                        mem[_21882 + 32] = 1000
                                        mem[_21882 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21882 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19467 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19467] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22893 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22893] = arg1
                                        mem[_22893 + 32] = 1000
                                        mem[_22893 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22893 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19467 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26959 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26959] == Mask(32, 224, mem[_26959])
                                        if Mask(32, 224, mem[_26959]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28663 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28663] = arg1
                                        mem[_28663 + 32] = 1000
                                        mem[_28663 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28663 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10180 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10180] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11828 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11828] = arg1
                                    mem[_11828 + 32] = 1000
                                    mem[_11828 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11828 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10180 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19659 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19659] == Mask(32, 224, mem[_19659])
                                    if Mask(32, 224, mem[_19659]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21886 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21886] = arg1
                                    mem[_21886 + 32] = 1000
                                    mem[_21886 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21886 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10182 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10182] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11829 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11829] = arg1
                                        mem[_11829 + 32] = 1000
                                        mem[_11829 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11829 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10182 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19661 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19661] == Mask(32, 224, mem[_19661])
                                        if Mask(32, 224, mem[_19661]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21891 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21891] = arg1
                                        mem[_21891 + 32] = 1000
                                        mem[_21891 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21891 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19472 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19472] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22894 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22894] = arg1
                                        mem[_22894 + 32] = 1000
                                        mem[_22894 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22894 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19472 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26961 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26961] == Mask(32, 224, mem[_26961])
                                        if Mask(32, 224, mem[_26961]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28667 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28667] = arg1
                                        mem[_28667 + 32] = 1000
                                        mem[_28667 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28667 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10183 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10183] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11833 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11833] = arg1
                                        mem[_11833 + 32] = 1000
                                        mem[_11833 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11833 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10183 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19667 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19667] == Mask(32, 224, mem[_19667])
                                        if Mask(32, 224, mem[_19667]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21911] = arg1
                                        mem[_21911 + 32] = 1000
                                        mem[_21911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10185 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10185] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11834 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11834] = arg1
                                            mem[_11834 + 32] = 1000
                                            mem[_11834 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11834 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10185 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19669 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19669] == Mask(32, 224, mem[_19669])
                                            if Mask(32, 224, mem[_19669]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21916 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21916] = arg1
                                            mem[_21916 + 32] = 1000
                                            mem[_21916 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21916 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19489 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19489] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22903] = arg1
                                            mem[_22903 + 32] = 1000
                                            mem[_22903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22903 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19489 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26979 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26979] == Mask(32, 224, mem[_26979])
                                            if Mask(32, 224, mem[_26979]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28707 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28707] = arg1
                                            mem[_28707 + 32] = 1000
                                            mem[_28707 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28707 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10186 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10186] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11835 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11835] = arg1
                                        mem[_11835 + 32] = 1000
                                        mem[_11835 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11835 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10186 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19671 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19671] == Mask(32, 224, mem[_19671])
                                        if Mask(32, 224, mem[_19671]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21920 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21920] = arg1
                                        mem[_21920 + 32] = 1000
                                        mem[_21920 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21920 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10188 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10188] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11836 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11836] = arg1
                                            mem[_11836 + 32] = 1000
                                            mem[_11836 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11836 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10188 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19673 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19673] == Mask(32, 224, mem[_19673])
                                            if Mask(32, 224, mem[_19673]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21925 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21925] = arg1
                                            mem[_21925 + 32] = 1000
                                            mem[_21925 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21925 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19494 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19494] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22904 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22904] = arg1
                                            mem[_22904 + 32] = 1000
                                            mem[_22904 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22904 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19494 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26981 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26981] == Mask(32, 224, mem[_26981])
                                            if Mask(32, 224, mem[_26981]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28711 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28711] = arg1
                                            mem[_28711 + 32] = 1000
                                            mem[_28711 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28711 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10189 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10189] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11837 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11837] = arg1
                                        mem[_11837 + 32] = 1000
                                        mem[_11837 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11837 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10189 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19675 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19675] == Mask(32, 224, mem[_19675])
                                        if Mask(32, 224, mem[_19675]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21929 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21929] = arg1
                                        mem[_21929 + 32] = 1000
                                        mem[_21929 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21929 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10191 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10191] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11838 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11838] = arg1
                                            mem[_11838 + 32] = 1000
                                            mem[_11838 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11838 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10191 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19677 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19677] == Mask(32, 224, mem[_19677])
                                            if Mask(32, 224, mem[_19677]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21934 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21934] = arg1
                                            mem[_21934 + 32] = 1000
                                            mem[_21934 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21934 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19499 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19499] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22905 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22905] = arg1
                                            mem[_22905 + 32] = 1000
                                            mem[_22905 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22905 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19499 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26983 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26983] == Mask(32, 224, mem[_26983])
                                            if Mask(32, 224, mem[_26983]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28715 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28715] = arg1
                                            mem[_28715 + 32] = 1000
                                            mem[_28715 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28715 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10192 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10192] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11839 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11839] = arg1
                                        mem[_11839 + 32] = 1000
                                        mem[_11839 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11839 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10192 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19679 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19679] == Mask(32, 224, mem[_19679])
                                        if Mask(32, 224, mem[_19679]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21938 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21938] = arg1
                                        mem[_21938 + 32] = 1000
                                        mem[_21938 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21938 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10194 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10194] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11840 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11840] = arg1
                                            mem[_11840 + 32] = 1000
                                            mem[_11840 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11840 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10194 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19681 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19681] == Mask(32, 224, mem[_19681])
                                            if Mask(32, 224, mem[_19681]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21943 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21943] = arg1
                                            mem[_21943 + 32] = 1000
                                            mem[_21943 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21943 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19504 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19504] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22906 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22906] = arg1
                                            mem[_22906 + 32] = 1000
                                            mem[_22906 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22906 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19504 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26985 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26985] == Mask(32, 224, mem[_26985])
                                            if Mask(32, 224, mem[_26985]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28719 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28719] = arg1
                                            mem[_28719 + 32] = 1000
                                            mem[_28719 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28719 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19475 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19475] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22895 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22895] = arg1
                                        mem[_22895 + 32] = 1000
                                        mem[_22895 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22895 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19475 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26963 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26963] == Mask(32, 224, mem[_26963])
                                        if Mask(32, 224, mem[_26963]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28671 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28671] = arg1
                                        mem[_28671 + 32] = 1000
                                        mem[_28671 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28671 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19477 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19477] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22896 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22896] = arg1
                                            mem[_22896 + 32] = 1000
                                            mem[_22896 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22896 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19477 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26965 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26965] == Mask(32, 224, mem[_26965])
                                            if Mask(32, 224, mem[_26965]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28676 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28676] = arg1
                                            mem[_28676 + 32] = 1000
                                            mem[_28676 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28676 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26825 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26825] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29519 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29519] = arg1
                                            mem[_29519 + 32] = 1000
                                            mem[_29519 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29519 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26825 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30323 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30323] == Mask(32, 224, mem[_30323])
                                            if Mask(32, 224, mem[_30323]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30715 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30715] = arg1
                                            mem[_30715 + 32] = 1000
                                            mem[_30715 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30715 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19478 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19478] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22897 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22897] = arg1
                                        mem[_22897 + 32] = 1000
                                        mem[_22897 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22897 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19478 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26967 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26967] == Mask(32, 224, mem[_26967])
                                        if Mask(32, 224, mem[_26967]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28680 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28680] = arg1
                                        mem[_28680 + 32] = 1000
                                        mem[_28680 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28680 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19480 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19480] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22898 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22898] = arg1
                                            mem[_22898 + 32] = 1000
                                            mem[_22898 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22898 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19480 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26969 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26969] == Mask(32, 224, mem[_26969])
                                            if Mask(32, 224, mem[_26969]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28685 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28685] = arg1
                                            mem[_28685 + 32] = 1000
                                            mem[_28685 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28685 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26830 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26830] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29520 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29520] = arg1
                                            mem[_29520 + 32] = 1000
                                            mem[_29520 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29520 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26830 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30325 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30325] == Mask(32, 224, mem[_30325])
                                            if Mask(32, 224, mem[_30325]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30719 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30719] = arg1
                                            mem[_30719 + 32] = 1000
                                            mem[_30719 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30719 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19481 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19481] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22899 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22899] = arg1
                                        mem[_22899 + 32] = 1000
                                        mem[_22899 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22899 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19481 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26971 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26971] == Mask(32, 224, mem[_26971])
                                        if Mask(32, 224, mem[_26971]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28689 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28689] = arg1
                                        mem[_28689 + 32] = 1000
                                        mem[_28689 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28689 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19483 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19483] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22900 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22900] = arg1
                                            mem[_22900 + 32] = 1000
                                            mem[_22900 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22900 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19483 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26973 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26973] == Mask(32, 224, mem[_26973])
                                            if Mask(32, 224, mem[_26973]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28694 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28694] = arg1
                                            mem[_28694 + 32] = 1000
                                            mem[_28694 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28694 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26835 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26835] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29521 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29521] = arg1
                                            mem[_29521 + 32] = 1000
                                            mem[_29521 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29521 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26835 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30327 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30327] == Mask(32, 224, mem[_30327])
                                            if Mask(32, 224, mem[_30327]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30723 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30723] = arg1
                                            mem[_30723 + 32] = 1000
                                            mem[_30723 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30723 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19484 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19484] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22901 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22901] = arg1
                                        mem[_22901 + 32] = 1000
                                        mem[_22901 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22901 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19484 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26975 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26975] == Mask(32, 224, mem[_26975])
                                        if Mask(32, 224, mem[_26975]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28698 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28698] = arg1
                                        mem[_28698 + 32] = 1000
                                        mem[_28698 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28698 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19486 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19486] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22902 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22902] = arg1
                                            mem[_22902 + 32] = 1000
                                            mem[_22902 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22902 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19486 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26977 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26977] == Mask(32, 224, mem[_26977])
                                            if Mask(32, 224, mem[_26977]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28703] = arg1
                                            mem[_28703 + 32] = 1000
                                            mem[_28703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26840 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26840] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29522 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29522] = arg1
                                            mem[_29522 + 32] = 1000
                                            mem[_29522 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29522 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26840 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30329 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30329] == Mask(32, 224, mem[_30329])
                                            if Mask(32, 224, mem[_30329]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30727 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30727] = arg1
                                            mem[_30727 + 32] = 1000
                                            mem[_30727 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30727 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
    else:
        if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
            revert with 0, 34
        mem[352] = sub_be75288d[arg1].field_1 % 128
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10195 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10195] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11841 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11841] = arg1
                                    mem[_11841 + 32] = 1000
                                    mem[_11841 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11841 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10195 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19683 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19683] == Mask(32, 224, mem[_19683])
                                    if Mask(32, 224, mem[_19683]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21947 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21947] = arg1
                                    mem[_21947 + 32] = 1000
                                    mem[_21947 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21947 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10197 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10197] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11842 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11842] = arg1
                                        mem[_11842 + 32] = 1000
                                        mem[_11842 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11842 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10197 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19685 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19685] == Mask(32, 224, mem[_19685])
                                        if Mask(32, 224, mem[_19685]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21952 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21952] = arg1
                                        mem[_21952 + 32] = 1000
                                        mem[_21952 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21952 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19509 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19509] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22907 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22907] = arg1
                                        mem[_22907 + 32] = 1000
                                        mem[_22907 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22907 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19509 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26987 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26987] == Mask(32, 224, mem[_26987])
                                        if Mask(32, 224, mem[_26987]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28723 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28723] = arg1
                                        mem[_28723 + 32] = 1000
                                        mem[_28723 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28723 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10198 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10198] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11843 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11843] = arg1
                                    mem[_11843 + 32] = 1000
                                    mem[_11843 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11843 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10198 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19687 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19687] == Mask(32, 224, mem[_19687])
                                    if Mask(32, 224, mem[_19687]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21956 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21956] = arg1
                                    mem[_21956 + 32] = 1000
                                    mem[_21956 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21956 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10200 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10200] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11844 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11844] = arg1
                                        mem[_11844 + 32] = 1000
                                        mem[_11844 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11844 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10200 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19689 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19689] == Mask(32, 224, mem[_19689])
                                        if Mask(32, 224, mem[_19689]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21961 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21961] = arg1
                                        mem[_21961 + 32] = 1000
                                        mem[_21961 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21961 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19514 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19514] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22908 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22908] = arg1
                                        mem[_22908 + 32] = 1000
                                        mem[_22908 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22908 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19514 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26989 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26989] == Mask(32, 224, mem[_26989])
                                        if Mask(32, 224, mem[_26989]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28727 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28727] = arg1
                                        mem[_28727 + 32] = 1000
                                        mem[_28727 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28727 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10201 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10201] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11845 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11845] = arg1
                                    mem[_11845 + 32] = 1000
                                    mem[_11845 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11845 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10201 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19691 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19691] == Mask(32, 224, mem[_19691])
                                    if Mask(32, 224, mem[_19691]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21965 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21965] = arg1
                                    mem[_21965 + 32] = 1000
                                    mem[_21965 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21965 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10203 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10203] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11846 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11846] = arg1
                                        mem[_11846 + 32] = 1000
                                        mem[_11846 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11846 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10203 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19693 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19693] == Mask(32, 224, mem[_19693])
                                        if Mask(32, 224, mem[_19693]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21970 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21970] = arg1
                                        mem[_21970 + 32] = 1000
                                        mem[_21970 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21970 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19519 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19519] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22909 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22909] = arg1
                                        mem[_22909 + 32] = 1000
                                        mem[_22909 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22909 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19519 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26991 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26991] == Mask(32, 224, mem[_26991])
                                        if Mask(32, 224, mem[_26991]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28731 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28731] = arg1
                                        mem[_28731 + 32] = 1000
                                        mem[_28731 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28731 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10204 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10204] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11847 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11847] = arg1
                                    mem[_11847 + 32] = 1000
                                    mem[_11847 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11847 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10204 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19695 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19695] == Mask(32, 224, mem[_19695])
                                    if Mask(32, 224, mem[_19695]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21974 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21974] = arg1
                                    mem[_21974 + 32] = 1000
                                    mem[_21974 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21974 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10206 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10206] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11848 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11848] = arg1
                                        mem[_11848 + 32] = 1000
                                        mem[_11848 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11848 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10206 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19697 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19697] == Mask(32, 224, mem[_19697])
                                        if Mask(32, 224, mem[_19697]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21979 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21979] = arg1
                                        mem[_21979 + 32] = 1000
                                        mem[_21979 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21979 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19524 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19524] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22910 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22910] = arg1
                                        mem[_22910 + 32] = 1000
                                        mem[_22910 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22910 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19524 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26993 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26993] == Mask(32, 224, mem[_26993])
                                        if Mask(32, 224, mem[_26993]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28735 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28735] = arg1
                                        mem[_28735 + 32] = 1000
                                        mem[_28735 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28735 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10207 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10207] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11852 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11852] = arg1
                                        mem[_11852 + 32] = 1000
                                        mem[_11852 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11852 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10207 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19703 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19703] == Mask(32, 224, mem[_19703])
                                        if Mask(32, 224, mem[_19703]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21999 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21999] = arg1
                                        mem[_21999 + 32] = 1000
                                        mem[_21999 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21999 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10209 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10209] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11853 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11853] = arg1
                                            mem[_11853 + 32] = 1000
                                            mem[_11853 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11853 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10209 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19705] == Mask(32, 224, mem[_19705])
                                            if Mask(32, 224, mem[_19705]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22004 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22004] = arg1
                                            mem[_22004 + 32] = 1000
                                            mem[_22004 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22004 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19541 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19541] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22919 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22919] = arg1
                                            mem[_22919 + 32] = 1000
                                            mem[_22919 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22919 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19541 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27011 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27011] == Mask(32, 224, mem[_27011])
                                            if Mask(32, 224, mem[_27011]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28775 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28775] = arg1
                                            mem[_28775 + 32] = 1000
                                            mem[_28775 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28775 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10210 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10210] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11854 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11854] = arg1
                                        mem[_11854 + 32] = 1000
                                        mem[_11854 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11854 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10210 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19707 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19707] == Mask(32, 224, mem[_19707])
                                        if Mask(32, 224, mem[_19707]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22008 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22008] = arg1
                                        mem[_22008 + 32] = 1000
                                        mem[_22008 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22008 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10212 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10212] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11855] = arg1
                                            mem[_11855 + 32] = 1000
                                            mem[_11855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10212 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19709 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19709] == Mask(32, 224, mem[_19709])
                                            if Mask(32, 224, mem[_19709]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22013 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22013] = arg1
                                            mem[_22013 + 32] = 1000
                                            mem[_22013 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22013 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19546 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19546] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22920 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22920] = arg1
                                            mem[_22920 + 32] = 1000
                                            mem[_22920 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22920 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19546 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27013 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27013] == Mask(32, 224, mem[_27013])
                                            if Mask(32, 224, mem[_27013]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28779 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28779] = arg1
                                            mem[_28779 + 32] = 1000
                                            mem[_28779 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28779 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10213 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10213] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11856 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11856] = arg1
                                        mem[_11856 + 32] = 1000
                                        mem[_11856 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11856 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10213 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19711 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19711] == Mask(32, 224, mem[_19711])
                                        if Mask(32, 224, mem[_19711]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22017 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22017] = arg1
                                        mem[_22017 + 32] = 1000
                                        mem[_22017 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22017 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10215 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10215] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11857 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11857] = arg1
                                            mem[_11857 + 32] = 1000
                                            mem[_11857 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11857 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10215 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19713 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19713] == Mask(32, 224, mem[_19713])
                                            if Mask(32, 224, mem[_19713]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22022 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22022] = arg1
                                            mem[_22022 + 32] = 1000
                                            mem[_22022 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22022 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19551 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19551] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22921 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22921] = arg1
                                            mem[_22921 + 32] = 1000
                                            mem[_22921 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22921 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19551 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27015 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27015] == Mask(32, 224, mem[_27015])
                                            if Mask(32, 224, mem[_27015]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28783 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28783] = arg1
                                            mem[_28783 + 32] = 1000
                                            mem[_28783 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28783 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10216 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10216] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11858 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11858] = arg1
                                        mem[_11858 + 32] = 1000
                                        mem[_11858 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11858 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10216 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19715 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19715] == Mask(32, 224, mem[_19715])
                                        if Mask(32, 224, mem[_19715]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22026 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22026] = arg1
                                        mem[_22026 + 32] = 1000
                                        mem[_22026 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22026 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10218 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10218] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11859 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11859] = arg1
                                            mem[_11859 + 32] = 1000
                                            mem[_11859 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11859 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10218 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19717 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19717] == Mask(32, 224, mem[_19717])
                                            if Mask(32, 224, mem[_19717]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22031 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22031] = arg1
                                            mem[_22031 + 32] = 1000
                                            mem[_22031 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22031 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19556 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19556] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22922 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22922] = arg1
                                            mem[_22922 + 32] = 1000
                                            mem[_22922 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22922 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19556 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27017 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27017] == Mask(32, 224, mem[_27017])
                                            if Mask(32, 224, mem[_27017]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28787 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28787] = arg1
                                            mem[_28787 + 32] = 1000
                                            mem[_28787 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28787 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19527 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19527] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22911] = arg1
                                        mem[_22911 + 32] = 1000
                                        mem[_22911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19527 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26995 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26995] == Mask(32, 224, mem[_26995])
                                        if Mask(32, 224, mem[_26995]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28739 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28739] = arg1
                                        mem[_28739 + 32] = 1000
                                        mem[_28739 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28739 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19529 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19529] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22912 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22912] = arg1
                                            mem[_22912 + 32] = 1000
                                            mem[_22912 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22912 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19529 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26997 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26997] == Mask(32, 224, mem[_26997])
                                            if Mask(32, 224, mem[_26997]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28744 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28744] = arg1
                                            mem[_28744 + 32] = 1000
                                            mem[_28744 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28744 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26861 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26861] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29523 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29523] = arg1
                                            mem[_29523 + 32] = 1000
                                            mem[_29523 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29523 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26861 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30331 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30331] == Mask(32, 224, mem[_30331])
                                            if Mask(32, 224, mem[_30331]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30731 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30731] = arg1
                                            mem[_30731 + 32] = 1000
                                            mem[_30731 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30731 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19530 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19530] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22913 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22913] = arg1
                                        mem[_22913 + 32] = 1000
                                        mem[_22913 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22913 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19530 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26999 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26999] == Mask(32, 224, mem[_26999])
                                        if Mask(32, 224, mem[_26999]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28748 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28748] = arg1
                                        mem[_28748 + 32] = 1000
                                        mem[_28748 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28748 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19532 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19532] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22914 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22914] = arg1
                                            mem[_22914 + 32] = 1000
                                            mem[_22914 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22914 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19532 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27001 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27001] == Mask(32, 224, mem[_27001])
                                            if Mask(32, 224, mem[_27001]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28753 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28753] = arg1
                                            mem[_28753 + 32] = 1000
                                            mem[_28753 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28753 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26866 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26866] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29524 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29524] = arg1
                                            mem[_29524 + 32] = 1000
                                            mem[_29524 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29524 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26866 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30333 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30333] == Mask(32, 224, mem[_30333])
                                            if Mask(32, 224, mem[_30333]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30735 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30735] = arg1
                                            mem[_30735 + 32] = 1000
                                            mem[_30735 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30735 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19533 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19533] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22915 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22915] = arg1
                                        mem[_22915 + 32] = 1000
                                        mem[_22915 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22915 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19533 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27003 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27003] == Mask(32, 224, mem[_27003])
                                        if Mask(32, 224, mem[_27003]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28757 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28757] = arg1
                                        mem[_28757 + 32] = 1000
                                        mem[_28757 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28757 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19535 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19535] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22916 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22916] = arg1
                                            mem[_22916 + 32] = 1000
                                            mem[_22916 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22916 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19535 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27005 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27005] == Mask(32, 224, mem[_27005])
                                            if Mask(32, 224, mem[_27005]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28762 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28762] = arg1
                                            mem[_28762 + 32] = 1000
                                            mem[_28762 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28762 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26871 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26871] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29525 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29525] = arg1
                                            mem[_29525 + 32] = 1000
                                            mem[_29525 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29525 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26871 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30335 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30335] == Mask(32, 224, mem[_30335])
                                            if Mask(32, 224, mem[_30335]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30739 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30739] = arg1
                                            mem[_30739 + 32] = 1000
                                            mem[_30739 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30739 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19536 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19536] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22917 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22917] = arg1
                                        mem[_22917 + 32] = 1000
                                        mem[_22917 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22917 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19536 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27007 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27007] == Mask(32, 224, mem[_27007])
                                        if Mask(32, 224, mem[_27007]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28766 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28766] = arg1
                                        mem[_28766 + 32] = 1000
                                        mem[_28766 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28766 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19538 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19538] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22918 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22918] = arg1
                                            mem[_22918 + 32] = 1000
                                            mem[_22918 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22918 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19538 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27009 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27009] == Mask(32, 224, mem[_27009])
                                            if Mask(32, 224, mem[_27009]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28771 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28771] = arg1
                                            mem[_28771 + 32] = 1000
                                            mem[_28771 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28771 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26876 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26876] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29526 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29526] = arg1
                                            mem[_29526 + 32] = 1000
                                            mem[_29526 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29526 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26876 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30337 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30337] == Mask(32, 224, mem[_30337])
                                            if Mask(32, 224, mem[_30337]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30743 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30743] = arg1
                                            mem[_30743 + 32] = 1000
                                            mem[_30743 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30743 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10219 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10219] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11860 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11860] = arg1
                                    mem[_11860 + 32] = 1000
                                    mem[_11860 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11860 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10219 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19719 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19719] == Mask(32, 224, mem[_19719])
                                    if Mask(32, 224, mem[_19719]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22035 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22035] = arg1
                                    mem[_22035 + 32] = 1000
                                    mem[_22035 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22035 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10221 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10221] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11861 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11861] = arg1
                                        mem[_11861 + 32] = 1000
                                        mem[_11861 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11861 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10221 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19721 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19721] == Mask(32, 224, mem[_19721])
                                        if Mask(32, 224, mem[_19721]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22040 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22040] = arg1
                                        mem[_22040 + 32] = 1000
                                        mem[_22040 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22040 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19561 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19561] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22923 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22923] = arg1
                                        mem[_22923 + 32] = 1000
                                        mem[_22923 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22923 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19561 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27019 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27019] == Mask(32, 224, mem[_27019])
                                        if Mask(32, 224, mem[_27019]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28791 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28791] = arg1
                                        mem[_28791 + 32] = 1000
                                        mem[_28791 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10222 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10222] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11862 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11862] = arg1
                                    mem[_11862 + 32] = 1000
                                    mem[_11862 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11862 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10222 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19723 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19723] == Mask(32, 224, mem[_19723])
                                    if Mask(32, 224, mem[_19723]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22044 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22044] = arg1
                                    mem[_22044 + 32] = 1000
                                    mem[_22044 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22044 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10224 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10224] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11863 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11863] = arg1
                                        mem[_11863 + 32] = 1000
                                        mem[_11863 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11863 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10224 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19725] == Mask(32, 224, mem[_19725])
                                        if Mask(32, 224, mem[_19725]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22049 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22049] = arg1
                                        mem[_22049 + 32] = 1000
                                        mem[_22049 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22049 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19566 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19566] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22924 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22924] = arg1
                                        mem[_22924 + 32] = 1000
                                        mem[_22924 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22924 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19566 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27021 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27021] == Mask(32, 224, mem[_27021])
                                        if Mask(32, 224, mem[_27021]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28795 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28795] = arg1
                                        mem[_28795 + 32] = 1000
                                        mem[_28795 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28795 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10225 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10225] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11864 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11864] = arg1
                                    mem[_11864 + 32] = 1000
                                    mem[_11864 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11864 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10225 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19727 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19727] == Mask(32, 224, mem[_19727])
                                    if Mask(32, 224, mem[_19727]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22053 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22053] = arg1
                                    mem[_22053 + 32] = 1000
                                    mem[_22053 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22053 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10227 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10227] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11865 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11865] = arg1
                                        mem[_11865 + 32] = 1000
                                        mem[_11865 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11865 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10227 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19729 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19729] == Mask(32, 224, mem[_19729])
                                        if Mask(32, 224, mem[_19729]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22058 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22058] = arg1
                                        mem[_22058 + 32] = 1000
                                        mem[_22058 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22058 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19571 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19571] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22925 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22925] = arg1
                                        mem[_22925 + 32] = 1000
                                        mem[_22925 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22925 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19571 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27023 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27023] == Mask(32, 224, mem[_27023])
                                        if Mask(32, 224, mem[_27023]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28799 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28799] = arg1
                                        mem[_28799 + 32] = 1000
                                        mem[_28799 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28799 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10228 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10228] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11866 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11866] = arg1
                                    mem[_11866 + 32] = 1000
                                    mem[_11866 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11866 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10228 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19731 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19731] == Mask(32, 224, mem[_19731])
                                    if Mask(32, 224, mem[_19731]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22062 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22062] = arg1
                                    mem[_22062 + 32] = 1000
                                    mem[_22062 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22062 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10230 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10230] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11867 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11867] = arg1
                                        mem[_11867 + 32] = 1000
                                        mem[_11867 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11867 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10230 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19733] == Mask(32, 224, mem[_19733])
                                        if Mask(32, 224, mem[_19733]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22067 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22067] = arg1
                                        mem[_22067 + 32] = 1000
                                        mem[_22067 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22067 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19576 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19576] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22926 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22926] = arg1
                                        mem[_22926 + 32] = 1000
                                        mem[_22926 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22926 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19576 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27025 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27025] == Mask(32, 224, mem[_27025])
                                        if Mask(32, 224, mem[_27025]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28803 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28803] = arg1
                                        mem[_28803 + 32] = 1000
                                        mem[_28803 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10231 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10231] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11871 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11871] = arg1
                                        mem[_11871 + 32] = 1000
                                        mem[_11871 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11871 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10231 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19739 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19739] == Mask(32, 224, mem[_19739])
                                        if Mask(32, 224, mem[_19739]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22087 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22087] = arg1
                                        mem[_22087 + 32] = 1000
                                        mem[_22087 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22087 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10233 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10233] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11872 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11872] = arg1
                                            mem[_11872 + 32] = 1000
                                            mem[_11872 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11872 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10233 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19741 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19741] == Mask(32, 224, mem[_19741])
                                            if Mask(32, 224, mem[_19741]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22092 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22092] = arg1
                                            mem[_22092 + 32] = 1000
                                            mem[_22092 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22092 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19593 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19593] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22935 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22935] = arg1
                                            mem[_22935 + 32] = 1000
                                            mem[_22935 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22935 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19593 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27043 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27043] == Mask(32, 224, mem[_27043])
                                            if Mask(32, 224, mem[_27043]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28843 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28843] = arg1
                                            mem[_28843 + 32] = 1000
                                            mem[_28843 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28843 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10234 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10234] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11873 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11873] = arg1
                                        mem[_11873 + 32] = 1000
                                        mem[_11873 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11873 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10234 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19743] == Mask(32, 224, mem[_19743])
                                        if Mask(32, 224, mem[_19743]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22096 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22096] = arg1
                                        mem[_22096 + 32] = 1000
                                        mem[_22096 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22096 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10236 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10236] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11874 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11874] = arg1
                                            mem[_11874 + 32] = 1000
                                            mem[_11874 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11874 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10236 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19745] == Mask(32, 224, mem[_19745])
                                            if Mask(32, 224, mem[_19745]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22101 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22101] = arg1
                                            mem[_22101 + 32] = 1000
                                            mem[_22101 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22101 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19598 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19598] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22936 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22936] = arg1
                                            mem[_22936 + 32] = 1000
                                            mem[_22936 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22936 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19598 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27045 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27045] == Mask(32, 224, mem[_27045])
                                            if Mask(32, 224, mem[_27045]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28847 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28847] = arg1
                                            mem[_28847 + 32] = 1000
                                            mem[_28847 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28847 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10237 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10237] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11875 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11875] = arg1
                                        mem[_11875 + 32] = 1000
                                        mem[_11875 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11875 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10237 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19747 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19747] == Mask(32, 224, mem[_19747])
                                        if Mask(32, 224, mem[_19747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22105 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22105] = arg1
                                        mem[_22105 + 32] = 1000
                                        mem[_22105 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22105 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10239 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10239] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11876 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11876] = arg1
                                            mem[_11876 + 32] = 1000
                                            mem[_11876 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11876 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10239 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19749] == Mask(32, 224, mem[_19749])
                                            if Mask(32, 224, mem[_19749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22110 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22110] = arg1
                                            mem[_22110 + 32] = 1000
                                            mem[_22110 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22110 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19603 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19603] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22937 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22937] = arg1
                                            mem[_22937 + 32] = 1000
                                            mem[_22937 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22937 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19603 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27047 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27047] == Mask(32, 224, mem[_27047])
                                            if Mask(32, 224, mem[_27047]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28851 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28851] = arg1
                                            mem[_28851 + 32] = 1000
                                            mem[_28851 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28851 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10240 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10240] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11877 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11877] = arg1
                                        mem[_11877 + 32] = 1000
                                        mem[_11877 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11877 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10240 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19751 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19751] == Mask(32, 224, mem[_19751])
                                        if Mask(32, 224, mem[_19751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22114 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22114] = arg1
                                        mem[_22114 + 32] = 1000
                                        mem[_22114 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22114 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10242 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10242] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11878 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11878] = arg1
                                            mem[_11878 + 32] = 1000
                                            mem[_11878 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11878 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10242 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19753 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19753] == Mask(32, 224, mem[_19753])
                                            if Mask(32, 224, mem[_19753]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22119 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22119] = arg1
                                            mem[_22119 + 32] = 1000
                                            mem[_22119 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22119 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19608 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19608] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22938 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22938] = arg1
                                            mem[_22938 + 32] = 1000
                                            mem[_22938 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22938 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19608 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27049 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27049] == Mask(32, 224, mem[_27049])
                                            if Mask(32, 224, mem[_27049]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28855] = arg1
                                            mem[_28855 + 32] = 1000
                                            mem[_28855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19579 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19579] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22927 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22927] = arg1
                                        mem[_22927 + 32] = 1000
                                        mem[_22927 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22927 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19579 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27027 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27027] == Mask(32, 224, mem[_27027])
                                        if Mask(32, 224, mem[_27027]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28807 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28807] = arg1
                                        mem[_28807 + 32] = 1000
                                        mem[_28807 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28807 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19581 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19581] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22928 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22928] = arg1
                                            mem[_22928 + 32] = 1000
                                            mem[_22928 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22928 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19581 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27029 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27029] == Mask(32, 224, mem[_27029])
                                            if Mask(32, 224, mem[_27029]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28812 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28812] = arg1
                                            mem[_28812 + 32] = 1000
                                            mem[_28812 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28812 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26897 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26897] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29527 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29527] = arg1
                                            mem[_29527 + 32] = 1000
                                            mem[_29527 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29527 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26897 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30339 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30339] == Mask(32, 224, mem[_30339])
                                            if Mask(32, 224, mem[_30339]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30747 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30747] = arg1
                                            mem[_30747 + 32] = 1000
                                            mem[_30747 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30747 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19582 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19582] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22929 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22929] = arg1
                                        mem[_22929 + 32] = 1000
                                        mem[_22929 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22929 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19582 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27031 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27031] == Mask(32, 224, mem[_27031])
                                        if Mask(32, 224, mem[_27031]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28816 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28816] = arg1
                                        mem[_28816 + 32] = 1000
                                        mem[_28816 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28816 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19584 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19584] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22930 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22930] = arg1
                                            mem[_22930 + 32] = 1000
                                            mem[_22930 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22930 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19584 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27033] == Mask(32, 224, mem[_27033])
                                            if Mask(32, 224, mem[_27033]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28821 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28821] = arg1
                                            mem[_28821 + 32] = 1000
                                            mem[_28821 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28821 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26902 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26902] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29528 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29528] = arg1
                                            mem[_29528 + 32] = 1000
                                            mem[_29528 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29528 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26902 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30341 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30341] == Mask(32, 224, mem[_30341])
                                            if Mask(32, 224, mem[_30341]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30751 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30751] = arg1
                                            mem[_30751 + 32] = 1000
                                            mem[_30751 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30751 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19585 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19585] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22931 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22931] = arg1
                                        mem[_22931 + 32] = 1000
                                        mem[_22931 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22931 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19585 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27035 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27035] == Mask(32, 224, mem[_27035])
                                        if Mask(32, 224, mem[_27035]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28825 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28825] = arg1
                                        mem[_28825 + 32] = 1000
                                        mem[_28825 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28825 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19587 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19587] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22932 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22932] = arg1
                                            mem[_22932 + 32] = 1000
                                            mem[_22932 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22932 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19587 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27037] == Mask(32, 224, mem[_27037])
                                            if Mask(32, 224, mem[_27037]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28830 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28830] = arg1
                                            mem[_28830 + 32] = 1000
                                            mem[_28830 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28830 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26907 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26907] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29529 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29529] = arg1
                                            mem[_29529 + 32] = 1000
                                            mem[_29529 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29529 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26907 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30343 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30343] == Mask(32, 224, mem[_30343])
                                            if Mask(32, 224, mem[_30343]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30755 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30755] = arg1
                                            mem[_30755 + 32] = 1000
                                            mem[_30755 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30755 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19588 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19588] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22933 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22933] = arg1
                                        mem[_22933 + 32] = 1000
                                        mem[_22933 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22933 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19588 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27039 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27039] == Mask(32, 224, mem[_27039])
                                        if Mask(32, 224, mem[_27039]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28834 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28834] = arg1
                                        mem[_28834 + 32] = 1000
                                        mem[_28834 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28834 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19590 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19590] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22934 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22934] = arg1
                                            mem[_22934 + 32] = 1000
                                            mem[_22934 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22934 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19590 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27041 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27041] == Mask(32, 224, mem[_27041])
                                            if Mask(32, 224, mem[_27041]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28839 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28839] = arg1
                                            mem[_28839 + 32] = 1000
                                            mem[_28839 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28839 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26912 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26912] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29530 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29530] = arg1
                                            mem[_29530 + 32] = 1000
                                            mem[_29530 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29530 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26912 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30345 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30345] == Mask(32, 224, mem[_30345])
                                            if Mask(32, 224, mem[_30345]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30759 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30759] = arg1
                                            mem[_30759 + 32] = 1000
                                            mem[_30759 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30759 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
}

function sub_8706b531(?) payable {
    require calldata.size - 4 >= 64
    if paused:
        revert with 0, 'Pausable: paused'
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        mem[352] = uint255(sub_be75288d[arg1].field_0) * 0.5
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11923 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11923] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13539 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13539] = arg1
                                    mem[_13539 + 32] = 500
                                    mem[_13539 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13539 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11923 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22523 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22523] == Mask(32, 224, mem[_22523])
                                    if Mask(32, 224, mem[_22523]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24747 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24747] = arg1
                                    mem[_24747 + 32] = 500
                                    mem[_24747 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24747 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11924 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11924] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13540 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13540] = arg1
                                        mem[_13540 + 32] = 500
                                        mem[_13540 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13540 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11924 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22525 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22525] == Mask(32, 224, mem[_22525])
                                        if Mask(32, 224, mem[_22525]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24752 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24752] = arg1
                                        mem[_24752 + 32] = 500
                                        mem[_24752 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24752 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22269 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22269] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25771 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25771] = arg1
                                        mem[_25771 + 32] = 500
                                        mem[_25771 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25771 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22269 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30043 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30043] == Mask(32, 224, mem[_30043])
                                        if Mask(32, 224, mem[_30043]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31707 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31707] = arg1
                                        mem[_31707 + 32] = 500
                                        mem[_31707 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31707 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11925 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11925] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13541 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13541] = arg1
                                    mem[_13541 + 32] = 500
                                    mem[_13541 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13541 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11925 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22527 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22527] == Mask(32, 224, mem[_22527])
                                    if Mask(32, 224, mem[_22527]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24756 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24756] = arg1
                                    mem[_24756 + 32] = 500
                                    mem[_24756 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24756 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11926 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11926] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13542 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13542] = arg1
                                        mem[_13542 + 32] = 500
                                        mem[_13542 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13542 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11926 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22529 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22529] == Mask(32, 224, mem[_22529])
                                        if Mask(32, 224, mem[_22529]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24761 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24761] = arg1
                                        mem[_24761 + 32] = 500
                                        mem[_24761 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24761 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22274 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22274] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25772 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25772] = arg1
                                        mem[_25772 + 32] = 500
                                        mem[_25772 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25772 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22274 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30045 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30045] == Mask(32, 224, mem[_30045])
                                        if Mask(32, 224, mem[_30045]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31711 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31711] = arg1
                                        mem[_31711 + 32] = 500
                                        mem[_31711 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31711 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11927 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11927] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13543 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13543] = arg1
                                    mem[_13543 + 32] = 500
                                    mem[_13543 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13543 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11927 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22531 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22531] == Mask(32, 224, mem[_22531])
                                    if Mask(32, 224, mem[_22531]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24765 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24765] = arg1
                                    mem[_24765 + 32] = 500
                                    mem[_24765 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24765 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11928 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11928] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13544 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13544] = arg1
                                        mem[_13544 + 32] = 500
                                        mem[_13544 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13544 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11928 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22533 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22533] == Mask(32, 224, mem[_22533])
                                        if Mask(32, 224, mem[_22533]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24770 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24770] = arg1
                                        mem[_24770 + 32] = 500
                                        mem[_24770 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24770 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22279 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22279] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25773 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25773] = arg1
                                        mem[_25773 + 32] = 500
                                        mem[_25773 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25773 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22279 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30047 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30047] == Mask(32, 224, mem[_30047])
                                        if Mask(32, 224, mem[_30047]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31715 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31715] = arg1
                                        mem[_31715 + 32] = 500
                                        mem[_31715 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31715 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11929 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11929] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13545 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13545] = arg1
                                    mem[_13545 + 32] = 500
                                    mem[_13545 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13545 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11929 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22535 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22535] == Mask(32, 224, mem[_22535])
                                    if Mask(32, 224, mem[_22535]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24774 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24774] = arg1
                                    mem[_24774 + 32] = 500
                                    mem[_24774 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24774 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11930 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11930] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13546 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13546] = arg1
                                        mem[_13546 + 32] = 500
                                        mem[_13546 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13546 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11930 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22537 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22537] == Mask(32, 224, mem[_22537])
                                        if Mask(32, 224, mem[_22537]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24779 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24779] = arg1
                                        mem[_24779 + 32] = 500
                                        mem[_24779 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24779 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22284 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22284] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25774 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25774] = arg1
                                        mem[_25774 + 32] = 500
                                        mem[_25774 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25774 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22284 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30049 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30049] == Mask(32, 224, mem[_30049])
                                        if Mask(32, 224, mem[_30049]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31719 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31719] = arg1
                                        mem[_31719 + 32] = 500
                                        mem[_31719 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31719 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11931 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11931] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13564 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13564] = arg1
                                        mem[_13564 + 32] = 500
                                        mem[_13564 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13564 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11931 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22539 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22539] == Mask(32, 224, mem[_22539])
                                        if Mask(32, 224, mem[_22539]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24791 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24791] = arg1
                                        mem[_24791 + 32] = 500
                                        mem[_24791 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11932 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11932] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13565 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13565] = arg1
                                            mem[_13565 + 32] = 500
                                            mem[_13565 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13565 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11932 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22541 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22541] == Mask(32, 224, mem[_22541])
                                            if Mask(32, 224, mem[_22541]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24796 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24796] = arg1
                                            mem[_24796 + 32] = 500
                                            mem[_24796 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24796 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22297 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22297] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25783 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25783] = arg1
                                            mem[_25783 + 32] = 500
                                            mem[_25783 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25783 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22297 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30067 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30067] == Mask(32, 224, mem[_30067])
                                            if Mask(32, 224, mem[_30067]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31759 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31759] = arg1
                                            mem[_31759 + 32] = 500
                                            mem[_31759 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31759 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11933 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11933] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13566 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13566] = arg1
                                        mem[_13566 + 32] = 500
                                        mem[_13566 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13566 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11933 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22543 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22543] == Mask(32, 224, mem[_22543])
                                        if Mask(32, 224, mem[_22543]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24800 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24800] = arg1
                                        mem[_24800 + 32] = 500
                                        mem[_24800 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24800 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11934 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11934] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13567 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13567] = arg1
                                            mem[_13567 + 32] = 500
                                            mem[_13567 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13567 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11934 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22545 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22545] == Mask(32, 224, mem[_22545])
                                            if Mask(32, 224, mem[_22545]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24805 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24805] = arg1
                                            mem[_24805 + 32] = 500
                                            mem[_24805 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24805 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22302 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22302] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25784 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25784] = arg1
                                            mem[_25784 + 32] = 500
                                            mem[_25784 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25784 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22302 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30069 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30069] == Mask(32, 224, mem[_30069])
                                            if Mask(32, 224, mem[_30069]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31763 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31763] = arg1
                                            mem[_31763 + 32] = 500
                                            mem[_31763 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31763 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11935 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11935] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13568 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13568] = arg1
                                        mem[_13568 + 32] = 500
                                        mem[_13568 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13568 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11935 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22547 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22547] == Mask(32, 224, mem[_22547])
                                        if Mask(32, 224, mem[_22547]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24809 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24809] = arg1
                                        mem[_24809 + 32] = 500
                                        mem[_24809 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24809 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11936 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11936] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13569 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13569] = arg1
                                            mem[_13569 + 32] = 500
                                            mem[_13569 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13569 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11936 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22549 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22549] == Mask(32, 224, mem[_22549])
                                            if Mask(32, 224, mem[_22549]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24814 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24814] = arg1
                                            mem[_24814 + 32] = 500
                                            mem[_24814 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24814 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22307 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22307] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25785 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25785] = arg1
                                            mem[_25785 + 32] = 500
                                            mem[_25785 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25785 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22307 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30071 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30071] == Mask(32, 224, mem[_30071])
                                            if Mask(32, 224, mem[_30071]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31767 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31767] = arg1
                                            mem[_31767 + 32] = 500
                                            mem[_31767 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31767 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11937 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11937] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13570 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13570] = arg1
                                        mem[_13570 + 32] = 500
                                        mem[_13570 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13570 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11937 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22551 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22551] == Mask(32, 224, mem[_22551])
                                        if Mask(32, 224, mem[_22551]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24818 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24818] = arg1
                                        mem[_24818 + 32] = 500
                                        mem[_24818 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24818 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11938 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11938] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13571 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13571] = arg1
                                            mem[_13571 + 32] = 500
                                            mem[_13571 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13571 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11938 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22553 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22553] == Mask(32, 224, mem[_22553])
                                            if Mask(32, 224, mem[_22553]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24823 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24823] = arg1
                                            mem[_24823 + 32] = 500
                                            mem[_24823 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24823 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22312 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22312] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25786 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25786] = arg1
                                            mem[_25786 + 32] = 500
                                            mem[_25786 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25786 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22312 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30073 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30073] == Mask(32, 224, mem[_30073])
                                            if Mask(32, 224, mem[_30073]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31771 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31771] = arg1
                                            mem[_31771 + 32] = 500
                                            mem[_31771 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31771 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22287 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22287] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25775 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25775] = arg1
                                        mem[_25775 + 32] = 500
                                        mem[_25775 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25775 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22287 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30051 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30051] == Mask(32, 224, mem[_30051])
                                        if Mask(32, 224, mem[_30051]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31723 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31723] = arg1
                                        mem[_31723 + 32] = 500
                                        mem[_31723 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31723 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22288 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22288] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25776 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25776] = arg1
                                            mem[_25776 + 32] = 500
                                            mem[_25776 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25776 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22288 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30053] == Mask(32, 224, mem[_30053])
                                            if Mask(32, 224, mem[_30053]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31728 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31728] = arg1
                                            mem[_31728 + 32] = 500
                                            mem[_31728 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31728 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29909 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29909] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32635 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32635] = arg1
                                            mem[_32635 + 32] = 500
                                            mem[_32635 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29909 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33435 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33435] == Mask(32, 224, mem[_33435])
                                            if Mask(32, 224, mem[_33435]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33819 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33819] = arg1
                                            mem[_33819 + 32] = 500
                                            mem[_33819 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33819 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22289 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22289] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25777 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25777] = arg1
                                        mem[_25777 + 32] = 500
                                        mem[_25777 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25777 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22289 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30055 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30055] == Mask(32, 224, mem[_30055])
                                        if Mask(32, 224, mem[_30055]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31732 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31732] = arg1
                                        mem[_31732 + 32] = 500
                                        mem[_31732 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31732 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22290 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22290] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25778 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25778] = arg1
                                            mem[_25778 + 32] = 500
                                            mem[_25778 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25778 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22290 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30057 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30057] == Mask(32, 224, mem[_30057])
                                            if Mask(32, 224, mem[_30057]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31737 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31737] = arg1
                                            mem[_31737 + 32] = 500
                                            mem[_31737 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31737 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29914 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29914] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32636 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32636] = arg1
                                            mem[_32636 + 32] = 500
                                            mem[_32636 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32636 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29914 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33437 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33437] == Mask(32, 224, mem[_33437])
                                            if Mask(32, 224, mem[_33437]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33823 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33823] = arg1
                                            mem[_33823 + 32] = 500
                                            mem[_33823 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33823 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22291 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22291] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25779 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25779] = arg1
                                        mem[_25779 + 32] = 500
                                        mem[_25779 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25779 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22291 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30059 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30059] == Mask(32, 224, mem[_30059])
                                        if Mask(32, 224, mem[_30059]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31741 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31741] = arg1
                                        mem[_31741 + 32] = 500
                                        mem[_31741 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31741 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22292 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22292] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25780 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25780] = arg1
                                            mem[_25780 + 32] = 500
                                            mem[_25780 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25780 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22292 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30061 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30061] == Mask(32, 224, mem[_30061])
                                            if Mask(32, 224, mem[_30061]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31746 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31746] = arg1
                                            mem[_31746 + 32] = 500
                                            mem[_31746 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31746 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29919 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29919] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32637 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32637] = arg1
                                            mem[_32637 + 32] = 500
                                            mem[_32637 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32637 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29919 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33439 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33439] == Mask(32, 224, mem[_33439])
                                            if Mask(32, 224, mem[_33439]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33827 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33827] = arg1
                                            mem[_33827 + 32] = 500
                                            mem[_33827 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33827 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22293 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22293] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25781 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25781] = arg1
                                        mem[_25781 + 32] = 500
                                        mem[_25781 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25781 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22293 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30063 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30063] == Mask(32, 224, mem[_30063])
                                        if Mask(32, 224, mem[_30063]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31750 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31750] = arg1
                                        mem[_31750 + 32] = 500
                                        mem[_31750 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31750 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22294 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22294] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25782 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25782] = arg1
                                            mem[_25782 + 32] = 500
                                            mem[_25782 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25782 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22294 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30065 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30065] == Mask(32, 224, mem[_30065])
                                            if Mask(32, 224, mem[_30065]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31755 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31755] = arg1
                                            mem[_31755 + 32] = 500
                                            mem[_31755 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31755 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29924 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29924] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32638 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32638] = arg1
                                            mem[_32638 + 32] = 500
                                            mem[_32638 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32638 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29924 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33441 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33441] == Mask(32, 224, mem[_33441])
                                            if Mask(32, 224, mem[_33441]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33831 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33831] = arg1
                                            mem[_33831 + 32] = 500
                                            mem[_33831 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33831 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11939 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11939] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13572 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13572] = arg1
                                    mem[_13572 + 32] = 500
                                    mem[_13572 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13572 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11939 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22555 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22555] == Mask(32, 224, mem[_22555])
                                    if Mask(32, 224, mem[_22555]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24827 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24827] = arg1
                                    mem[_24827 + 32] = 500
                                    mem[_24827 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24827 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11940 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11940] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13573 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13573] = arg1
                                        mem[_13573 + 32] = 500
                                        mem[_13573 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13573 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11940 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22557 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22557] == Mask(32, 224, mem[_22557])
                                        if Mask(32, 224, mem[_22557]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24832 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24832] = arg1
                                        mem[_24832 + 32] = 500
                                        mem[_24832 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24832 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22317 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22317] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25787 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25787] = arg1
                                        mem[_25787 + 32] = 500
                                        mem[_25787 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25787 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22317 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30075 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30075] == Mask(32, 224, mem[_30075])
                                        if Mask(32, 224, mem[_30075]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31775 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31775] = arg1
                                        mem[_31775 + 32] = 500
                                        mem[_31775 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31775 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11941 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11941] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13574 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13574] = arg1
                                    mem[_13574 + 32] = 500
                                    mem[_13574 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13574 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11941 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22559] == Mask(32, 224, mem[_22559])
                                    if Mask(32, 224, mem[_22559]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24836 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24836] = arg1
                                    mem[_24836 + 32] = 500
                                    mem[_24836 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24836 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11942 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11942] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13575 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13575] = arg1
                                        mem[_13575 + 32] = 500
                                        mem[_13575 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13575 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11942 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22561 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22561] == Mask(32, 224, mem[_22561])
                                        if Mask(32, 224, mem[_22561]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24841 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24841] = arg1
                                        mem[_24841 + 32] = 500
                                        mem[_24841 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24841 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22322 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22322] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25788 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25788] = arg1
                                        mem[_25788 + 32] = 500
                                        mem[_25788 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25788 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22322 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30077 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30077] == Mask(32, 224, mem[_30077])
                                        if Mask(32, 224, mem[_30077]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31779 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31779] = arg1
                                        mem[_31779 + 32] = 500
                                        mem[_31779 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31779 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11943 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11943] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13576 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13576] = arg1
                                    mem[_13576 + 32] = 500
                                    mem[_13576 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13576 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11943 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22563] == Mask(32, 224, mem[_22563])
                                    if Mask(32, 224, mem[_22563]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24845 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24845] = arg1
                                    mem[_24845 + 32] = 500
                                    mem[_24845 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24845 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11944 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11944] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13577 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13577] = arg1
                                        mem[_13577 + 32] = 500
                                        mem[_13577 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13577 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11944 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22565 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22565] == Mask(32, 224, mem[_22565])
                                        if Mask(32, 224, mem[_22565]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24850 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24850] = arg1
                                        mem[_24850 + 32] = 500
                                        mem[_24850 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24850 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22327 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22327] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25789 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25789] = arg1
                                        mem[_25789 + 32] = 500
                                        mem[_25789 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25789 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22327 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30079 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30079] == Mask(32, 224, mem[_30079])
                                        if Mask(32, 224, mem[_30079]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31783 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31783] = arg1
                                        mem[_31783 + 32] = 500
                                        mem[_31783 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31783 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11945 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11945] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13578 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13578] = arg1
                                    mem[_13578 + 32] = 500
                                    mem[_13578 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13578 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11945 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22567] == Mask(32, 224, mem[_22567])
                                    if Mask(32, 224, mem[_22567]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24854 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24854] = arg1
                                    mem[_24854 + 32] = 500
                                    mem[_24854 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24854 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11946 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11946] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13579 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13579] = arg1
                                        mem[_13579 + 32] = 500
                                        mem[_13579 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13579 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11946 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22569 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22569] == Mask(32, 224, mem[_22569])
                                        if Mask(32, 224, mem[_22569]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24859 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24859] = arg1
                                        mem[_24859 + 32] = 500
                                        mem[_24859 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24859 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22332 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22332] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25790 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25790] = arg1
                                        mem[_25790 + 32] = 500
                                        mem[_25790 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25790 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22332 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30081 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30081] == Mask(32, 224, mem[_30081])
                                        if Mask(32, 224, mem[_30081]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31787 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31787] = arg1
                                        mem[_31787 + 32] = 500
                                        mem[_31787 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31787 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11947 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11947] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13597 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13597] = arg1
                                        mem[_13597 + 32] = 500
                                        mem[_13597 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13597 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11947 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22571 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22571] == Mask(32, 224, mem[_22571])
                                        if Mask(32, 224, mem[_22571]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24871 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24871] = arg1
                                        mem[_24871 + 32] = 500
                                        mem[_24871 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24871 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11948 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11948] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13598 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13598] = arg1
                                            mem[_13598 + 32] = 500
                                            mem[_13598 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13598 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11948 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22573 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22573] == Mask(32, 224, mem[_22573])
                                            if Mask(32, 224, mem[_22573]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24876 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24876] = arg1
                                            mem[_24876 + 32] = 500
                                            mem[_24876 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24876 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22345 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22345] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25799 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25799] = arg1
                                            mem[_25799 + 32] = 500
                                            mem[_25799 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25799 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22345 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30099 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30099] == Mask(32, 224, mem[_30099])
                                            if Mask(32, 224, mem[_30099]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31827 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31827] = arg1
                                            mem[_31827 + 32] = 500
                                            mem[_31827 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31827 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11949 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11949] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13599 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13599] = arg1
                                        mem[_13599 + 32] = 500
                                        mem[_13599 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13599 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11949 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22575 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22575] == Mask(32, 224, mem[_22575])
                                        if Mask(32, 224, mem[_22575]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24880 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24880] = arg1
                                        mem[_24880 + 32] = 500
                                        mem[_24880 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24880 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11950 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11950] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13600 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13600] = arg1
                                            mem[_13600 + 32] = 500
                                            mem[_13600 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13600 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11950 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22577 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22577] == Mask(32, 224, mem[_22577])
                                            if Mask(32, 224, mem[_22577]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24885 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24885] = arg1
                                            mem[_24885 + 32] = 500
                                            mem[_24885 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24885 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22350 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22350] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25800 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25800] = arg1
                                            mem[_25800 + 32] = 500
                                            mem[_25800 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25800 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22350 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30101 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30101] == Mask(32, 224, mem[_30101])
                                            if Mask(32, 224, mem[_30101]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31831 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31831] = arg1
                                            mem[_31831 + 32] = 500
                                            mem[_31831 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31831 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11951 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11951] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13601 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13601] = arg1
                                        mem[_13601 + 32] = 500
                                        mem[_13601 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13601 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11951 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22579 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22579] == Mask(32, 224, mem[_22579])
                                        if Mask(32, 224, mem[_22579]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24889 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24889] = arg1
                                        mem[_24889 + 32] = 500
                                        mem[_24889 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24889 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11952 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11952] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13602 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13602] = arg1
                                            mem[_13602 + 32] = 500
                                            mem[_13602 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13602 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11952 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22581 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22581] == Mask(32, 224, mem[_22581])
                                            if Mask(32, 224, mem[_22581]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24894 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24894] = arg1
                                            mem[_24894 + 32] = 500
                                            mem[_24894 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24894 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22355 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22355] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25801 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25801] = arg1
                                            mem[_25801 + 32] = 500
                                            mem[_25801 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25801 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22355 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30103 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30103] == Mask(32, 224, mem[_30103])
                                            if Mask(32, 224, mem[_30103]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31835 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31835] = arg1
                                            mem[_31835 + 32] = 500
                                            mem[_31835 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31835 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11953 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11953] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13603 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13603] = arg1
                                        mem[_13603 + 32] = 500
                                        mem[_13603 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13603 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11953 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22583 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22583] == Mask(32, 224, mem[_22583])
                                        if Mask(32, 224, mem[_22583]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24898 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24898] = arg1
                                        mem[_24898 + 32] = 500
                                        mem[_24898 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24898 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11954 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11954] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13604 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13604] = arg1
                                            mem[_13604 + 32] = 500
                                            mem[_13604 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13604 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11954 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22585 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22585] == Mask(32, 224, mem[_22585])
                                            if Mask(32, 224, mem[_22585]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24903] = arg1
                                            mem[_24903 + 32] = 500
                                            mem[_24903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24903 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22360 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22360] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25802 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25802] = arg1
                                            mem[_25802 + 32] = 500
                                            mem[_25802 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25802 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22360 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30105 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30105] == Mask(32, 224, mem[_30105])
                                            if Mask(32, 224, mem[_30105]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31839 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31839] = arg1
                                            mem[_31839 + 32] = 500
                                            mem[_31839 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31839 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22335 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22335] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25791 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25791] = arg1
                                        mem[_25791 + 32] = 500
                                        mem[_25791 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22335 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30083 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30083] == Mask(32, 224, mem[_30083])
                                        if Mask(32, 224, mem[_30083]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31791 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31791] = arg1
                                        mem[_31791 + 32] = 500
                                        mem[_31791 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22336 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22336] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25792 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25792] = arg1
                                            mem[_25792 + 32] = 500
                                            mem[_25792 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25792 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22336 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30085 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30085] == Mask(32, 224, mem[_30085])
                                            if Mask(32, 224, mem[_30085]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31796 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31796] = arg1
                                            mem[_31796 + 32] = 500
                                            mem[_31796 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31796 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29945 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29945] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32639 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32639] = arg1
                                            mem[_32639 + 32] = 500
                                            mem[_32639 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32639 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29945 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33443 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33443] == Mask(32, 224, mem[_33443])
                                            if Mask(32, 224, mem[_33443]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33835 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33835] = arg1
                                            mem[_33835 + 32] = 500
                                            mem[_33835 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33835 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22337 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22337] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25793 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25793] = arg1
                                        mem[_25793 + 32] = 500
                                        mem[_25793 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25793 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22337 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30087 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30087] == Mask(32, 224, mem[_30087])
                                        if Mask(32, 224, mem[_30087]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31800 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31800] = arg1
                                        mem[_31800 + 32] = 500
                                        mem[_31800 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31800 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22338 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22338] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25794 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25794] = arg1
                                            mem[_25794 + 32] = 500
                                            mem[_25794 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25794 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22338 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30089 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30089] == Mask(32, 224, mem[_30089])
                                            if Mask(32, 224, mem[_30089]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31805 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31805] = arg1
                                            mem[_31805 + 32] = 500
                                            mem[_31805 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31805 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29950 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29950] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32640 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32640] = arg1
                                            mem[_32640 + 32] = 500
                                            mem[_32640 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32640 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29950 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33445 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33445] == Mask(32, 224, mem[_33445])
                                            if Mask(32, 224, mem[_33445]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33839 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33839] = arg1
                                            mem[_33839 + 32] = 500
                                            mem[_33839 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33839 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22339 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22339] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25795 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25795] = arg1
                                        mem[_25795 + 32] = 500
                                        mem[_25795 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25795 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22339 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30091 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30091] == Mask(32, 224, mem[_30091])
                                        if Mask(32, 224, mem[_30091]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31809 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31809] = arg1
                                        mem[_31809 + 32] = 500
                                        mem[_31809 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31809 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22340 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22340] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25796 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25796] = arg1
                                            mem[_25796 + 32] = 500
                                            mem[_25796 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25796 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22340 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30093 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30093] == Mask(32, 224, mem[_30093])
                                            if Mask(32, 224, mem[_30093]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31814 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31814] = arg1
                                            mem[_31814 + 32] = 500
                                            mem[_31814 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31814 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29955 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29955] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32641 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32641] = arg1
                                            mem[_32641 + 32] = 500
                                            mem[_32641 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32641 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29955 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33447 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33447] == Mask(32, 224, mem[_33447])
                                            if Mask(32, 224, mem[_33447]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33843 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33843] = arg1
                                            mem[_33843 + 32] = 500
                                            mem[_33843 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33843 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22341 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22341] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25797 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25797] = arg1
                                        mem[_25797 + 32] = 500
                                        mem[_25797 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25797 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22341 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30095 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30095] == Mask(32, 224, mem[_30095])
                                        if Mask(32, 224, mem[_30095]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31818 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31818] = arg1
                                        mem[_31818 + 32] = 500
                                        mem[_31818 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31818 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22342 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22342] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25798 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25798] = arg1
                                            mem[_25798 + 32] = 500
                                            mem[_25798 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25798 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22342 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30097 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30097] == Mask(32, 224, mem[_30097])
                                            if Mask(32, 224, mem[_30097]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31823 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31823] = arg1
                                            mem[_31823 + 32] = 500
                                            mem[_31823 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31823 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29960 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29960] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32642 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32642] = arg1
                                            mem[_32642 + 32] = 500
                                            mem[_32642 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32642 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29960 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33449 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33449] == Mask(32, 224, mem[_33449])
                                            if Mask(32, 224, mem[_33449]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33847 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33847] = arg1
                                            mem[_33847 + 32] = 500
                                            mem[_33847 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33847 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
    else:
        if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
            revert with 0, 34
        mem[352] = sub_be75288d[arg1].field_1 % 128
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11955 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11955] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13605 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13605] = arg1
                                    mem[_13605 + 32] = 500
                                    mem[_13605 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13605 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11955 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22587] == Mask(32, 224, mem[_22587])
                                    if Mask(32, 224, mem[_22587]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24907 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24907] = arg1
                                    mem[_24907 + 32] = 500
                                    mem[_24907 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24907 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11956 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11956] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13606 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13606] = arg1
                                        mem[_13606 + 32] = 500
                                        mem[_13606 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13606 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11956 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22589 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22589] == Mask(32, 224, mem[_22589])
                                        if Mask(32, 224, mem[_22589]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24912 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24912] = arg1
                                        mem[_24912 + 32] = 500
                                        mem[_24912 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24912 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22365 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22365] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25803 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25803] = arg1
                                        mem[_25803 + 32] = 500
                                        mem[_25803 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22365 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30107 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30107] == Mask(32, 224, mem[_30107])
                                        if Mask(32, 224, mem[_30107]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31843 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31843] = arg1
                                        mem[_31843 + 32] = 500
                                        mem[_31843 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31843 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11957 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11957] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13607 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13607] = arg1
                                    mem[_13607 + 32] = 500
                                    mem[_13607 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13607 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11957 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22591 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22591] == Mask(32, 224, mem[_22591])
                                    if Mask(32, 224, mem[_22591]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24916 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24916] = arg1
                                    mem[_24916 + 32] = 500
                                    mem[_24916 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24916 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11958 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11958] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13608 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13608] = arg1
                                        mem[_13608 + 32] = 500
                                        mem[_13608 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13608 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11958 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22593 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22593] == Mask(32, 224, mem[_22593])
                                        if Mask(32, 224, mem[_22593]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24921 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24921] = arg1
                                        mem[_24921 + 32] = 500
                                        mem[_24921 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24921 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22370 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22370] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25804 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25804] = arg1
                                        mem[_25804 + 32] = 500
                                        mem[_25804 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25804 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22370 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30109 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30109] == Mask(32, 224, mem[_30109])
                                        if Mask(32, 224, mem[_30109]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31847 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31847] = arg1
                                        mem[_31847 + 32] = 500
                                        mem[_31847 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31847 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11959 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11959] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13609 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13609] = arg1
                                    mem[_13609 + 32] = 500
                                    mem[_13609 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13609 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11959 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22595 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22595] == Mask(32, 224, mem[_22595])
                                    if Mask(32, 224, mem[_22595]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24925 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24925] = arg1
                                    mem[_24925 + 32] = 500
                                    mem[_24925 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24925 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11960 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11960] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13610 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13610] = arg1
                                        mem[_13610 + 32] = 500
                                        mem[_13610 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13610 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11960 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22597 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22597] == Mask(32, 224, mem[_22597])
                                        if Mask(32, 224, mem[_22597]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24930 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24930] = arg1
                                        mem[_24930 + 32] = 500
                                        mem[_24930 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24930 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22375 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22375] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25805 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25805] = arg1
                                        mem[_25805 + 32] = 500
                                        mem[_25805 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25805 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22375 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30111 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30111] == Mask(32, 224, mem[_30111])
                                        if Mask(32, 224, mem[_30111]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31851 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31851] = arg1
                                        mem[_31851 + 32] = 500
                                        mem[_31851 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31851 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11961 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11961] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13611 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13611] = arg1
                                    mem[_13611 + 32] = 500
                                    mem[_13611 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13611 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11961 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22599 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22599] == Mask(32, 224, mem[_22599])
                                    if Mask(32, 224, mem[_22599]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24934 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24934] = arg1
                                    mem[_24934 + 32] = 500
                                    mem[_24934 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24934 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11962 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11962] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13612 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13612] = arg1
                                        mem[_13612 + 32] = 500
                                        mem[_13612 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13612 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11962 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22601 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22601] == Mask(32, 224, mem[_22601])
                                        if Mask(32, 224, mem[_22601]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24939 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24939] = arg1
                                        mem[_24939 + 32] = 500
                                        mem[_24939 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24939 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22380 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22380] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25806 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25806] = arg1
                                        mem[_25806 + 32] = 500
                                        mem[_25806 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25806 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22380 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30113 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30113] == Mask(32, 224, mem[_30113])
                                        if Mask(32, 224, mem[_30113]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31855 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31855] = arg1
                                        mem[_31855 + 32] = 500
                                        mem[_31855 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31855 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11963 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11963] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13630 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13630] = arg1
                                        mem[_13630 + 32] = 500
                                        mem[_13630 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13630 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11963 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22603 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22603] == Mask(32, 224, mem[_22603])
                                        if Mask(32, 224, mem[_22603]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24951 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24951] = arg1
                                        mem[_24951 + 32] = 500
                                        mem[_24951 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24951 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11964 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11964] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13631 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13631] = arg1
                                            mem[_13631 + 32] = 500
                                            mem[_13631 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13631 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11964 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22605 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22605] == Mask(32, 224, mem[_22605])
                                            if Mask(32, 224, mem[_22605]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24956 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24956] = arg1
                                            mem[_24956 + 32] = 500
                                            mem[_24956 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24956 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22393 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22393] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25815 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25815] = arg1
                                            mem[_25815 + 32] = 500
                                            mem[_25815 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25815 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22393 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30131 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30131] == Mask(32, 224, mem[_30131])
                                            if Mask(32, 224, mem[_30131]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31895 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31895] = arg1
                                            mem[_31895 + 32] = 500
                                            mem[_31895 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31895 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11965 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11965] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13632 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13632] = arg1
                                        mem[_13632 + 32] = 500
                                        mem[_13632 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13632 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11965 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22607 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22607] == Mask(32, 224, mem[_22607])
                                        if Mask(32, 224, mem[_22607]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24960 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24960] = arg1
                                        mem[_24960 + 32] = 500
                                        mem[_24960 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24960 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11966 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11966] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13633 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13633] = arg1
                                            mem[_13633 + 32] = 500
                                            mem[_13633 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13633 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11966 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22609 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22609] == Mask(32, 224, mem[_22609])
                                            if Mask(32, 224, mem[_22609]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24965 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24965] = arg1
                                            mem[_24965 + 32] = 500
                                            mem[_24965 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24965 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22398 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22398] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25816 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25816] = arg1
                                            mem[_25816 + 32] = 500
                                            mem[_25816 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25816 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22398 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30133 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30133] == Mask(32, 224, mem[_30133])
                                            if Mask(32, 224, mem[_30133]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31899 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31899] = arg1
                                            mem[_31899 + 32] = 500
                                            mem[_31899 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31899 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11967 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11967] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13634 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13634] = arg1
                                        mem[_13634 + 32] = 500
                                        mem[_13634 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13634 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11967 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22611 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22611] == Mask(32, 224, mem[_22611])
                                        if Mask(32, 224, mem[_22611]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24969 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24969] = arg1
                                        mem[_24969 + 32] = 500
                                        mem[_24969 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24969 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11968 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11968] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13635 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13635] = arg1
                                            mem[_13635 + 32] = 500
                                            mem[_13635 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11968 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22613 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22613] == Mask(32, 224, mem[_22613])
                                            if Mask(32, 224, mem[_22613]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24974 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24974] = arg1
                                            mem[_24974 + 32] = 500
                                            mem[_24974 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24974 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22403 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22403] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25817 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25817] = arg1
                                            mem[_25817 + 32] = 500
                                            mem[_25817 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25817 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22403 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30135 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30135] == Mask(32, 224, mem[_30135])
                                            if Mask(32, 224, mem[_30135]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31903] = arg1
                                            mem[_31903 + 32] = 500
                                            mem[_31903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31903 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11969 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11969] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13636 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13636] = arg1
                                        mem[_13636 + 32] = 500
                                        mem[_13636 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13636 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11969 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22615 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22615] == Mask(32, 224, mem[_22615])
                                        if Mask(32, 224, mem[_22615]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24978 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24978] = arg1
                                        mem[_24978 + 32] = 500
                                        mem[_24978 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24978 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11970 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11970] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13637 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13637] = arg1
                                            mem[_13637 + 32] = 500
                                            mem[_13637 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13637 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11970 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22617 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22617] == Mask(32, 224, mem[_22617])
                                            if Mask(32, 224, mem[_22617]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _24983 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_24983] = arg1
                                            mem[_24983 + 32] = 500
                                            mem[_24983 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_24983 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22408 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22408] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25818 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25818] = arg1
                                            mem[_25818 + 32] = 500
                                            mem[_25818 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25818 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22408 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30137 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30137] == Mask(32, 224, mem[_30137])
                                            if Mask(32, 224, mem[_30137]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31907 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31907] = arg1
                                            mem[_31907 + 32] = 500
                                            mem[_31907 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31907 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22383 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22383] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25807 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25807] = arg1
                                        mem[_25807 + 32] = 500
                                        mem[_25807 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25807 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22383 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30115 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30115] == Mask(32, 224, mem[_30115])
                                        if Mask(32, 224, mem[_30115]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31859 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31859] = arg1
                                        mem[_31859 + 32] = 500
                                        mem[_31859 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31859 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22384 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22384] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25808 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25808] = arg1
                                            mem[_25808 + 32] = 500
                                            mem[_25808 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25808 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22384 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30117 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30117] == Mask(32, 224, mem[_30117])
                                            if Mask(32, 224, mem[_30117]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31864 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31864] = arg1
                                            mem[_31864 + 32] = 500
                                            mem[_31864 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31864 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29981 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29981] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32643 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32643] = arg1
                                            mem[_32643 + 32] = 500
                                            mem[_32643 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32643 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29981 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33451 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33451] == Mask(32, 224, mem[_33451])
                                            if Mask(32, 224, mem[_33451]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33851 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33851] = arg1
                                            mem[_33851 + 32] = 500
                                            mem[_33851 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33851 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22385 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22385] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25809 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25809] = arg1
                                        mem[_25809 + 32] = 500
                                        mem[_25809 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25809 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22385 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30119 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30119] == Mask(32, 224, mem[_30119])
                                        if Mask(32, 224, mem[_30119]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31868 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31868] = arg1
                                        mem[_31868 + 32] = 500
                                        mem[_31868 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31868 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22386 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22386] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25810 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25810] = arg1
                                            mem[_25810 + 32] = 500
                                            mem[_25810 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25810 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22386 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30121 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30121] == Mask(32, 224, mem[_30121])
                                            if Mask(32, 224, mem[_30121]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31873 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31873] = arg1
                                            mem[_31873 + 32] = 500
                                            mem[_31873 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31873 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29986 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29986] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32644 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32644] = arg1
                                            mem[_32644 + 32] = 500
                                            mem[_32644 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32644 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29986 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33453 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33453] == Mask(32, 224, mem[_33453])
                                            if Mask(32, 224, mem[_33453]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33855] = arg1
                                            mem[_33855 + 32] = 500
                                            mem[_33855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22387 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22387] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25811 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25811] = arg1
                                        mem[_25811 + 32] = 500
                                        mem[_25811 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25811 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22387 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30123 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30123] == Mask(32, 224, mem[_30123])
                                        if Mask(32, 224, mem[_30123]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31877 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31877] = arg1
                                        mem[_31877 + 32] = 500
                                        mem[_31877 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31877 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22388 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22388] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25812 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25812] = arg1
                                            mem[_25812 + 32] = 500
                                            mem[_25812 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25812 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22388 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30125 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30125] == Mask(32, 224, mem[_30125])
                                            if Mask(32, 224, mem[_30125]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31882 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31882] = arg1
                                            mem[_31882 + 32] = 500
                                            mem[_31882 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31882 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29991 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29991] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32645 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32645] = arg1
                                            mem[_32645 + 32] = 500
                                            mem[_32645 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32645 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29991 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33455 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33455] == Mask(32, 224, mem[_33455])
                                            if Mask(32, 224, mem[_33455]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33859 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33859] = arg1
                                            mem[_33859 + 32] = 500
                                            mem[_33859 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33859 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22389 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22389] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25813 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25813] = arg1
                                        mem[_25813 + 32] = 500
                                        mem[_25813 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25813 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22389 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30127 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30127] == Mask(32, 224, mem[_30127])
                                        if Mask(32, 224, mem[_30127]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31886 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31886] = arg1
                                        mem[_31886 + 32] = 500
                                        mem[_31886 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31886 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22390 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22390] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25814 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25814] = arg1
                                            mem[_25814 + 32] = 500
                                            mem[_25814 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25814 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22390 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30129 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30129] == Mask(32, 224, mem[_30129])
                                            if Mask(32, 224, mem[_30129]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31891 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31891] = arg1
                                            mem[_31891 + 32] = 500
                                            mem[_31891 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31891 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _29996 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_29996] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32646 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32646] = arg1
                                            mem[_32646 + 32] = 500
                                            mem[_32646 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32646 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _29996 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33457 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33457] == Mask(32, 224, mem[_33457])
                                            if Mask(32, 224, mem[_33457]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33863 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33863] = arg1
                                            mem[_33863 + 32] = 500
                                            mem[_33863 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33863 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11971 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11971] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13638 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13638] = arg1
                                    mem[_13638 + 32] = 500
                                    mem[_13638 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13638 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11971 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22619 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22619] == Mask(32, 224, mem[_22619])
                                    if Mask(32, 224, mem[_22619]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24987 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24987] = arg1
                                    mem[_24987 + 32] = 500
                                    mem[_24987 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24987 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11972 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11972] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13639 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13639] = arg1
                                        mem[_13639 + 32] = 500
                                        mem[_13639 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13639 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11972 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22621 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22621] == Mask(32, 224, mem[_22621])
                                        if Mask(32, 224, mem[_22621]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _24992 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_24992] = arg1
                                        mem[_24992 + 32] = 500
                                        mem[_24992 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_24992 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22413 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22413] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25819 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25819] = arg1
                                        mem[_25819 + 32] = 500
                                        mem[_25819 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25819 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22413 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30139 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30139] == Mask(32, 224, mem[_30139])
                                        if Mask(32, 224, mem[_30139]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31911] = arg1
                                        mem[_31911 + 32] = 500
                                        mem[_31911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11973 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11973] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13640 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13640] = arg1
                                    mem[_13640 + 32] = 500
                                    mem[_13640 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13640 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11973 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22623 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22623] == Mask(32, 224, mem[_22623])
                                    if Mask(32, 224, mem[_22623]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _24996 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_24996] = arg1
                                    mem[_24996 + 32] = 500
                                    mem[_24996 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_24996 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11974 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11974] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13641 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13641] = arg1
                                        mem[_13641 + 32] = 500
                                        mem[_13641 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13641 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11974 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22625 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22625] == Mask(32, 224, mem[_22625])
                                        if Mask(32, 224, mem[_22625]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25001 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25001] = arg1
                                        mem[_25001 + 32] = 500
                                        mem[_25001 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25001 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22418 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22418] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25820 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25820] = arg1
                                        mem[_25820 + 32] = 500
                                        mem[_25820 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25820 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22418 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30141 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30141] == Mask(32, 224, mem[_30141])
                                        if Mask(32, 224, mem[_30141]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31915 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31915] = arg1
                                        mem[_31915 + 32] = 500
                                        mem[_31915 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31915 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11975 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11975] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13642 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13642] = arg1
                                    mem[_13642 + 32] = 500
                                    mem[_13642 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13642 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11975 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22627 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22627] == Mask(32, 224, mem[_22627])
                                    if Mask(32, 224, mem[_22627]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _25005 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_25005] = arg1
                                    mem[_25005 + 32] = 500
                                    mem[_25005 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_25005 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11976 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11976] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13643 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13643] = arg1
                                        mem[_13643 + 32] = 500
                                        mem[_13643 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13643 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11976 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22629 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22629] == Mask(32, 224, mem[_22629])
                                        if Mask(32, 224, mem[_22629]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25010 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25010] = arg1
                                        mem[_25010 + 32] = 500
                                        mem[_25010 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25010 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22423 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22423] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25821 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25821] = arg1
                                        mem[_25821 + 32] = 500
                                        mem[_25821 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25821 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22423 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30143 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30143] == Mask(32, 224, mem[_30143])
                                        if Mask(32, 224, mem[_30143]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31919 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31919] = arg1
                                        mem[_31919 + 32] = 500
                                        mem[_31919 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31919 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                revert with 0, 17
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            if block.timestamp < launchTime:
                                revert with 0, 'Not launched yet'
                            if not launchTime:
                                revert with 0, 'Not launched yet'
                            mem[0] = arg1
                            mem[32] = sha3(msg.sender, 202)
                            if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[msg.sender][arg1] += arg2
                            if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                revert with 0, 17
                            if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                revert with 0, 17
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            require ext_code.size(sub_cd38b90aAddress)
                            call sub_cd38b90aAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _11977 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11977] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(msg.sender)] > -2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = msg.sender
                                emit Transfer(0, msg.sender, numMinted);
                                if not ext_code.size(msg.sender):
                                    _13644 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_13644] = arg1
                                    mem[_13644 + 32] = 500
                                    mem[_13644 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_13644 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _11977 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(msg.sender)
                                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22631 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22631] == Mask(32, 224, mem[_22631])
                                    if Mask(32, 224, mem[_22631]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _25014 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_25014] = arg1
                                    mem[_25014 + 32] = 500
                                    mem[_25014 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_25014 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 500
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11978 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11978] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13645 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13645] = arg1
                                        mem[_13645 + 32] = 500
                                        mem[_13645 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13645 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11978 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22633 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22633] == Mask(32, 224, mem[_22633])
                                        if Mask(32, 224, mem[_22633]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25019 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25019] = arg1
                                        mem[_25019 + 32] = 500
                                        mem[_25019 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25019 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22428 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22428] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25822 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25822] = arg1
                                        mem[_25822 + 32] = 500
                                        mem[_25822 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25822 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22428 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30145 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30145] == Mask(32, 224, mem[_30145])
                                        if Mask(32, 224, mem[_30145]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31923 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31923] = arg1
                                        mem[_31923 + 32] = 500
                                        mem[_31923 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31923 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11979 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11979] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13663 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13663] = arg1
                                        mem[_13663 + 32] = 500
                                        mem[_13663 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13663 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11979 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22635 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22635] == Mask(32, 224, mem[_22635])
                                        if Mask(32, 224, mem[_22635]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25031 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25031] = arg1
                                        mem[_25031 + 32] = 500
                                        mem[_25031 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25031 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11980 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11980] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13664 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13664] = arg1
                                            mem[_13664 + 32] = 500
                                            mem[_13664 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13664 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11980 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22637 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22637] == Mask(32, 224, mem[_22637])
                                            if Mask(32, 224, mem[_22637]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _25036 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25036] = arg1
                                            mem[_25036 + 32] = 500
                                            mem[_25036 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25036 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22441 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22441] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25831 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25831] = arg1
                                            mem[_25831 + 32] = 500
                                            mem[_25831 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25831 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22441 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30163 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30163] == Mask(32, 224, mem[_30163])
                                            if Mask(32, 224, mem[_30163]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31963 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31963] = arg1
                                            mem[_31963 + 32] = 500
                                            mem[_31963 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31963 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11981 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11981] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13665 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13665] = arg1
                                        mem[_13665 + 32] = 500
                                        mem[_13665 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13665 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11981 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22639 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22639] == Mask(32, 224, mem[_22639])
                                        if Mask(32, 224, mem[_22639]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25040 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25040] = arg1
                                        mem[_25040 + 32] = 500
                                        mem[_25040 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25040 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11982 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11982] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13666 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13666] = arg1
                                            mem[_13666 + 32] = 500
                                            mem[_13666 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13666 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11982 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22641 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22641] == Mask(32, 224, mem[_22641])
                                            if Mask(32, 224, mem[_22641]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _25045 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25045] = arg1
                                            mem[_25045 + 32] = 500
                                            mem[_25045 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25045 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22446 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22446] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25832 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25832] = arg1
                                            mem[_25832 + 32] = 500
                                            mem[_25832 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25832 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22446 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30165 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30165] == Mask(32, 224, mem[_30165])
                                            if Mask(32, 224, mem[_30165]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31967 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31967] = arg1
                                            mem[_31967 + 32] = 500
                                            mem[_31967 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31967 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11983 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11983] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13667 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13667] = arg1
                                        mem[_13667 + 32] = 500
                                        mem[_13667 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13667 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11983 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22643 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22643] == Mask(32, 224, mem[_22643])
                                        if Mask(32, 224, mem[_22643]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25049 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25049] = arg1
                                        mem[_25049 + 32] = 500
                                        mem[_25049 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25049 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11984 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11984] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13668 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13668] = arg1
                                            mem[_13668 + 32] = 500
                                            mem[_13668 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13668 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11984 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22645 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22645] == Mask(32, 224, mem[_22645])
                                            if Mask(32, 224, mem[_22645]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _25054 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25054] = arg1
                                            mem[_25054 + 32] = 500
                                            mem[_25054 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25054 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22451 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22451] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25833 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25833] = arg1
                                            mem[_25833 + 32] = 500
                                            mem[_25833 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25833 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22451 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30167 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30167] == Mask(32, 224, mem[_30167])
                                            if Mask(32, 224, mem[_30167]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31971 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31971] = arg1
                                            mem[_31971 + 32] = 500
                                            mem[_31971 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31971 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _11985 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_11985] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _13669 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_13669] = arg1
                                        mem[_13669 + 32] = 500
                                        mem[_13669 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_13669 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11985 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22647 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22647] == Mask(32, 224, mem[_22647])
                                        if Mask(32, 224, mem[_22647]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _25058 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25058] = arg1
                                        mem[_25058 + 32] = 500
                                        mem[_25058 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25058 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _11986 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_11986] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _13670 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_13670] = arg1
                                            mem[_13670 + 32] = 500
                                            mem[_13670 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_13670 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11986 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22649 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22649] == Mask(32, 224, mem[_22649])
                                            if Mask(32, 224, mem[_22649]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _25063 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25063] = arg1
                                            mem[_25063 + 32] = 500
                                            mem[_25063 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25063 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22456 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22456] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25834 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25834] = arg1
                                            mem[_25834 + 32] = 500
                                            mem[_25834 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25834 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22456 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30169 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30169] == Mask(32, 224, mem[_30169])
                                            if Mask(32, 224, mem[_30169]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31975 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31975] = arg1
                                            mem[_31975 + 32] = 500
                                            mem[_31975 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31975 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22431 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22431] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25823 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25823] = arg1
                                        mem[_25823 + 32] = 500
                                        mem[_25823 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22431 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30147 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30147] == Mask(32, 224, mem[_30147])
                                        if Mask(32, 224, mem[_30147]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31927 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31927] = arg1
                                        mem[_31927 + 32] = 500
                                        mem[_31927 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31927 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22432 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22432] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25824 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25824] = arg1
                                            mem[_25824 + 32] = 500
                                            mem[_25824 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25824 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22432 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30149 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30149] == Mask(32, 224, mem[_30149])
                                            if Mask(32, 224, mem[_30149]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31932 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31932] = arg1
                                            mem[_31932 + 32] = 500
                                            mem[_31932 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31932 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _30017 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_30017] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32647 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32647] = arg1
                                            mem[_32647 + 32] = 500
                                            mem[_32647 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32647 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _30017 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33459 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33459] == Mask(32, 224, mem[_33459])
                                            if Mask(32, 224, mem[_33459]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33867 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33867] = arg1
                                            mem[_33867 + 32] = 500
                                            mem[_33867 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33867 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22433 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22433] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25825 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25825] = arg1
                                        mem[_25825 + 32] = 500
                                        mem[_25825 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25825 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22433 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30151 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30151] == Mask(32, 224, mem[_30151])
                                        if Mask(32, 224, mem[_30151]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31936 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31936] = arg1
                                        mem[_31936 + 32] = 500
                                        mem[_31936 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31936 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22434 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22434] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25826 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25826] = arg1
                                            mem[_25826 + 32] = 500
                                            mem[_25826 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25826 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22434 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30153 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30153] == Mask(32, 224, mem[_30153])
                                            if Mask(32, 224, mem[_30153]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31941 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31941] = arg1
                                            mem[_31941 + 32] = 500
                                            mem[_31941 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31941 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _30022 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_30022] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32648 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32648] = arg1
                                            mem[_32648 + 32] = 500
                                            mem[_32648 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32648 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _30022 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33461 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33461] == Mask(32, 224, mem[_33461])
                                            if Mask(32, 224, mem[_33461]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33871 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33871] = arg1
                                            mem[_33871 + 32] = 500
                                            mem[_33871 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33871 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22435 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22435] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25827 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25827] = arg1
                                        mem[_25827 + 32] = 500
                                        mem[_25827 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25827 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22435 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30155 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30155] == Mask(32, 224, mem[_30155])
                                        if Mask(32, 224, mem[_30155]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31945 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31945] = arg1
                                        mem[_31945 + 32] = 500
                                        mem[_31945 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31945 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22436 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22436] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25828 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25828] = arg1
                                            mem[_25828 + 32] = 500
                                            mem[_25828 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25828 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22436 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30157 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30157] == Mask(32, 224, mem[_30157])
                                            if Mask(32, 224, mem[_30157]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31950 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31950] = arg1
                                            mem[_31950 + 32] = 500
                                            mem[_31950 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31950 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _30027 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_30027] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32649 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32649] = arg1
                                            mem[_32649 + 32] = 500
                                            mem[_32649 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32649 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _30027 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33463 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33463] == Mask(32, 224, mem[_33463])
                                            if Mask(32, 224, mem[_33463]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33875 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33875] = arg1
                                            mem[_33875 + 32] = 500
                                            mem[_33875 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33875 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                    revert with 0, 17
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                if block.timestamp < launchTime:
                                    revert with 0, 'Not launched yet'
                                if not launchTime:
                                    revert with 0, 'Not launched yet'
                                mem[0] = arg1
                                mem[32] = sha3(msg.sender, 202)
                                if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[msg.sender][arg1] += arg2
                                if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                    revert with 0, 17
                                if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                    revert with 0, 17
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                require ext_code.size(sub_cd38b90aAddress)
                                call sub_cd38b90aAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _22437 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_22437] = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = msg.sender
                                    emit Transfer(0, msg.sender, numMinted);
                                    if not ext_code.size(msg.sender):
                                        _25829 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_25829] = arg1
                                        mem[_25829 + 32] = 500
                                        mem[_25829 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_25829 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _22437 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _30159 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_30159] == Mask(32, 224, mem[_30159])
                                        if Mask(32, 224, mem[_30159]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _31954 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_31954] = arg1
                                        mem[_31954 + 32] = 500
                                        mem[_31954 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_31954 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 500
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _22438 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_22438] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _25830 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_25830] = arg1
                                            mem[_25830 + 32] = 500
                                            mem[_25830 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_25830 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _22438 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30161 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30161] == Mask(32, 224, mem[_30161])
                                            if Mask(32, 224, mem[_30161]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _31959 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_31959] = arg1
                                            mem[_31959 + 32] = 500
                                            mem[_31959 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_31959 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if sub_be75288d[arg1].field_512 and arg2 > -1 / sub_be75288d[arg1].field_512:
                                        revert with 0, 17
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[msg.sender][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    if block.timestamp < launchTime:
                                        revert with 0, 'Not launched yet'
                                    if not launchTime:
                                        revert with 0, 'Not launched yet'
                                    mem[0] = arg1
                                    mem[32] = sha3(msg.sender, 202)
                                    if sub_2b1331a8[msg.sender][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[msg.sender][arg1] += arg2
                                    if sub_be75288d[arg1].field_512 * arg2 > 0x369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369d0369:
                                        revert with 0, 17
                                    if sub_be75288d[arg1].field_512 * arg2 < 75 * sub_be75288d[arg1].field_512 * arg2 / 100:
                                        revert with 0, 17
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 452] = this.address
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 484] = 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), 75 * sub_be75288d[arg1].field_512 * arg2 / 100
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 420] = msg.sender
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 452] = treasuryAddress
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 484] = (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    require ext_code.size(sub_cd38b90aAddress)
                                    call sub_cd38b90aAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, treasuryAddress, (sub_be75288d[arg1].field_512 * arg2) - (75 * sub_be75288d[arg1].field_512 * arg2 / 100)
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + ceil32(return_data.size) + 416] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + (2 * ceil32(return_data.size)) + 416
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _30032 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_30032] = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = msg.sender
                                        emit Transfer(0, msg.sender, numMinted);
                                        if not ext_code.size(msg.sender):
                                            _32650 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_32650] = arg1
                                            mem[_32650 + 32] = 500
                                            mem[_32650 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_32650 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _30032 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33465 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33465] == Mask(32, 224, mem[_33465])
                                            if Mask(32, 224, mem[_33465]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _33879 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_33879] = arg1
                                            mem[_33879 + 32] = 500
                                            mem[_33879 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_33879 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 500
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
}



}

contract main {




// =====================  Runtime code  =====================


address stor0;
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor4;

function _fallback() payable {
    revert
}

function setAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    address(stor0) = arg1
    return block.number
}

function sub_86bf92f7(?) payable {
    require stor3
    if stor4.length > test266151307():
        revert with 'NH{q', 65
    mem[96] = stor4.length
    mem[64] = (32 * stor4.length) + 128
    if not stor4.length:
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        while idx < stor4.length:
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            if address(s) != stor4[idx].field_1024:
                if address(s) != stor4[idx].field_1280:
                    _60 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_60] = 0
                    if idx >= stor4.length:
                        revert with 'NH{q', 50
                    mem[0] = 4
                    mem[_60 + 32] = stor4[idx].field_0
                    mem[_60 + 64] = 300
                    mem[_60 + 96] = 1
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + 128] = _60
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = 0
                    continue 
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                _65 = mem[64]
                mem[64] = mem[64] + 128
                mem[_65] = stor4[idx].field_1024
                mem[0] = 4
                mem[_65 + 32] = stor4[idx].field_0
                mem[_65 + 64] = 300
                mem[_65 + 96] = 1
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = _65
            else:
                if address(s) != stor4[idx].field_1280:
                    _66 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_66] = stor4[idx].field_1280
                    if idx >= stor4.length:
                        revert with 'NH{q', 50
                    mem[0] = 4
                    mem[_66 + 32] = stor4[idx].field_0
                    mem[_66 + 64] = 300
                    mem[_66 + 96] = 1
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + 128] = _66
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = stor4[idx].field_1280
                    continue 
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                _74 = mem[64]
                mem[64] = mem[64] + 128
                mem[_74] = stor4[idx].field_1024
                mem[0] = 4
                mem[_74 + 32] = stor4[idx].field_0
                mem[_74 + 64] = 300
                mem[_74 + 96] = 1
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = _74
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = stor4[idx].field_1024
            continue 
        _56 = mem[64]
        mem[mem[64]] = stor1
        mem[mem[64] + 32] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[mem[64] + 64] = 96
        _92 = mem[96]
        mem[mem[64] + 96] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 128
        while idx < _92:
            _109 = mem[s]
            mem[t] = mem[mem[s] + 12 len 20]
            mem[t + 32] = mem[_109 + 44 len 20]
            mem[t + 64] = mem[_109 + 64]
            mem[t + 96] = mem[_109 + 96]
            idx = idx + 1
            s = s + 32
            t = t + 128
            continue 
        return memory
          from mem[64]
           len _56 + (128 * _92) + -mem[64] + 128
    mem[64] = (32 * stor4.length) + 256
    mem[(32 * stor4.length) + 128] = 0
    mem[(32 * stor4.length) + 160] = 0
    mem[(32 * stor4.length) + 192] = 0
    mem[(32 * stor4.length) + 224] = 0
    mem[var9001] = (32 * stor4.length) + 128
    s = var9001
    idx = var9002
    while idx - 1:
        mem[64] = mem[64] + 128
        mem[(32 * stor4.length) + 128] = 0
        mem[(32 * stor4.length) + 160] = 0
        mem[(32 * stor4.length) + 192] = 0
        mem[(32 * stor4.length) + 224] = 0
        mem[s + 32] = (32 * stor4.length) + 128
        s = s + 32
        idx = idx - 1
        continue 
    idx = 0
    s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
    while idx < stor4.length:
        if idx >= stor4.length:
            revert with 'NH{q', 50
        mem[0] = 4
        if address(s) != stor4[idx].field_1024:
            if address(s) != stor4[idx].field_1280:
                _145 = mem[64]
                mem[64] = mem[64] + 128
                mem[_145] = 0
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                mem[_145 + 32] = stor4[idx].field_0
                mem[_145 + 64] = 300
                mem[_145 + 96] = 1
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = _145
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = 0
                continue 
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            _150 = mem[64]
            mem[64] = mem[64] + 128
            mem[_150] = stor4[idx].field_1024
            mem[0] = 4
            mem[_150 + 32] = stor4[idx].field_0
            mem[_150 + 64] = 300
            mem[_150 + 96] = 1
            if idx >= mem[96]:
                revert with 'NH{q', 50
            mem[(32 * idx) + 128] = _150
        else:
            if address(s) != stor4[idx].field_1280:
                _151 = mem[64]
                mem[64] = mem[64] + 128
                mem[_151] = stor4[idx].field_1280
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                mem[_151 + 32] = stor4[idx].field_0
                mem[_151 + 64] = 300
                mem[_151 + 96] = 1
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = _151
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = stor4[idx].field_1280
                continue 
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            _157 = mem[64]
            mem[64] = mem[64] + 128
            mem[_157] = stor4[idx].field_1024
            mem[0] = 4
            mem[_157 + 32] = stor4[idx].field_0
            mem[_157 + 64] = 300
            mem[_157 + 96] = 1
            if idx >= mem[96]:
                revert with 'NH{q', 50
            mem[(32 * idx) + 128] = _157
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        s = stor4[idx].field_1024
        continue 
    _141 = mem[64]
    mem[mem[64]] = stor1
    mem[mem[64] + 32] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
    mem[mem[64] + 64] = 96
    _160 = mem[96]
    mem[mem[64] + 96] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + 128
    while idx < _160:
        _167 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_167 + 44 len 20]
        mem[t + 64] = mem[_167 + 64]
        mem[t + 96] = mem[_167 + 96]
        idx = idx + 1
        s = s + 32
        t = t + 128
        continue 
    return memory
      from mem[64]
       len _141 + (128 * _160) + -mem[64] + 128
}

function swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapTokensForExactETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg3.length) + 97 > test266151307() or floor32(arg3.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = 128
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == arg5
    mem[floor32(arg3.length) + 97] = 0
    mem[floor32(arg3.length) + 129] = 0
    mem[floor32(arg3.length) + 161] = 0
    mem[floor32(arg3.length) + 193] = 96
    mem[floor32(arg3.length) + 225] = 0
    mem[floor32(arg3.length) + 257] = 0
    mem[floor32(arg3.length) + 289] = 0
    mem[floor32(arg3.length) + 321] = 96
    mem[floor32(arg3.length) + 353] = 3
    mem[64] = floor32(arg3.length) + 481
    mem[floor32(arg3.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg3.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg3.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg3.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg3.length) + 485] = address(stor0)
    mem[floor32(arg3.length) + 517] = 160
    mem[floor32(arg3.length) + 645] = arg3.length
    idx = 0
    s = 128
    t = floor32(arg3.length) + 677
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg3.length) + 549] = 0
    mem[floor32(arg3.length) + 581] = 0
    mem[floor32(arg3.length) + 613] = (32 * arg3.length) + 192
    mem[floor32(arg3.length) + (32 * arg3.length) + 677] = 3
    idx = 0
    s = floor32(arg3.length) + 385
    t = floor32(arg3.length) + (32 * arg3.length) + 709
    while idx < mem[floor32(arg3.length) + 353]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len floor32(arg3.length) + (32 * arg3.length) + (32 * mem[floor32(arg3.length) + 353]) + -mem[64] + 705]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _276 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _277 = mem[_276]
    require mem[_276] <= test266151307()
    require _276 + mem[_276] + 31 < _276 + return_data.size
    _278 = mem[_276 + mem[_276]]
    if mem[_276 + mem[_276]] > test266151307():
        revert with 'NH{q', 65
    if _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1 > test266151307() or floor32(mem[_276 + mem[_276]]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = _276 + ceil32(return_data.size) + floor32(mem[_276 + mem[_276]]) + 1
    mem[_276 + ceil32(return_data.size)] = _278
    require _277 + (32 * _278) + 32 <= return_data.size
    idx = 0
    s = _276 + _277 + 32
    t = _276 + ceil32(return_data.size) + 32
    while idx < _278:
        _359 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_277 + -mem[s] - 32 >= 128
        _363 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[_276 + _277 + _359 + 32] == mem[_276 + _277 + _359 + 32]
        mem[_363] = mem[_276 + _277 + _359 + 32]
        require mem[_276 + _277 + _359 + 64] == mem[_276 + _277 + _359 + 64]
        mem[_363 + 32] = mem[_276 + _277 + _359 + 64]
        require mem[_276 + _277 + _359 + 96] == mem[_276 + _277 + _359 + 96]
        mem[_363 + 64] = mem[_276 + _277 + _359 + 96]
        _420 = mem[_276 + _277 + _359 + 128]
        require mem[_276 + _277 + _359 + 128] <= test266151307()
        require _276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 63 < _276 + return_data.size
        _422 = mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]
        if mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32] > test266151307():
            revert with 'NH{q', 65
        _425 = mem[64]
        if mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 > test266151307() or mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[_276 + _277 + _359 + mem[_276 + _277 + _359 + 128] + 32]) + 1
        mem[_425] = _422
        require _277 + _359 + _420 + (192 * _422) + 64 <= return_data.size
        u = 0
        v = _276 + _277 + _359 + _420 + 64
        w = _425 + 32
        while u < _422:
            require _276 + return_data.size - v >= 192
            _461 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_461] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_461 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_461 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_461 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_461 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_461 + 160] = mem[v + 160]
            mem[w] = _461
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_363 + 96] = _425
        mem[t] = _363
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[_276 + ceil32(return_data.size)]:
        if idx >= mem[_276 + ceil32(return_data.size)]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + _276 + ceil32(return_data.size) + 32] + 64] > 0:
            if idx >= mem[_276 + ceil32(return_data.size)]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[_276 + ceil32(return_data.size)]:
        revert with 'NH{q', 50
    _441 = mem[_276 + ceil32(return_data.size) + 32]
    stor1 = mem[mem[_276 + ceil32(return_data.size) + 32]]
    stor2 = mem[mem[_276 + ceil32(return_data.size) + 32] + 32]
    stor3 = mem[mem[_276 + ceil32(return_data.size) + 32] + 64]
    _510 = mem[mem[mem[_276 + ceil32(return_data.size) + 32] + 96]]
    idx = 0
    while idx < _510:
        _513 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 32] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 32]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 64] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 64]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 96] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 96]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 128] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_441 + 96]]:
            revert with 'NH{q', 50
        mem[_513 + 160] = mem[mem[(32 * idx) + mem[_441 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_513 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_513 + 32]
        stor4[stor4.length].field_512 = mem[_513 + 64]
        stor4[stor4.length].field_768 = mem[_513 + 96]
        stor4[stor4.length].field_1024 = mem[_513 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_513 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _510 = mem[mem[_441 + 96]]
        idx = idx + 1
        continue 
    _511 = mem[64]
    mem[64] = mem[64] + 128
    mem[_511] = stor1
    mem[_511 + 32] = stor2
    mem[_511 + 64] = stor3
    _512 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_512] = stor4.length
    s = _512 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _562 = mem[64]
        mem[64] = mem[64] + 192
        mem[_562] = stor4[idx].field_0
        mem[_562 + 32] = stor4[idx].field_256
        mem[_562 + 64] = stor4[idx].field_512
        mem[_562 + 96] = stor4[idx].field_768
        mem[_562 + 128] = stor4[idx].field_1024
        mem[_562 + 160] = stor4[idx].field_1280
        mem[s] = _562
        s = s + 32
        idx = idx + 1
        continue 
    mem[_511 + 96] = _512
    _563 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_511]
    mem[mem[64] + 64] = mem[_511 + 32]
    mem[mem[64] + 96] = mem[_511 + 64]
    mem[mem[64] + 128] = 128
    _568 = mem[_512]
    mem[mem[64] + 160] = mem[_512]
    idx = 0
    s = _512 + 32
    t = mem[64] + 192
    while idx < _568:
        _577 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_577 + 32]
        mem[t + 64] = mem[_577 + 64]
        mem[t + 96] = mem[_577 + 96]
        mem[t + 128] = mem[_577 + 140 len 20]
        mem[t + 160] = mem[_577 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _563 + (192 * _568) + -mem[64] + 192
}

function swapExactETHForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function swapETHForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == arg4
    mem[floor32(arg2.length) + 97] = 0
    mem[floor32(arg2.length) + 129] = 0
    mem[floor32(arg2.length) + 161] = 0
    mem[floor32(arg2.length) + 193] = 96
    mem[floor32(arg2.length) + 225] = 0
    mem[floor32(arg2.length) + 257] = 0
    mem[floor32(arg2.length) + 289] = 0
    mem[floor32(arg2.length) + 321] = 96
    mem[floor32(arg2.length) + 353] = 3
    mem[floor32(arg2.length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(arg2.length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(arg2.length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(arg2.length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(arg2.length) + 485] = address(stor0)
    mem[floor32(arg2.length) + 517] = 160
    mem[floor32(arg2.length) + 645] = arg2.length
    idx = 0
    s = 128
    t = floor32(arg2.length) + 677
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(arg2.length) + 549] = 0
    mem[floor32(arg2.length) + 581] = 0
    mem[floor32(arg2.length) + 613] = (32 * arg2.length) + 192
    mem[floor32(arg2.length) + (32 * arg2.length) + 677] = 3
    idx = 0
    s = floor32(arg2.length) + 385
    t = floor32(arg2.length) + (32 * arg2.length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * arg2.length) + 192, arg2.length, mem[floor32(arg2.length) + 677 len (32 * arg2.length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(arg2.length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _278 = mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(arg2.length) + return_data.size + 481
    _279 = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + ceil32(return_data.size) + floor32(mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(arg2.length) + ceil32(return_data.size) + 481] = mem[floor32(arg2.length) + mem[floor32(arg2.length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _278 + (32 * _279) + 32 <= return_data.size
    idx = 0
    s = floor32(arg2.length) + _278 + 513
    t = floor32(arg2.length) + ceil32(return_data.size) + 513
    while idx < _279:
        _360 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_278 + -mem[s] - 32 >= 128
        _364 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(arg2.length) + _278 + _360 + 513] == mem[floor32(arg2.length) + _278 + _360 + 513]
        mem[_364] = mem[floor32(arg2.length) + _278 + _360 + 513]
        require mem[floor32(arg2.length) + _278 + _360 + 545] == mem[floor32(arg2.length) + _278 + _360 + 545]
        mem[_364 + 32] = mem[floor32(arg2.length) + _278 + _360 + 545]
        require mem[floor32(arg2.length) + _278 + _360 + 577] == mem[floor32(arg2.length) + _278 + _360 + 577]
        mem[_364 + 64] = mem[floor32(arg2.length) + _278 + _360 + 577]
        _421 = mem[floor32(arg2.length) + _278 + _360 + 609]
        require mem[floor32(arg2.length) + _278 + _360 + 609] <= test266151307()
        require floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 544 < floor32(arg2.length) + return_data.size + 481
        _423 = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        if mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _426 = mem[64]
        if mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]) + 1
        mem[_426] = mem[floor32(arg2.length) + _278 + _360 + mem[floor32(arg2.length) + _278 + _360 + 609] + 513]
        require _278 + _360 + _421 + (192 * _423) + 64 <= return_data.size
        u = 0
        v = floor32(arg2.length) + _278 + _360 + _421 + 545
        w = _426 + 32
        while u < _423:
            require floor32(arg2.length) + return_data.size + -v + 481 >= 192
            _462 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_462] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_462 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_462 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_462 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_462 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_462 + 160] = mem[v + 160]
            mem[w] = _462
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_364 + 96] = _426
        mem[t] = _364
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(arg2.length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(arg2.length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _442 = mem[floor32(arg2.length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 64]
    _511 = mem[mem[mem[floor32(arg2.length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _511:
        _514 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 32] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 32]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 64] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 64]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 96] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 96]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 128] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_442 + 96]]:
            revert with 'NH{q', 50
        mem[_514 + 160] = mem[mem[(32 * idx) + mem[_442 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_514 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_514 + 32]
        stor4[stor4.length].field_512 = mem[_514 + 64]
        stor4[stor4.length].field_768 = mem[_514 + 96]
        stor4[stor4.length].field_1024 = mem[_514 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_514 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _511 = mem[mem[_442 + 96]]
        idx = idx + 1
        continue 
    _512 = mem[64]
    mem[64] = mem[64] + 128
    mem[_512] = stor1
    mem[_512 + 32] = stor2
    mem[_512 + 64] = stor3
    _513 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_513] = stor4.length
    s = _513 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _563 = mem[64]
        mem[64] = mem[64] + 192
        mem[_563] = stor4[idx].field_0
        mem[_563 + 32] = stor4[idx].field_256
        mem[_563 + 64] = stor4[idx].field_512
        mem[_563 + 96] = stor4[idx].field_768
        mem[_563 + 128] = stor4[idx].field_1024
        mem[_563 + 160] = stor4[idx].field_1280
        mem[s] = _563
        s = s + 32
        idx = idx + 1
        continue 
    mem[_512 + 96] = _513
    _564 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_512]
    mem[mem[64] + 64] = mem[_512 + 32]
    mem[mem[64] + 96] = mem[_512 + 64]
    mem[mem[64] + 128] = 128
    _569 = mem[_513]
    mem[mem[64] + 160] = mem[_513]
    idx = 0
    s = _513 + 32
    t = mem[64] + 192
    while idx < _569:
        _578 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_578 + 32]
        mem[t + 64] = mem[_578 + 64]
        mem[t + 96] = mem[_578 + 96]
        mem[t + 128] = mem[_578 + 140 len 20]
        mem[t + 160] = mem[_578 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _564 + (192 * _569) + -mem[64] + 192
}

function sub_074351a9(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + 97 > test266151307() or floor32(('cd', 4).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(('cd', 4).length) + 97] = 0
    mem[floor32(('cd', 4).length) + 129] = 0
    mem[floor32(('cd', 4).length) + 161] = 0
    mem[floor32(('cd', 4).length) + 193] = 96
    mem[floor32(('cd', 4).length) + 225] = 3
    mem[floor32(('cd', 4).length) + 257] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(('cd', 4).length) + 289] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(('cd', 4).length) + 321] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(('cd', 4).length) + 353] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(('cd', 4).length) + 357] = address(stor0)
    mem[floor32(('cd', 4).length) + 389] = 160
    mem[floor32(('cd', 4).length) + 517] = ('cd', 4).length
    idx = 0
    s = 128
    t = floor32(('cd', 4).length) + 549
    while idx < ('cd', 4).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(('cd', 4).length) + 421] = 0
    mem[floor32(('cd', 4).length) + 453] = 0
    mem[floor32(('cd', 4).length) + 485] = (32 * ('cd', 4).length) + 192
    mem[floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 549] = 3
    idx = 0
    s = floor32(('cd', 4).length) + 257
    t = floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 581
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * ('cd', 4).length) + 192, ('cd', 4).length, mem[floor32(('cd', 4).length) + 549 len (32 * ('cd', 4).length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(('cd', 4).length) + 353 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + 353
    require return_data.size >= 32
    _280 = mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0)
    require mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 384 < floor32(('cd', 4).length) + return_data.size + 353
    _281 = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]
    if mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353] > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 354 > test266151307() or floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 354
    mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353] = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]
    require _280 + (32 * _281) + 32 <= return_data.size
    idx = 0
    s = floor32(('cd', 4).length) + _280 + 385
    t = floor32(('cd', 4).length) + ceil32(return_data.size) + 385
    while idx < _281:
        _362 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_280 + -mem[s] - 32 >= 128
        _366 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(('cd', 4).length) + _280 + _362 + 385] == mem[floor32(('cd', 4).length) + _280 + _362 + 385]
        mem[_366] = mem[floor32(('cd', 4).length) + _280 + _362 + 385]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 417] == mem[floor32(('cd', 4).length) + _280 + _362 + 417]
        mem[_366 + 32] = mem[floor32(('cd', 4).length) + _280 + _362 + 417]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 449] == mem[floor32(('cd', 4).length) + _280 + _362 + 449]
        mem[_366 + 64] = mem[floor32(('cd', 4).length) + _280 + _362 + 449]
        _423 = mem[floor32(('cd', 4).length) + _280 + _362 + 481]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 481] <= test266151307()
        require floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 416 < floor32(('cd', 4).length) + return_data.size + 353
        _426 = mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 385]
        if mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 385] > test266151307():
            revert with 'NH{q', 65
        _429 = mem[64]
        if mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 385]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 385]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 481] + 385]) + 1
        mem[_429] = _426
        require _280 + _362 + _423 + (192 * _426) + 64 <= return_data.size
        u = 0
        v = floor32(('cd', 4).length) + _280 + _362 + _423 + 417
        w = _429 + 32
        while u < _426:
            require floor32(('cd', 4).length) + return_data.size + -v + 353 >= 192
            _464 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_464] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_464 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_464 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_464 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_464 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_464 + 160] = mem[v + 160]
            mem[w] = _464
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_366 + 96] = _429
        mem[t] = _366
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
        if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 64] > 0:
            if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
        revert with 'NH{q', 50
    _444 = mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385]
    stor1 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385]]
    stor2 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 32]
    stor3 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 64]
    _513 = mem[mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 96]]
    idx = 0
    while idx < _513:
        _516 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 32] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 32]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 64] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 64]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 96] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 96]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 128] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 160] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_516 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_516 + 32]
        stor4[stor4.length].field_512 = mem[_516 + 64]
        stor4[stor4.length].field_768 = mem[_516 + 96]
        stor4[stor4.length].field_1024 = mem[_516 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_516 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _513 = mem[mem[_444 + 96]]
        idx = idx + 1
        continue 
    _514 = mem[64]
    mem[64] = mem[64] + 128
    mem[_514] = stor1
    mem[_514 + 32] = stor2
    mem[_514 + 64] = stor3
    _515 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_515] = stor4.length
    s = _515 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _565 = mem[64]
        mem[64] = mem[64] + 192
        mem[_565] = stor4[idx].field_0
        mem[_565 + 32] = stor4[idx].field_256
        mem[_565 + 64] = stor4[idx].field_512
        mem[_565 + 96] = stor4[idx].field_768
        mem[_565 + 128] = stor4[idx].field_1024
        mem[_565 + 160] = stor4[idx].field_1280
        mem[s] = _565
        s = s + 32
        idx = idx + 1
        continue 
    mem[_514 + 96] = _515
    _566 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_514]
    mem[mem[64] + 64] = mem[_514 + 32]
    mem[mem[64] + 96] = mem[_514 + 64]
    mem[mem[64] + 128] = 128
    _571 = mem[_515]
    mem[mem[64] + 160] = mem[_515]
    idx = 0
    s = _515 + 32
    t = mem[64] + 192
    while idx < _571:
        _580 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_580 + 32]
        mem[t + 64] = mem[_580 + 64]
        mem[t + 96] = mem[_580 + 96]
        mem[t + 128] = mem[_580 + 140 len 20]
        mem[t + 160] = mem[_580 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _566 + (192 * _571) + -mem[64] + 192
}

function sub_b293b3c4(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + 97 > test266151307() or floor32(('cd', 4).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] == address(cd[36])
    mem[floor32(('cd', 4).length) + 97] = 0
    mem[floor32(('cd', 4).length) + 129] = 0
    mem[floor32(('cd', 4).length) + 161] = 0
    mem[floor32(('cd', 4).length) + 193] = 96
    address(stor0) = address(cd[36])
    mem[floor32(('cd', 4).length) + 225] = 0
    mem[floor32(('cd', 4).length) + 257] = 0
    mem[floor32(('cd', 4).length) + 289] = 0
    mem[floor32(('cd', 4).length) + 321] = 96
    mem[floor32(('cd', 4).length) + 353] = 3
    mem[floor32(('cd', 4).length) + 385] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(('cd', 4).length) + 417] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(('cd', 4).length) + 449] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(('cd', 4).length) + 481] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(('cd', 4).length) + 485] = address(stor0)
    mem[floor32(('cd', 4).length) + 517] = 160
    mem[floor32(('cd', 4).length) + 645] = ('cd', 4).length
    idx = 0
    s = 128
    t = floor32(('cd', 4).length) + 677
    while idx < ('cd', 4).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(('cd', 4).length) + 549] = 0
    mem[floor32(('cd', 4).length) + 581] = 0
    mem[floor32(('cd', 4).length) + 613] = (32 * ('cd', 4).length) + 192
    mem[floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 677] = 3
    idx = 0
    s = floor32(('cd', 4).length) + 385
    t = floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 709
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * ('cd', 4).length) + 192, ('cd', 4).length, mem[floor32(('cd', 4).length) + 677 len (32 * ('cd', 4).length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(('cd', 4).length) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + 481
    require return_data.size >= 32
    _280 = mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0)
    require mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 512 < floor32(('cd', 4).length) + return_data.size + 481
    _281 = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481]
    if mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481] > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482 > test266151307() or floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481]) + 482
    mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 481] = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 481 len 4], Mask(224, 0, stor0) + 481]
    require _280 + (32 * _281) + 32 <= return_data.size
    idx = 0
    s = floor32(('cd', 4).length) + _280 + 513
    t = floor32(('cd', 4).length) + ceil32(return_data.size) + 513
    while idx < _281:
        _362 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_280 + -mem[s] - 32 >= 128
        _366 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(('cd', 4).length) + _280 + _362 + 513] == mem[floor32(('cd', 4).length) + _280 + _362 + 513]
        mem[_366] = mem[floor32(('cd', 4).length) + _280 + _362 + 513]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 545] == mem[floor32(('cd', 4).length) + _280 + _362 + 545]
        mem[_366 + 32] = mem[floor32(('cd', 4).length) + _280 + _362 + 545]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 577] == mem[floor32(('cd', 4).length) + _280 + _362 + 577]
        mem[_366 + 64] = mem[floor32(('cd', 4).length) + _280 + _362 + 577]
        _423 = mem[floor32(('cd', 4).length) + _280 + _362 + 609]
        require mem[floor32(('cd', 4).length) + _280 + _362 + 609] <= test266151307()
        require floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 544 < floor32(('cd', 4).length) + return_data.size + 481
        _425 = mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 513]
        if mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 513] > test266151307():
            revert with 'NH{q', 65
        _428 = mem[64]
        if mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 513]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 513]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(('cd', 4).length) + _280 + _362 + mem[floor32(('cd', 4).length) + _280 + _362 + 609] + 513]) + 1
        mem[_428] = _425
        require _280 + _362 + _423 + (192 * _425) + 64 <= return_data.size
        u = 0
        v = floor32(('cd', 4).length) + _280 + _362 + _423 + 545
        w = _428 + 32
        while u < _425:
            require floor32(('cd', 4).length) + return_data.size + -v + 481 >= 192
            _464 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_464] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_464 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_464 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_464 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_464 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_464 + 160] = mem[v + 160]
            mem[w] = _464
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_366 + 96] = _428
        mem[t] = _366
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 481]:
        if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 481]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(('cd', 4).length) + ceil32(return_data.size) + 513] + 64] > 0:
            if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 481]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 481]:
        revert with 'NH{q', 50
    _444 = mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 513]
    stor1 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 513]]
    stor2 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 513] + 32]
    stor3 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 513] + 64]
    _513 = mem[mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 513] + 96]]
    idx = 0
    while idx < _513:
        _516 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 32] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 32]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 64] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 64]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 96] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 96]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 128] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_444 + 96]]:
            revert with 'NH{q', 50
        mem[_516 + 160] = mem[mem[(32 * idx) + mem[_444 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_516 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_516 + 32]
        stor4[stor4.length].field_512 = mem[_516 + 64]
        stor4[stor4.length].field_768 = mem[_516 + 96]
        stor4[stor4.length].field_1024 = mem[_516 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_516 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _513 = mem[mem[_444 + 96]]
        idx = idx + 1
        continue 
    _514 = mem[64]
    mem[64] = mem[64] + 128
    mem[_514] = stor1
    mem[_514 + 32] = stor2
    mem[_514 + 64] = stor3
    _515 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_515] = stor4.length
    s = _515 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _565 = mem[64]
        mem[64] = mem[64] + 192
        mem[_565] = stor4[idx].field_0
        mem[_565 + 32] = stor4[idx].field_256
        mem[_565 + 64] = stor4[idx].field_512
        mem[_565 + 96] = stor4[idx].field_768
        mem[_565 + 128] = stor4[idx].field_1024
        mem[_565 + 160] = stor4[idx].field_1280
        mem[s] = _565
        s = s + 32
        idx = idx + 1
        continue 
    mem[_514 + 96] = _515
    _566 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_514]
    mem[mem[64] + 64] = mem[_514 + 32]
    mem[mem[64] + 96] = mem[_514 + 64]
    mem[mem[64] + 128] = 128
    _571 = mem[_515]
    mem[mem[64] + 160] = mem[_515]
    idx = 0
    s = _515 + 32
    t = mem[64] + 192
    while idx < _571:
        _580 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_580 + 32]
        mem[t + 64] = mem[_580 + 64]
        mem[t + 96] = mem[_580 + 96]
        mem[t + 128] = mem[_580 + 140 len 20]
        mem[t + 160] = mem[_580 + 172 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _566 + (192 * _571) + -mem[64] + 192
}

function sub_d5ffafcc(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + 97 > test266151307() or floor32(('cd', 4).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] == address(cd[36])
    address(stor0) = address(cd[36])
    mem[floor32(('cd', 4).length) + 97] = 0
    mem[floor32(('cd', 4).length) + 129] = 0
    mem[floor32(('cd', 4).length) + 161] = 0
    mem[floor32(('cd', 4).length) + 193] = 96
    mem[floor32(('cd', 4).length) + 225] = 3
    mem[floor32(('cd', 4).length) + 257] = 0xe54ca86531e17ef3616d22ca28b0d458b6c89106
    mem[floor32(('cd', 4).length) + 289] = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    mem[floor32(('cd', 4).length) + 321] = 0xd8aa70f7990dab4a383a0d8a57df7a372916575d
    mem[floor32(('cd', 4).length) + 353] = 0xaef022b800000000000000000000000000000000000000000000000000000000
    mem[floor32(('cd', 4).length) + 357] = address(stor0)
    mem[floor32(('cd', 4).length) + 389] = 160
    mem[floor32(('cd', 4).length) + 517] = ('cd', 4).length
    idx = 0
    s = 128
    t = floor32(('cd', 4).length) + 549
    while idx < ('cd', 4).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[floor32(('cd', 4).length) + 421] = 0
    mem[floor32(('cd', 4).length) + 453] = 0
    mem[floor32(('cd', 4).length) + 485] = (32 * ('cd', 4).length) + 192
    mem[floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 549] = 3
    idx = 0
    s = floor32(('cd', 4).length) + 257
    t = floor32(('cd', 4).length) + (32 * ('cd', 4).length) + 581
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0x6ffb1bb6811b07aa326eecd1320a5a3297371de2)
    staticcall 0x6ffb1bb6811b07aa326eecd1320a5a3297371de2.0xaef022b8 with:
            gas gas_remaining wei
           args address(stor0), 160, 0, 0, (32 * ('cd', 4).length) + 192, ('cd', 4).length, mem[floor32(('cd', 4).length) + 549 len (32 * ('cd', 4).length) + 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[floor32(('cd', 4).length) + 353 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + 353
    require return_data.size >= 32
    _398 = mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0)
    require mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) <= test266151307()
    require floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 384 < floor32(('cd', 4).length) + return_data.size + 353
    _399 = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]
    if mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353] > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 354 > test266151307() or floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 4).length) + ceil32(return_data.size) + floor32(mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]) + 354
    mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353] = mem[floor32(('cd', 4).length) + mem[floor32(('cd', 4).length) + 353 len 4], Mask(224, 0, stor0) + 353]
    require _398 + (32 * _399) + 32 <= return_data.size
    idx = 0
    s = floor32(('cd', 4).length) + _398 + 385
    t = floor32(('cd', 4).length) + ceil32(return_data.size) + 385
    while idx < _399:
        _520 = mem[s]
        require mem[s] <= test266151307()
        require return_data.size + -_398 + -mem[s] - 32 >= 128
        _524 = mem[64]
        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 128
        require mem[floor32(('cd', 4).length) + _398 + _520 + 385] == mem[floor32(('cd', 4).length) + _398 + _520 + 385]
        mem[_524] = mem[floor32(('cd', 4).length) + _398 + _520 + 385]
        require mem[floor32(('cd', 4).length) + _398 + _520 + 417] == mem[floor32(('cd', 4).length) + _398 + _520 + 417]
        mem[_524 + 32] = mem[floor32(('cd', 4).length) + _398 + _520 + 417]
        require mem[floor32(('cd', 4).length) + _398 + _520 + 449] == mem[floor32(('cd', 4).length) + _398 + _520 + 449]
        mem[_524 + 64] = mem[floor32(('cd', 4).length) + _398 + _520 + 449]
        _616 = mem[floor32(('cd', 4).length) + _398 + _520 + 481]
        require mem[floor32(('cd', 4).length) + _398 + _520 + 481] <= test266151307()
        require floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 416 < floor32(('cd', 4).length) + return_data.size + 353
        _617 = mem[floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 385]
        if mem[floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 385] > test266151307():
            revert with 'NH{q', 65
        _622 = mem[64]
        if mem[64] + floor32(mem[floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 385]) + 1 > test266151307() or mem[64] + floor32(mem[floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 385]) + 1 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + floor32(mem[floor32(('cd', 4).length) + _398 + _520 + mem[floor32(('cd', 4).length) + _398 + _520 + 481] + 385]) + 1
        mem[_622] = _617
        require _398 + _520 + _616 + (192 * _617) + 64 <= return_data.size
        u = 0
        v = floor32(('cd', 4).length) + _398 + _520 + _616 + 417
        w = _622 + 32
        while u < _617:
            require floor32(('cd', 4).length) + return_data.size + -v + 353 >= 192
            _662 = mem[64]
            if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
                revert with 'NH{q', 65
            mem[64] = mem[64] + 192
            require mem[v] == mem[v + 12 len 20]
            mem[_662] = mem[v]
            require mem[v + 32] == mem[v + 32]
            mem[_662 + 32] = mem[v + 32]
            require mem[v + 64] == mem[v + 64]
            mem[_662 + 64] = mem[v + 64]
            require mem[v + 96] == mem[v + 96]
            mem[_662 + 96] = mem[v + 96]
            require mem[v + 128] == mem[v + 140 len 20]
            mem[_662 + 128] = mem[v + 128]
            require mem[v + 160] == mem[v + 172 len 20]
            mem[_662 + 160] = mem[v + 160]
            mem[w] = _662
            u = u + 1
            v = v + 192
            w = w + 32
            continue 
        mem[_524 + 96] = _622
        mem[t] = _524
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
        if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
            revert with 'NH{q', 50
        if mem[mem[(32 * idx) + floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 64] > 0:
            if idx >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
                revert with 'NH{q', 50
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    if 0 >= mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 353]:
        revert with 'NH{q', 50
    _642 = mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385]
    stor1 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385]]
    stor2 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 32]
    stor3 = mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 64]
    _751 = mem[mem[mem[floor32(('cd', 4).length) + ceil32(return_data.size) + 385] + 96]]
    idx = 0
    while idx < _751:
        _754 = mem[64]
        mem[64] = mem[64] + 192
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 12 len 20]
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754 + 32] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 32]
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754 + 64] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 64]
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754 + 96] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 96]
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754 + 128] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 140 len 20]
        if idx >= mem[mem[_642 + 96]]:
            revert with 'NH{q', 50
        mem[_754 + 160] = mem[mem[(32 * idx) + mem[_642 + 96] + 32] + 172 len 20]
        stor4.length++
        mem[0] = 4
        stor4[stor4.length].field_0 = mem[_754 + 12 len 20]
        stor4[stor4.length].field_256 = mem[_754 + 32]
        stor4[stor4.length].field_512 = mem[_754 + 64]
        stor4[stor4.length].field_768 = mem[_754 + 96]
        stor4[stor4.length].field_1024 = mem[_754 + 140 len 20]
        stor4[stor4.length].field_1280 = mem[_754 + 172 len 20]
        if idx == -1:
            revert with 'NH{q', 17
        _751 = mem[mem[_642 + 96]]
        idx = idx + 1
        continue 
    _752 = mem[64]
    mem[64] = mem[64] + 128
    mem[_752] = stor1
    mem[_752 + 32] = stor2
    mem[_752 + 64] = stor3
    _753 = mem[64]
    mem[64] = mem[64] + (32 * stor4.length) + 32
    mem[_753] = stor4.length
    s = _753 + 32
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        _843 = mem[64]
        mem[64] = mem[64] + 192
        mem[_843] = stor4[idx].field_0
        mem[_843 + 32] = stor4[idx].field_256
        mem[_843 + 64] = stor4[idx].field_512
        mem[_843 + 96] = stor4[idx].field_768
        mem[_843 + 128] = stor4[idx].field_1024
        mem[_843 + 160] = stor4[idx].field_1280
        mem[s] = _843
        s = s + 32
        idx = idx + 1
        continue 
    mem[_752 + 96] = _753
    require stor3
    if stor4.length > test266151307():
        revert with 'NH{q', 65
    _844 = mem[64]
    mem[mem[64]] = stor4.length
    mem[64] = mem[64] + (32 * stor4.length) + 32
    if not stor4.length:
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        while idx < stor4.length:
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            if address(s) != stor4[idx].field_1024:
                if address(s) != stor4[idx].field_1280:
                    _903 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_903] = 0
                    if idx >= stor4.length:
                        revert with 'NH{q', 50
                    mem[0] = 4
                    mem[_903 + 32] = stor4[idx].field_0
                    mem[_903 + 64] = 300
                    mem[_903 + 96] = 1
                    if idx >= mem[_844]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + _844 + 32] = _903
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = 0
                    continue 
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                _908 = mem[64]
                mem[64] = mem[64] + 128
                mem[_908] = stor4[idx].field_1024
                mem[0] = 4
                mem[_908 + 32] = stor4[idx].field_0
                mem[_908 + 64] = 300
                mem[_908 + 96] = 1
                if idx >= mem[_844]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + _844 + 32] = _908
            else:
                if address(s) != stor4[idx].field_1280:
                    _909 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_909] = stor4[idx].field_1280
                    if idx >= stor4.length:
                        revert with 'NH{q', 50
                    mem[0] = 4
                    mem[_909 + 32] = stor4[idx].field_0
                    mem[_909 + 64] = 300
                    mem[_909 + 96] = 1
                    if idx >= mem[_844]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + _844 + 32] = _909
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = stor4[idx].field_1280
                    continue 
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                _917 = mem[64]
                mem[64] = mem[64] + 128
                mem[_917] = stor4[idx].field_1024
                mem[0] = 4
                mem[_917 + 32] = stor4[idx].field_0
                mem[_917 + 64] = 300
                mem[_917 + 96] = 1
                if idx >= mem[_844]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + _844 + 32] = _917
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = stor4[idx].field_1024
            continue 
        _900 = mem[64]
        mem[mem[64]] = stor1
        mem[mem[64] + 32] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[mem[64] + 64] = 96
        _937 = mem[_844]
        mem[mem[64] + 96] = mem[_844]
        idx = 0
        s = _844 + 32
        t = mem[64] + 128
        while idx < _937:
            _952 = mem[s]
            mem[t] = mem[mem[s] + 12 len 20]
            mem[t + 32] = mem[_952 + 44 len 20]
            mem[t + 64] = mem[_952 + 64]
            mem[t + 96] = mem[_952 + 96]
            idx = idx + 1
            s = s + 32
            t = t + 128
            continue 
        return memory
          from mem[64]
           len _900 + (128 * _937) + -mem[64] + 128
    mem[64] = _844 + (32 * stor4.length) + 160
    mem[_844 + (32 * stor4.length) + 32] = 0
    mem[_844 + (32 * stor4.length) + 64] = 0
    mem[_844 + (32 * stor4.length) + 96] = 0
    mem[_844 + (32 * stor4.length) + 128] = 0
    mem[var133001] = _844 + (32 * stor4.length) + 32
    s = var133001
    idx = var133002
    while idx - 1:
        mem[64] = mem[64] + 128
        mem[_844 + (32 * stor4.length) + 32] = 0
        mem[_844 + (32 * stor4.length) + 64] = 0
        mem[_844 + (32 * stor4.length) + 96] = 0
        mem[_844 + (32 * stor4.length) + 128] = 0
        mem[s + 32] = _844 + (32 * stor4.length) + 32
        s = s + 32
        idx = idx - 1
        continue 
    idx = 0
    s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
    while idx < stor4.length:
        if idx >= stor4.length:
            revert with 'NH{q', 50
        mem[0] = 4
        if address(s) != stor4[idx].field_1024:
            if address(s) != stor4[idx].field_1280:
                _988 = mem[64]
                mem[64] = mem[64] + 128
                mem[_988] = 0
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                mem[_988 + 32] = stor4[idx].field_0
                mem[_988 + 64] = 300
                mem[_988 + 96] = 1
                if idx >= mem[_844]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + _844 + 32] = _988
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = 0
                continue 
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            _993 = mem[64]
            mem[64] = mem[64] + 128
            mem[_993] = stor4[idx].field_1024
            mem[0] = 4
            mem[_993 + 32] = stor4[idx].field_0
            mem[_993 + 64] = 300
            mem[_993 + 96] = 1
            if idx >= mem[_844]:
                revert with 'NH{q', 50
            mem[(32 * idx) + _844 + 32] = _993
        else:
            if address(s) != stor4[idx].field_1280:
                _994 = mem[64]
                mem[64] = mem[64] + 128
                mem[_994] = stor4[idx].field_1280
                if idx >= stor4.length:
                    revert with 'NH{q', 50
                mem[0] = 4
                mem[_994 + 32] = stor4[idx].field_0
                mem[_994 + 64] = 300
                mem[_994 + 96] = 1
                if idx >= mem[_844]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + _844 + 32] = _994
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = stor4[idx].field_1280
                continue 
            if idx >= stor4.length:
                revert with 'NH{q', 50
            mem[0] = 4
            _1000 = mem[64]
            mem[64] = mem[64] + 128
            mem[_1000] = stor4[idx].field_1024
            mem[0] = 4
            mem[_1000 + 32] = stor4[idx].field_0
            mem[_1000 + 64] = 300
            mem[_1000 + 96] = 1
            if idx >= mem[_844]:
                revert with 'NH{q', 50
            mem[(32 * idx) + _844 + 32] = _1000
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        s = stor4[idx].field_1024
        continue 
    _985 = mem[64]
    mem[mem[64]] = stor1
    mem[mem[64] + 32] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
    mem[mem[64] + 64] = 96
    _1003 = mem[_844]
    mem[mem[64] + 96] = mem[_844]
    idx = 0
    s = _844 + 32
    t = mem[64] + 128
    while idx < _1003:
        _1010 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_1010 + 44 len 20]
        mem[t + 64] = mem[_1010 + 64]
        mem[t + 96] = mem[_1010 + 96]
        idx = idx + 1
        s = s + 32
        t = t + 128
        continue 
    return memory
      from mem[64]
       len _985 + (128 * _1003) + -mem[64] + 128
}



}

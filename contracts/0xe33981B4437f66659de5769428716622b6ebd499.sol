contract main {




// =====================  Runtime code  =====================


#
#  - sub_029c4aea(?)
#
address stor1;
address stor2;
address stor3;
address stor4;
address stor5;
address stor6;
mapping of address stor11;
mapping of address stor12;
mapping of address stor13;

function _fallback() payable {
    revert
}

function sub_9c4a79d5(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == arg2
    mem[100] = msg.sender
    require ext_code.size(stor2)
    staticcall stor2.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] >= arg2:
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = this.address
        mem[ceil32(return_data.size) + 164] = arg2
        require ext_code.size(stor2)
        call stor2.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require address(arg1)
        if address(arg1) == stor3:
            mem[(2 * ceil32(return_data.size)) + 100] = stor6
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor6, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor6)
            call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _137 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _141 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _137 + (32 * _141) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _137 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _141:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _357 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _363 = mem[_357]
            require mem[_357] == mem[_357]
            mem[0] = address(arg1)
            mem[32] = 13
            mem[mem[64] + 4] = stor13[address(arg1)]
            mem[mem[64] + 36] = _363
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor13[address(arg1)], _363
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _383 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_383] == bool(mem[_383])
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _403 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _409 = mem[_403]
            require mem[_403] == mem[_403]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _423 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _433 = mem[_423]
            require mem[_423] == mem[_423]
            require mem[_423 + 32] == mem[_423 + 32]
            require mem[_423 + 64] == mem[_423 + 92 len 4]
            require mem[_423 + 96] == mem[_423 + 124 len 4]
            mem[mem[64] + 4] = _363
            mem[mem[64] + 36] = _409
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor13[address(arg1)])
            call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _363, _409, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _485 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_485] == mem[_485]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _505 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_505] == mem[_505]
            require mem[_505 + 32] == mem[_505 + 32]
            require mem[_505 + 64] == mem[_505 + 92 len 4]
            require mem[_505 + 96] == mem[_505 + 124 len 4]
            if mem[_505] < _433:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_505] - _433
        else:
            mem[(2 * ceil32(return_data.size)) + 100] = stor5
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor5, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor5)
            call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _138 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _142 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _138 + (32 * _142) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _138 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _142:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _358 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _364 = mem[_358]
            require mem[_358] == mem[_358]
            mem[0] = address(arg1)
            mem[32] = 13
            mem[mem[64] + 4] = stor13[address(arg1)]
            mem[mem[64] + 36] = _364
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor13[address(arg1)], _364
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _384 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_384] == bool(mem[_384])
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _404 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _410 = mem[_404]
            require mem[_404] == mem[_404]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _424 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _434 = mem[_424]
            require mem[_424] == mem[_424]
            require mem[_424 + 32] == mem[_424 + 32]
            require mem[_424 + 64] == mem[_424 + 92 len 4]
            require mem[_424 + 96] == mem[_424 + 124 len 4]
            mem[mem[64] + 4] = _364
            mem[mem[64] + 36] = _410
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor13[address(arg1)])
            call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _364, _410, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _486 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_486] == mem[_486]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _506 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_506] == mem[_506]
            require mem[_506 + 32] == mem[_506 + 32]
            require mem[_506 + 64] == mem[_506 + 92 len 4]
            require mem[_506 + 96] == mem[_506 + 124 len 4]
            if mem[_506] < _434:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_506] - _434
    else:
        if arg2 < ext_call.return_data[0]:
            revert with 'NH{q', 17
        mem[ceil32(return_data.size) + 100] = msg.sender
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = this.address
        if ext_call.return_data[0] >= arg2 - ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + 164] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg2 - ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, arg2 - ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args arg2 - ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require address(arg1)
            if address(arg1) == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _359 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _365 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _359 + (32 * _365) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _359 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _365:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _567 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _571 = mem[_567]
                require mem[_567] == mem[_567]
                mem[0] = address(arg1)
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _571
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _571
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _587 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_587] == bool(mem[_587])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _603 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _607 = mem[_603]
                require mem[_603] == mem[_603]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _619 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _623 = mem[_619]
                require mem[_619] == mem[_619]
                require mem[_619 + 32] == mem[_619 + 32]
                require mem[_619 + 64] == mem[_619 + 92 len 4]
                require mem[_619 + 96] == mem[_619 + 124 len 4]
                mem[mem[64] + 4] = _571
                mem[mem[64] + 36] = _607
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _571, _607, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _647 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_647] == mem[_647]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _663 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_663] == mem[_663]
                require mem[_663 + 32] == mem[_663 + 32]
                require mem[_663 + 64] == mem[_663 + 92 len 4]
                require mem[_663 + 96] == mem[_663 + 124 len 4]
                if mem[_663] < _623:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_663] - _623
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _360 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _366 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _360 + (32 * _366) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _360 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _366:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _568 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _572 = mem[_568]
                require mem[_568] == mem[_568]
                mem[0] = address(arg1)
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _572
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _572
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _588 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_588] == bool(mem[_588])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _604 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _608 = mem[_604]
                require mem[_604] == mem[_604]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _620 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _624 = mem[_620]
                require mem[_620] == mem[_620]
                require mem[_620 + 32] == mem[_620 + 32]
                require mem[_620 + 64] == mem[_620 + 92 len 4]
                require mem[_620 + 96] == mem[_620 + 124 len 4]
                mem[mem[64] + 4] = _572
                mem[mem[64] + 36] = _608
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _572, _608, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _648 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_648] == mem[_648]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _664 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_664] == mem[_664]
                require mem[_664 + 32] == mem[_664 + 32]
                require mem[_664 + 64] == mem[_664 + 92 len 4]
                require mem[_664 + 96] == mem[_664 + 124 len 4]
                if mem[_664] < _624:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_664] - _624
        else:
            mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require address(arg1)
            if address(arg1) == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _361 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _367 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _361 + (32 * _367) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _361 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _367:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _569 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _573 = mem[_569]
                require mem[_569] == mem[_569]
                mem[0] = address(arg1)
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _573
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _573
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _589 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_589] == bool(mem[_589])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _605 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _609 = mem[_605]
                require mem[_605] == mem[_605]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _621 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _625 = mem[_621]
                require mem[_621] == mem[_621]
                require mem[_621 + 32] == mem[_621 + 32]
                require mem[_621 + 64] == mem[_621 + 92 len 4]
                require mem[_621 + 96] == mem[_621 + 124 len 4]
                mem[mem[64] + 4] = _573
                mem[mem[64] + 36] = _609
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _573, _609, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _649 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_649] == mem[_649]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _665 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_665] == mem[_665]
                require mem[_665 + 32] == mem[_665 + 32]
                require mem[_665 + 64] == mem[_665 + 92 len 4]
                require mem[_665 + 96] == mem[_665 + 124 len 4]
                if mem[_665] < _625:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_665] - _625
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _362 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _368 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _362 + (32 * _368) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _362 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _368:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _570 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _574 = mem[_570]
                require mem[_570] == mem[_570]
                mem[0] = address(arg1)
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _574
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _574
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _590 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_590] == bool(mem[_590])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _606 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _610 = mem[_606]
                require mem[_606] == mem[_606]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _622 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _626 = mem[_622]
                require mem[_622] == mem[_622]
                require mem[_622 + 32] == mem[_622 + 32]
                require mem[_622 + 64] == mem[_622 + 92 len 4]
                require mem[_622 + 96] == mem[_622 + 124 len 4]
                mem[mem[64] + 4] = _574
                mem[mem[64] + 36] = _610
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _574, _610, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _650 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_650] == mem[_650]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _666 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_666] == mem[_666]
                require mem[_666 + 32] == mem[_666 + 32]
                require mem[_666 + 64] == mem[_666 + 92 len 4]
                require mem[_666 + 96] == mem[_666 + 124 len 4]
                if mem[_666] < _626:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_666] - _626
    return memory
      from mem[64]
       len 32
}

function mintWithERC20(address arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    mem[100] = msg.sender
    require ext_code.size(stor2)
    staticcall stor2.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] >= arg2:
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = this.address
        mem[ceil32(return_data.size) + 164] = arg2
        require ext_code.size(stor2)
        call stor2.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require arg1
        if arg1 == stor3:
            mem[(2 * ceil32(return_data.size)) + 100] = stor6
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor6, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = arg1
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor6)
            call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _119 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _127 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _119 + (32 * _127) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _119 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _127:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _349 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _355 = mem[_349]
            require mem[_349] == mem[_349]
            mem[0] = arg1
            mem[32] = 13
            mem[mem[64] + 4] = stor13[address(arg1)]
            mem[mem[64] + 36] = _355
            require ext_code.size(arg1)
            call arg1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor13[address(arg1)], _355
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _375 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_375] == bool(mem[_375])
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _395 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _401 = mem[_395]
            require mem[_395] == mem[_395]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _415 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _425 = mem[_415]
            require mem[_415] == mem[_415]
            require mem[_415 + 32] == mem[_415 + 32]
            require mem[_415 + 64] == mem[_415 + 92 len 4]
            require mem[_415 + 96] == mem[_415 + 124 len 4]
            mem[mem[64] + 4] = _355
            mem[mem[64] + 36] = _401
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor13[address(arg1)])
            call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _355, _401, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_477] == mem[_477]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _497 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_497] == mem[_497]
            require mem[_497 + 32] == mem[_497 + 32]
            require mem[_497 + 64] == mem[_497 + 92 len 4]
            require mem[_497 + 96] == mem[_497 + 124 len 4]
            if mem[_497] < _425:
                revert with 'NH{q', 17
            if mem[_497] - _425 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _551 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _553 = mem[_551]
            require mem[_551] == mem[_551]
            if mem[_551] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _577 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _587 = mem[_577]
                require mem[_577] == mem[_577]
                if mem[_577] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _587
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _587
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _615 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_615] == bool(mem[_615])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _553
                require ext_code.size(arg1)
                call arg1.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _553
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _581 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_581] == bool(mem[_581])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _616 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _624 = mem[_616]
                require mem[_616] == mem[_616]
                if mem[_616] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _624
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _624
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _651 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_651] == bool(mem[_651])
        else:
            mem[(2 * ceil32(return_data.size)) + 100] = stor5
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor5, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = arg1
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor5)
            call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _120 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _128 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _120 + (32 * _128) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _120 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _128:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _350 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _356 = mem[_350]
            require mem[_350] == mem[_350]
            mem[0] = arg1
            mem[32] = 13
            mem[mem[64] + 4] = stor13[address(arg1)]
            mem[mem[64] + 36] = _356
            require ext_code.size(arg1)
            call arg1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor13[address(arg1)], _356
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _376 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_376] == bool(mem[_376])
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _396 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _402 = mem[_396]
            require mem[_396] == mem[_396]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _416 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _426 = mem[_416]
            require mem[_416] == mem[_416]
            require mem[_416 + 32] == mem[_416 + 32]
            require mem[_416 + 64] == mem[_416 + 92 len 4]
            require mem[_416 + 96] == mem[_416 + 124 len 4]
            mem[mem[64] + 4] = _356
            mem[mem[64] + 36] = _402
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor13[address(arg1)])
            call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _356, _402, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _478 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_478] == mem[_478]
            require ext_code.size(stor13[address(arg1)])
            staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _498 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_498] == mem[_498]
            require mem[_498 + 32] == mem[_498 + 32]
            require mem[_498 + 64] == mem[_498 + 92 len 4]
            require mem[_498 + 96] == mem[_498 + 124 len 4]
            if mem[_498] < _426:
                revert with 'NH{q', 17
            if mem[_498] - _426 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _552 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _554 = mem[_552]
            require mem[_552] == mem[_552]
            if mem[_552] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _579 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _588 = mem[_579]
                require mem[_579] == mem[_579]
                if mem[_579] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _588
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _588
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _617 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_617] == bool(mem[_617])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _554
                require ext_code.size(arg1)
                call arg1.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _554
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _582 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_582] == bool(mem[_582])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _618 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _626 = mem[_618]
                require mem[_618] == mem[_618]
                if mem[_618] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _626
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _626
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_652] == bool(mem[_652])
    else:
        if arg2 < ext_call.return_data[0]:
            revert with 'NH{q', 17
        mem[ceil32(return_data.size) + 100] = msg.sender
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = this.address
        if ext_call.return_data[0] >= arg2 - ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + 164] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg2 - ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, arg2 - ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args arg2 - ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require arg1
            if arg1 == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = arg1
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _351 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _357 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _351 + (32 * _357) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _351 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _357:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _573 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _583 = mem[_573]
                require mem[_573] == mem[_573]
                mem[0] = arg1
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _583
                require ext_code.size(arg1)
                call arg1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _583
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _611 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_611] == bool(mem[_611])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _635 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _641 = mem[_635]
                require mem[_635] == mem[_635]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _659 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _663 = mem[_659]
                require mem[_659] == mem[_659]
                require mem[_659 + 32] == mem[_659 + 32]
                require mem[_659 + 64] == mem[_659 + 92 len 4]
                require mem[_659 + 96] == mem[_659 + 124 len 4]
                mem[mem[64] + 4] = _583
                mem[mem[64] + 36] = _641
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _583, _641, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _687 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_687] == mem[_687]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _703 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_703] == mem[_703]
                require mem[_703 + 32] == mem[_703 + 32]
                require mem[_703 + 64] == mem[_703 + 92 len 4]
                require mem[_703 + 96] == mem[_703 + 124 len 4]
                if mem[_703] < _663:
                    revert with 'NH{q', 17
                if mem[_703] - _663 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _739 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _743 = mem[_739]
                require mem[_739] == mem[_739]
                if mem[_739] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _759 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _771 = mem[_759]
                    require mem[_759] == mem[_759]
                    if mem[_759] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _771
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _771
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _795 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_795] == bool(mem[_795])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _743
                    require ext_code.size(arg1)
                    call arg1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _743
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _767 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_767] == bool(mem[_767])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _796 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _804 = mem[_796]
                    require mem[_796] == mem[_796]
                    if mem[_796] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _804
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _804
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _819 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_819] == bool(mem[_819])
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = arg1
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _352 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _358 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _352 + (32 * _358) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _352 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _358:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _574 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _584 = mem[_574]
                require mem[_574] == mem[_574]
                mem[0] = arg1
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _584
                require ext_code.size(arg1)
                call arg1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _584
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _612 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_612] == bool(mem[_612])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _636 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _642 = mem[_636]
                require mem[_636] == mem[_636]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _660 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _664 = mem[_660]
                require mem[_660] == mem[_660]
                require mem[_660 + 32] == mem[_660 + 32]
                require mem[_660 + 64] == mem[_660 + 92 len 4]
                require mem[_660 + 96] == mem[_660 + 124 len 4]
                mem[mem[64] + 4] = _584
                mem[mem[64] + 36] = _642
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _584, _642, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _688 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_688] == mem[_688]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _704 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_704] == mem[_704]
                require mem[_704 + 32] == mem[_704 + 32]
                require mem[_704 + 64] == mem[_704 + 92 len 4]
                require mem[_704 + 96] == mem[_704 + 124 len 4]
                if mem[_704] < _664:
                    revert with 'NH{q', 17
                if mem[_704] - _664 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _740 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _744 = mem[_740]
                require mem[_740] == mem[_740]
                if mem[_740] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _761 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _772 = mem[_761]
                    require mem[_761] == mem[_761]
                    if mem[_761] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _772
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _772
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _797 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_797] == bool(mem[_797])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _744
                    require ext_code.size(arg1)
                    call arg1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _744
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _768 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_768] == bool(mem[_768])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _798 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _806 = mem[_798]
                    require mem[_798] == mem[_798]
                    if mem[_798] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _806
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _806
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _820 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_820] == bool(mem[_820])
        else:
            mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require arg1
            if arg1 == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = arg1
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _353 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _359 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _353 + (32 * _359) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _353 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _359:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _585 = mem[_575]
                require mem[_575] == mem[_575]
                mem[0] = arg1
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _585
                require ext_code.size(arg1)
                call arg1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _585
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _613 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_613] == bool(mem[_613])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _637 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _643 = mem[_637]
                require mem[_637] == mem[_637]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _661 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _665 = mem[_661]
                require mem[_661] == mem[_661]
                require mem[_661 + 32] == mem[_661 + 32]
                require mem[_661 + 64] == mem[_661 + 92 len 4]
                require mem[_661 + 96] == mem[_661 + 124 len 4]
                mem[mem[64] + 4] = _585
                mem[mem[64] + 36] = _643
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _585, _643, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _689 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_689] == mem[_689]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _705 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_705] == mem[_705]
                require mem[_705 + 32] == mem[_705 + 32]
                require mem[_705 + 64] == mem[_705 + 92 len 4]
                require mem[_705 + 96] == mem[_705 + 124 len 4]
                if mem[_705] < _665:
                    revert with 'NH{q', 17
                if mem[_705] - _665 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _741 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _745 = mem[_741]
                require mem[_741] == mem[_741]
                if mem[_741] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _763 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _773 = mem[_763]
                    require mem[_763] == mem[_763]
                    if mem[_763] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _773
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _773
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _799 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_799] == bool(mem[_799])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _745
                    require ext_code.size(arg1)
                    call arg1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _745
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _769 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_769] == bool(mem[_769])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _800 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _808 = mem[_800]
                    require mem[_800] == mem[_800]
                    if mem[_800] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _808
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _808
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _821 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_821] == bool(mem[_821])
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = arg1
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _354 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _360 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _354 + (32 * _360) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _354 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _360:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _576 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _586 = mem[_576]
                require mem[_576] == mem[_576]
                mem[0] = arg1
                mem[32] = 13
                mem[mem[64] + 4] = stor13[address(arg1)]
                mem[mem[64] + 36] = _586
                require ext_code.size(arg1)
                call arg1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[address(arg1)], _586
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _614 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_614] == bool(mem[_614])
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _638 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _644 = mem[_638]
                require mem[_638] == mem[_638]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _662 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _666 = mem[_662]
                require mem[_662] == mem[_662]
                require mem[_662 + 32] == mem[_662 + 32]
                require mem[_662 + 64] == mem[_662 + 92 len 4]
                require mem[_662 + 96] == mem[_662 + 124 len 4]
                mem[mem[64] + 4] = _586
                mem[mem[64] + 36] = _644
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[address(arg1)])
                call stor13[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _586, _644, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _690 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_690] == mem[_690]
                require ext_code.size(stor13[address(arg1)])
                staticcall stor13[address(arg1)].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _706 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_706] == mem[_706]
                require mem[_706 + 32] == mem[_706 + 32]
                require mem[_706 + 64] == mem[_706 + 92 len 4]
                require mem[_706 + 96] == mem[_706 + 124 len 4]
                if mem[_706] < _666:
                    revert with 'NH{q', 17
                if mem[_706] - _666 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _742 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _746 = mem[_742]
                require mem[_742] == mem[_742]
                if mem[_742] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _765 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _774 = mem[_765]
                    require mem[_765] == mem[_765]
                    if mem[_765] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _774
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _774
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _801 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_801] == bool(mem[_801])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _746
                    require ext_code.size(arg1)
                    call arg1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _746
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _770 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_770] == bool(mem[_770])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _802 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _810 = mem[_802]
                    require mem[_802] == mem[_802]
                    if mem[_802] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _810
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _810
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _822 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_822] == bool(mem[_822])
}

function sub_5891fde9(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == arg2
    mem[100] = msg.sender
    require ext_code.size(stor2)
    staticcall stor2.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] >= arg2:
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = this.address
        mem[ceil32(return_data.size) + 164] = arg2
        require ext_code.size(stor2)
        call stor2.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require stor3
        if stor3 == stor3:
            mem[(2 * ceil32(return_data.size)) + 100] = stor6
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor6, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = stor3
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor6)
            call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _139 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _143 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _139 + (32 * _143) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _139 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _143:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[0] = address(arg1)
            mem[32] = 12
            require stor12[address(arg1)]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _379 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _381 = mem[_379]
            require mem[_379] == mem[_379 + 18 len 14]
            _395 = mem[_379 + 32]
            require mem[_379 + 32] == mem[_379 + 50 len 14]
            require mem[_379 + 64] == mem[_379 + 92 len 4]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _411 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _417 = mem[_411]
            require mem[_411] == mem[_411 + 12 len 20]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _443 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_443] == mem[_443 + 12 len 20]
            if address(_417) != address(arg1):
                if mem[_443 + 12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(_417) != stor3:
                    revert with 0, 'bad LP token'
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor3)
                staticcall stor3.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _501 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _515 = mem[_501]
                require mem[_501] == mem[_501]
                if Mask(112, 0, _381) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _381) and mem[_501] > -1 / 1000 * Mask(112, 0, _381):
                    revert with 'NH{q', 17
                if mem[_501] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_501] / 2 > (-1997 * Mask(112, 0, _381)) - 1:
                    revert with 'NH{q', 17
                if mem[_501] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_501] / 2 and mem[_501] / 2 > -1 / 997 * mem[_501] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_501] / 2 * mem[_501] / 2 > (-1000 * Mask(112, 0, _381) * mem[_501]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)):
                    revert with 'NH{q', 18
                if (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) > (-1997 * Mask(112, 0, _381)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) and (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) > -1 / 997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) > (-1000 * Mask(112, 0, _381) * mem[_501]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > (-1997 * Mask(112, 0, _381)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) and (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > -1 / 997 * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > (-1000 * Mask(112, 0, _381) * mem[_501]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * (997 * mem[_501] / 2 * mem[_501] / 2) + (1000 * Mask(112, 0, _381) * mem[_501]) / (1994 * mem[_501] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = (997 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                require ext_code.size(stor3)
                call stor3.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, (997 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _685 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_685] == bool(mem[_685])
                _727 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_727]:
                    revert with 'NH{q', 50
                mem[_727 + 32] = stor3
                if 1 >= mem[_727]:
                    revert with 'NH{q', 50
                mem[_727 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_727 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_727 + 100] = (997 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _515) / (1994 * (997 * _515 / 2 * _515 / 2) + (1000 * Mask(112, 0, _381) * _515) / (1994 * _515 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                mem[_727 + 132] = 0
                mem[_727 + 164] = 160
                mem[_727 + 260] = mem[_727]
                idx = 0
                s = _727 + 32
                t = _727 + 292
                while idx < mem[_727]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_727 + 196] = this.address
                mem[_727 + 228] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _727 + (32 * mem[_727]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _927 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _933 = mem[_927]
                require mem[_927] <= test266151307()
                require _927 + mem[_927] + 31 < _927 + return_data.size
                _939 = mem[_927 + mem[_927]]
                if mem[_927 + mem[_927]] > test266151307():
                    revert with 'NH{q', 65
                if _927 + ceil32(return_data.size) + floor32(mem[_927 + mem[_927]]) + 1 > test266151307() or floor32(mem[_927 + mem[_927]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _927 + ceil32(return_data.size) + floor32(mem[_927 + mem[_927]]) + 1
                mem[_927 + ceil32(return_data.size)] = _939
                require _933 + (32 * _939) + 32 <= return_data.size
                idx = 0
                s = _927 + _933 + 32
                t = _927 + ceil32(return_data.size) + 32
                while idx < _939:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1471 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1489 = mem[_1471]
                require mem[_1471] == mem[_1471]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor3)
                staticcall stor3.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1531 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1549 = mem[_1531]
                require mem[_1531] == mem[_1531]
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = _1489
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, _1489
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1615 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1615] == bool(mem[_1615])
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = _1549
                require ext_code.size(stor3)
                call stor3.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, _1549
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1699 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1699] == bool(mem[_1699])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _1549
                mem[mem[64] + 100] = _1489
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor3, address(arg1), _1549, _1489, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1819 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_1819] == mem[_1819]
                require mem[_1819 + 32] == mem[_1819 + 32]
                require mem[_1819 + 64] == mem[_1819 + 64]
                mem[0] = address(arg1)
                mem[32] = 12
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1885 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1903 = mem[_1885]
                require mem[_1885] == mem[_1885]
                mem[0] = stor12[address(arg1)]
                mem[32] = 13
                mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                mem[mem[64] + 36] = _1903
                require ext_code.size(stor12[address(arg1)])
                call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[stor12[address(arg1)]], _1903
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1975 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1975] == bool(mem[_1975])
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2035 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2041 = mem[_2035]
                require mem[_2035] == mem[_2035]
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2107 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _2113 = mem[_2107]
                require mem[_2107] == mem[_2107]
                require mem[_2107 + 32] == mem[_2107 + 32]
                require mem[_2107 + 64] == mem[_2107 + 92 len 4]
                require mem[_2107 + 96] == mem[_2107 + 124 len 4]
                mem[mem[64] + 4] = _1903
                mem[mem[64] + 36] = _2041
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[stor12[address(arg1)]])
                call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _1903, _2041, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2245 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2245] == mem[_2245]
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2281 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_2281] == mem[_2281]
                require mem[_2281 + 32] == mem[_2281 + 32]
                require mem[_2281 + 64] == mem[_2281 + 92 len 4]
                require mem[_2281 + 96] == mem[_2281 + 124 len 4]
                if mem[_2281] < _2113:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_2281] - _2113
            else:
                if mem[_443 + 12 len 20] == stor3:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _494 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _502 = mem[_494]
                    require mem[_494] == mem[_494]
                    if Mask(112, 0, _395) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _395) and mem[_494] > -1 / 1000 * Mask(112, 0, _395):
                        revert with 'NH{q', 17
                    if mem[_494] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_494] / 2 > (-1997 * Mask(112, 0, _395)) - 1:
                        revert with 'NH{q', 17
                    if mem[_494] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_494] / 2 and mem[_494] / 2 > -1 / 997 * mem[_494] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_494] / 2 * mem[_494] / 2 > (-1000 * Mask(112, 0, _395) * mem[_494]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)):
                        revert with 'NH{q', 18
                    if (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) > (-1997 * Mask(112, 0, _395)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) and (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) > -1 / 997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) > (-1000 * Mask(112, 0, _395) * mem[_494]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) > (-1997 * Mask(112, 0, _395)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) and (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) > -1 / 997 * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) > (-1000 * Mask(112, 0, _395) * mem[_494]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395)) * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * (997 * mem[_494] / 2 * mem[_494] / 2) + (1000 * Mask(112, 0, _395) * mem[_494]) / (1994 * mem[_494] / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _679 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_679] == bool(mem[_679])
                    _719 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_719]:
                        revert with 'NH{q', 50
                    mem[_719 + 32] = stor3
                    if 1 >= mem[_719]:
                        revert with 'NH{q', 50
                    mem[_719 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_719 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_719 + 100] = (997 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395)) * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395)) * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1000 * Mask(112, 0, _395) * _502) / (1994 * (997 * _502 / 2 * _502 / 2) + (1000 * Mask(112, 0, _395) * _502) / (1994 * _502 / 2) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))) + (1997 * Mask(112, 0, _395))
                    mem[_719 + 132] = 0
                    mem[_719 + 164] = 160
                    mem[_719 + 260] = mem[_719]
                    idx = 0
                    s = _719 + 32
                    t = _719 + 292
                    while idx < mem[_719]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_719 + 196] = this.address
                    mem[_719 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _719 + (32 * mem[_719]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _929 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _935 = mem[_929]
                    require mem[_929] <= test266151307()
                    require _929 + mem[_929] + 31 < _929 + return_data.size
                    _941 = mem[_929 + mem[_929]]
                    if mem[_929 + mem[_929]] > test266151307():
                        revert with 'NH{q', 65
                    if _929 + ceil32(return_data.size) + floor32(mem[_929 + mem[_929]]) + 1 > test266151307() or floor32(mem[_929 + mem[_929]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _929 + ceil32(return_data.size) + floor32(mem[_929 + mem[_929]]) + 1
                    mem[_929 + ceil32(return_data.size)] = _941
                    require _935 + (32 * _941) + 32 <= return_data.size
                    idx = 0
                    s = _929 + _935 + 32
                    t = _929 + ceil32(return_data.size) + 32
                    while idx < _941:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1473 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1491 = mem[_1473]
                    require mem[_1473] == mem[_1473]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1533 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1551 = mem[_1533]
                    require mem[_1533] == mem[_1533]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1491
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1491
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1617 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1617] == bool(mem[_1617])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1551
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1551
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1701 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1701] == bool(mem[_1701])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1551
                    mem[mem[64] + 100] = _1491
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _1551, _1491, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1821 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1821] == mem[_1821]
                    require mem[_1821 + 32] == mem[_1821 + 32]
                    require mem[_1821 + 64] == mem[_1821 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1887 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1905 = mem[_1887]
                    require mem[_1887] == mem[_1887]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _1905
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _1905
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1977 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1977] == bool(mem[_1977])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2037 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2043 = mem[_2037]
                    require mem[_2037] == mem[_2037]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2109 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2115 = mem[_2109]
                    require mem[_2109] == mem[_2109]
                    require mem[_2109 + 32] == mem[_2109 + 32]
                    require mem[_2109 + 64] == mem[_2109 + 92 len 4]
                    require mem[_2109 + 96] == mem[_2109 + 124 len 4]
                    mem[mem[64] + 4] = _1905
                    mem[mem[64] + 36] = _2043
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1905, _2043, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2247 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2247] == mem[_2247]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2283 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2283] == mem[_2283]
                    require mem[_2283 + 32] == mem[_2283 + 32]
                    require mem[_2283 + 64] == mem[_2283 + 92 len 4]
                    require mem[_2283 + 96] == mem[_2283 + 124 len 4]
                    if mem[_2283] < _2115:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2283] - _2115
                else:
                    if mem[_443 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_417) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _505 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _517 = mem[_505]
                    require mem[_505] == mem[_505]
                    if Mask(112, 0, _381) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _381) and mem[_505] > -1 / 1000 * Mask(112, 0, _381):
                        revert with 'NH{q', 17
                    if mem[_505] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_505] / 2 > (-1997 * Mask(112, 0, _381)) - 1:
                        revert with 'NH{q', 17
                    if mem[_505] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_505] / 2 and mem[_505] / 2 > -1 / 997 * mem[_505] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_505] / 2 * mem[_505] / 2 > (-1000 * Mask(112, 0, _381) * mem[_505]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)):
                        revert with 'NH{q', 18
                    if (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) > (-1997 * Mask(112, 0, _381)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) and (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) > -1 / 997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) > (-1000 * Mask(112, 0, _381) * mem[_505]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > (-1997 * Mask(112, 0, _381)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) and (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > -1 / 997 * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) > (-1000 * Mask(112, 0, _381) * mem[_505]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381)) * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * (997 * mem[_505] / 2 * mem[_505] / 2) + (1000 * Mask(112, 0, _381) * mem[_505]) / (1994 * mem[_505] / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _689 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_689] == bool(mem[_689])
                    _731 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_731]:
                        revert with 'NH{q', 50
                    mem[_731 + 32] = stor3
                    if 1 >= mem[_731]:
                        revert with 'NH{q', 50
                    mem[_731 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_731 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_731 + 100] = (997 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381)) * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381)) * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1000 * Mask(112, 0, _381) * _517) / (1994 * (997 * _517 / 2 * _517 / 2) + (1000 * Mask(112, 0, _381) * _517) / (1994 * _517 / 2) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))) + (1997 * Mask(112, 0, _381))
                    mem[_731 + 132] = 0
                    mem[_731 + 164] = 160
                    mem[_731 + 260] = mem[_731]
                    idx = 0
                    s = _731 + 32
                    t = _731 + 292
                    while idx < mem[_731]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_731 + 196] = this.address
                    mem[_731 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _731 + (32 * mem[_731]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _928 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _934 = mem[_928]
                    require mem[_928] <= test266151307()
                    require _928 + mem[_928] + 31 < _928 + return_data.size
                    _940 = mem[_928 + mem[_928]]
                    if mem[_928 + mem[_928]] > test266151307():
                        revert with 'NH{q', 65
                    if _928 + ceil32(return_data.size) + floor32(mem[_928 + mem[_928]]) + 1 > test266151307() or floor32(mem[_928 + mem[_928]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _928 + ceil32(return_data.size) + floor32(mem[_928 + mem[_928]]) + 1
                    mem[_928 + ceil32(return_data.size)] = _940
                    require _934 + (32 * _940) + 32 <= return_data.size
                    idx = 0
                    s = _928 + _934 + 32
                    t = _928 + ceil32(return_data.size) + 32
                    while idx < _940:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1472 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1490 = mem[_1472]
                    require mem[_1472] == mem[_1472]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1532 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1550 = mem[_1532]
                    require mem[_1532] == mem[_1532]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1490
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1490
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1616 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1616] == bool(mem[_1616])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1550
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1550
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1700 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1700] == bool(mem[_1700])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1550
                    mem[mem[64] + 100] = _1490
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _1550, _1490, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1820] == mem[_1820]
                    require mem[_1820 + 32] == mem[_1820 + 32]
                    require mem[_1820 + 64] == mem[_1820 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1886 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1904 = mem[_1886]
                    require mem[_1886] == mem[_1886]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _1904
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _1904
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1976 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1976] == bool(mem[_1976])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2036 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2042 = mem[_2036]
                    require mem[_2036] == mem[_2036]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2108 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2114 = mem[_2108]
                    require mem[_2108] == mem[_2108]
                    require mem[_2108 + 32] == mem[_2108 + 32]
                    require mem[_2108 + 64] == mem[_2108 + 92 len 4]
                    require mem[_2108 + 96] == mem[_2108 + 124 len 4]
                    mem[mem[64] + 4] = _1904
                    mem[mem[64] + 36] = _2042
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1904, _2042, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2246 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2246] == mem[_2246]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2282 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2282] == mem[_2282]
                    require mem[_2282 + 32] == mem[_2282 + 32]
                    require mem[_2282 + 64] == mem[_2282 + 92 len 4]
                    require mem[_2282 + 96] == mem[_2282 + 124 len 4]
                    if mem[_2282] < _2114:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2282] - _2114
        else:
            mem[(2 * ceil32(return_data.size)) + 100] = stor5
            mem[(2 * ceil32(return_data.size)) + 132] = arg2
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor5, arg2
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = stor2
            mem[(4 * ceil32(return_data.size)) + 160] = stor3
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(stor5)
            call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _140 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _144 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (6 * ceil32(return_data.size)) + floor32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require _140 + (32 * _144) + 32 <= return_data.size
            idx = 0
            s = (4 * ceil32(return_data.size)) + _140 + 224
            t = (6 * ceil32(return_data.size)) + 224
            while idx < _144:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[0] = address(arg1)
            mem[32] = 12
            require stor12[address(arg1)]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _380 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _382 = mem[_380]
            require mem[_380] == mem[_380 + 18 len 14]
            _396 = mem[_380 + 32]
            require mem[_380 + 32] == mem[_380 + 50 len 14]
            require mem[_380 + 64] == mem[_380 + 92 len 4]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _412 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _418 = mem[_412]
            require mem[_412] == mem[_412 + 12 len 20]
            require ext_code.size(stor12[address(arg1)])
            staticcall stor12[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _444 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_444] == mem[_444 + 12 len 20]
            if address(_418) != address(arg1):
                if mem[_444 + 12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(_418) != stor3:
                    revert with 0, 'bad LP token'
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor3)
                staticcall stor3.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _503 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _516 = mem[_503]
                require mem[_503] == mem[_503]
                if Mask(112, 0, _382) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _382) and mem[_503] > -1 / 1000 * Mask(112, 0, _382):
                    revert with 'NH{q', 17
                if mem[_503] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_503] / 2 > (-1997 * Mask(112, 0, _382)) - 1:
                    revert with 'NH{q', 17
                if mem[_503] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_503] / 2 and mem[_503] / 2 > -1 / 997 * mem[_503] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_503] / 2 * mem[_503] / 2 > (-1000 * Mask(112, 0, _382) * mem[_503]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)):
                    revert with 'NH{q', 18
                if (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) > (-1997 * Mask(112, 0, _382)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) and (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) > -1 / 997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) > (-1000 * Mask(112, 0, _382) * mem[_503]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > (-1997 * Mask(112, 0, _382)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) and (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > -1 / 997 * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > (-1000 * Mask(112, 0, _382) * mem[_503]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * (997 * mem[_503] / 2 * mem[_503] / 2) + (1000 * Mask(112, 0, _382) * mem[_503]) / (1994 * mem[_503] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = (997 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                require ext_code.size(stor3)
                call stor3.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, (997 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _687 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_687] == bool(mem[_687])
                _729 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_729]:
                    revert with 'NH{q', 50
                mem[_729 + 32] = stor3
                if 1 >= mem[_729]:
                    revert with 'NH{q', 50
                mem[_729 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_729 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_729 + 100] = (997 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _516) / (1994 * (997 * _516 / 2 * _516 / 2) + (1000 * Mask(112, 0, _382) * _516) / (1994 * _516 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                mem[_729 + 132] = 0
                mem[_729 + 164] = 160
                mem[_729 + 260] = mem[_729]
                idx = 0
                s = _729 + 32
                t = _729 + 292
                while idx < mem[_729]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_729 + 196] = this.address
                mem[_729 + 228] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _729 + (32 * mem[_729]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _930 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _936 = mem[_930]
                require mem[_930] <= test266151307()
                require _930 + mem[_930] + 31 < _930 + return_data.size
                _942 = mem[_930 + mem[_930]]
                if mem[_930 + mem[_930]] > test266151307():
                    revert with 'NH{q', 65
                if _930 + ceil32(return_data.size) + floor32(mem[_930 + mem[_930]]) + 1 > test266151307() or floor32(mem[_930 + mem[_930]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _930 + ceil32(return_data.size) + floor32(mem[_930 + mem[_930]]) + 1
                mem[_930 + ceil32(return_data.size)] = _942
                require _936 + (32 * _942) + 32 <= return_data.size
                idx = 0
                s = _930 + _936 + 32
                t = _930 + ceil32(return_data.size) + 32
                while idx < _942:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1474 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1492 = mem[_1474]
                require mem[_1474] == mem[_1474]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor3)
                staticcall stor3.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1534 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1552 = mem[_1534]
                require mem[_1534] == mem[_1534]
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = _1492
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, _1492
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1618 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1618] == bool(mem[_1618])
                mem[mem[64] + 4] = stor6
                mem[mem[64] + 36] = _1552
                require ext_code.size(stor3)
                call stor3.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, _1552
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1702 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1702] == bool(mem[_1702])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _1552
                mem[mem[64] + 100] = _1492
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor3, address(arg1), _1552, _1492, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1822 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_1822] == mem[_1822]
                require mem[_1822 + 32] == mem[_1822 + 32]
                require mem[_1822 + 64] == mem[_1822 + 64]
                mem[0] = address(arg1)
                mem[32] = 12
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1888 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1906 = mem[_1888]
                require mem[_1888] == mem[_1888]
                mem[0] = stor12[address(arg1)]
                mem[32] = 13
                mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                mem[mem[64] + 36] = _1906
                require ext_code.size(stor12[address(arg1)])
                call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor13[stor12[address(arg1)]], _1906
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1978 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1978] == bool(mem[_1978])
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2038 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2044 = mem[_2038]
                require mem[_2038] == mem[_2038]
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2110 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _2116 = mem[_2110]
                require mem[_2110] == mem[_2110]
                require mem[_2110 + 32] == mem[_2110 + 32]
                require mem[_2110 + 64] == mem[_2110 + 92 len 4]
                require mem[_2110 + 96] == mem[_2110 + 124 len 4]
                mem[mem[64] + 4] = _1906
                mem[mem[64] + 36] = _2044
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor13[stor12[address(arg1)]])
                call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _1906, _2044, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2248 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2248] == mem[_2248]
                require ext_code.size(stor13[stor12[address(arg1)]])
                staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2284 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_2284] == mem[_2284]
                require mem[_2284 + 32] == mem[_2284 + 32]
                require mem[_2284 + 64] == mem[_2284 + 92 len 4]
                require mem[_2284 + 96] == mem[_2284 + 124 len 4]
                if mem[_2284] < _2116:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_2284] - _2116
            else:
                if mem[_444 + 12 len 20] == stor3:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _504 = mem[_496]
                    require mem[_496] == mem[_496]
                    if Mask(112, 0, _396) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _396) and mem[_496] > -1 / 1000 * Mask(112, 0, _396):
                        revert with 'NH{q', 17
                    if mem[_496] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_496] / 2 > (-1997 * Mask(112, 0, _396)) - 1:
                        revert with 'NH{q', 17
                    if mem[_496] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_496] / 2 and mem[_496] / 2 > -1 / 997 * mem[_496] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_496] / 2 * mem[_496] / 2 > (-1000 * Mask(112, 0, _396) * mem[_496]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)):
                        revert with 'NH{q', 18
                    if (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) > (-1997 * Mask(112, 0, _396)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) and (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) > -1 / 997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) > (-1000 * Mask(112, 0, _396) * mem[_496]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) > (-1997 * Mask(112, 0, _396)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) and (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) > -1 / 997 * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) > (-1000 * Mask(112, 0, _396) * mem[_496]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396)) * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * (997 * mem[_496] / 2 * mem[_496] / 2) + (1000 * Mask(112, 0, _396) * mem[_496]) / (1994 * mem[_496] / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _680 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_680] == bool(mem[_680])
                    _720 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_720]:
                        revert with 'NH{q', 50
                    mem[_720 + 32] = stor3
                    if 1 >= mem[_720]:
                        revert with 'NH{q', 50
                    mem[_720 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_720 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_720 + 100] = (997 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396)) * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396)) * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1000 * Mask(112, 0, _396) * _504) / (1994 * (997 * _504 / 2 * _504 / 2) + (1000 * Mask(112, 0, _396) * _504) / (1994 * _504 / 2) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))) + (1997 * Mask(112, 0, _396))
                    mem[_720 + 132] = 0
                    mem[_720 + 164] = 160
                    mem[_720 + 260] = mem[_720]
                    idx = 0
                    s = _720 + 32
                    t = _720 + 292
                    while idx < mem[_720]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_720 + 196] = this.address
                    mem[_720 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _720 + (32 * mem[_720]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _932 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _938 = mem[_932]
                    require mem[_932] <= test266151307()
                    require _932 + mem[_932] + 31 < _932 + return_data.size
                    _944 = mem[_932 + mem[_932]]
                    if mem[_932 + mem[_932]] > test266151307():
                        revert with 'NH{q', 65
                    if _932 + ceil32(return_data.size) + floor32(mem[_932 + mem[_932]]) + 1 > test266151307() or floor32(mem[_932 + mem[_932]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _932 + ceil32(return_data.size) + floor32(mem[_932 + mem[_932]]) + 1
                    mem[_932 + ceil32(return_data.size)] = _944
                    require _938 + (32 * _944) + 32 <= return_data.size
                    idx = 0
                    s = _932 + _938 + 32
                    t = _932 + ceil32(return_data.size) + 32
                    while idx < _944:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1476 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1494 = mem[_1476]
                    require mem[_1476] == mem[_1476]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1536 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1554 = mem[_1536]
                    require mem[_1536] == mem[_1536]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1494
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1494
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1620 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1620] == bool(mem[_1620])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1554
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1554
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1704 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1704] == bool(mem[_1704])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1554
                    mem[mem[64] + 100] = _1494
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _1554, _1494, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1824 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1824] == mem[_1824]
                    require mem[_1824 + 32] == mem[_1824 + 32]
                    require mem[_1824 + 64] == mem[_1824 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1890 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1908 = mem[_1890]
                    require mem[_1890] == mem[_1890]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _1908
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _1908
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1980 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1980] == bool(mem[_1980])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2040 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2046 = mem[_2040]
                    require mem[_2040] == mem[_2040]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2112 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2118 = mem[_2112]
                    require mem[_2112] == mem[_2112]
                    require mem[_2112 + 32] == mem[_2112 + 32]
                    require mem[_2112 + 64] == mem[_2112 + 92 len 4]
                    require mem[_2112 + 96] == mem[_2112 + 124 len 4]
                    mem[mem[64] + 4] = _1908
                    mem[mem[64] + 36] = _2046
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1908, _2046, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2250 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2250] == mem[_2250]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2286 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2286] == mem[_2286]
                    require mem[_2286 + 32] == mem[_2286 + 32]
                    require mem[_2286 + 64] == mem[_2286 + 92 len 4]
                    require mem[_2286 + 96] == mem[_2286 + 124 len 4]
                    if mem[_2286] < _2118:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2286] - _2118
                else:
                    if mem[_444 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_418) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _506 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _518 = mem[_506]
                    require mem[_506] == mem[_506]
                    if Mask(112, 0, _382) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _382) and mem[_506] > -1 / 1000 * Mask(112, 0, _382):
                        revert with 'NH{q', 17
                    if mem[_506] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_506] / 2 > (-1997 * Mask(112, 0, _382)) - 1:
                        revert with 'NH{q', 17
                    if mem[_506] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_506] / 2 and mem[_506] / 2 > -1 / 997 * mem[_506] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_506] / 2 * mem[_506] / 2 > (-1000 * Mask(112, 0, _382) * mem[_506]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)):
                        revert with 'NH{q', 18
                    if (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) > (-1997 * Mask(112, 0, _382)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) and (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) > -1 / 997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) > (-1000 * Mask(112, 0, _382) * mem[_506]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > (-1997 * Mask(112, 0, _382)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) and (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > -1 / 997 * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) > (-1000 * Mask(112, 0, _382) * mem[_506]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382)) * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * (997 * mem[_506] / 2 * mem[_506] / 2) + (1000 * Mask(112, 0, _382) * mem[_506]) / (1994 * mem[_506] / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _690 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_690] == bool(mem[_690])
                    _732 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_732]:
                        revert with 'NH{q', 50
                    mem[_732 + 32] = stor3
                    if 1 >= mem[_732]:
                        revert with 'NH{q', 50
                    mem[_732 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_732 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_732 + 100] = (997 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382)) * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382)) * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1000 * Mask(112, 0, _382) * _518) / (1994 * (997 * _518 / 2 * _518 / 2) + (1000 * Mask(112, 0, _382) * _518) / (1994 * _518 / 2) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))) + (1997 * Mask(112, 0, _382))
                    mem[_732 + 132] = 0
                    mem[_732 + 164] = 160
                    mem[_732 + 260] = mem[_732]
                    idx = 0
                    s = _732 + 32
                    t = _732 + 292
                    while idx < mem[_732]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_732 + 196] = this.address
                    mem[_732 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _732 + (32 * mem[_732]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _931 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _937 = mem[_931]
                    require mem[_931] <= test266151307()
                    require _931 + mem[_931] + 31 < _931 + return_data.size
                    _943 = mem[_931 + mem[_931]]
                    if mem[_931 + mem[_931]] > test266151307():
                        revert with 'NH{q', 65
                    if _931 + ceil32(return_data.size) + floor32(mem[_931 + mem[_931]]) + 1 > test266151307() or floor32(mem[_931 + mem[_931]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _931 + ceil32(return_data.size) + floor32(mem[_931 + mem[_931]]) + 1
                    mem[_931 + ceil32(return_data.size)] = _943
                    require _937 + (32 * _943) + 32 <= return_data.size
                    idx = 0
                    s = _931 + _937 + 32
                    t = _931 + ceil32(return_data.size) + 32
                    while idx < _943:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1475 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1493 = mem[_1475]
                    require mem[_1475] == mem[_1475]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1535 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1553 = mem[_1535]
                    require mem[_1535] == mem[_1535]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1493
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1493
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1619 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1619] == bool(mem[_1619])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1553
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1553
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1703 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1703] == bool(mem[_1703])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1553
                    mem[mem[64] + 100] = _1493
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _1553, _1493, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1823 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1823] == mem[_1823]
                    require mem[_1823 + 32] == mem[_1823 + 32]
                    require mem[_1823 + 64] == mem[_1823 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1889 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1907 = mem[_1889]
                    require mem[_1889] == mem[_1889]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _1907
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _1907
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1979 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1979] == bool(mem[_1979])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2039 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2045 = mem[_2039]
                    require mem[_2039] == mem[_2039]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2111 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2117 = mem[_2111]
                    require mem[_2111] == mem[_2111]
                    require mem[_2111 + 32] == mem[_2111 + 32]
                    require mem[_2111 + 64] == mem[_2111 + 92 len 4]
                    require mem[_2111 + 96] == mem[_2111 + 124 len 4]
                    mem[mem[64] + 4] = _1907
                    mem[mem[64] + 36] = _2045
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1907, _2045, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2249 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2249] == mem[_2249]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2285 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2285] == mem[_2285]
                    require mem[_2285 + 32] == mem[_2285 + 32]
                    require mem[_2285 + 64] == mem[_2285 + 92 len 4]
                    require mem[_2285 + 96] == mem[_2285 + 124 len 4]
                    if mem[_2285] < _2117:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2285] - _2117
    else:
        if arg2 < ext_call.return_data[0]:
            revert with 'NH{q', 17
        mem[ceil32(return_data.size) + 100] = msg.sender
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = this.address
        if ext_call.return_data[0] >= arg2 - ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + 164] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg2 - ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, arg2 - ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args arg2 - ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require stor3
            if stor3 == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = stor3
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _391 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _397 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _391 + (32 * _397) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _391 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _397:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[0] = address(arg1)
                mem[32] = 12
                require stor12[address(arg1)]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _623 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _627 = mem[_623]
                require mem[_623] == mem[_623 + 18 len 14]
                _631 = mem[_623 + 32]
                require mem[_623 + 32] == mem[_623 + 50 len 14]
                require mem[_623 + 64] == mem[_623 + 92 len 4]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _647 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _651 = mem[_647]
                require mem[_647] == mem[_647 + 12 len 20]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0xd21220a7 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _669 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_669] == mem[_669 + 12 len 20]
                if address(_651) != address(arg1):
                    if mem[_669 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_651) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _773 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _787 = mem[_773]
                    require mem[_773] == mem[_773]
                    if Mask(112, 0, _627) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _627) and mem[_773] > -1 / 1000 * Mask(112, 0, _627):
                        revert with 'NH{q', 17
                    if mem[_773] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_773] / 2 > (-1997 * Mask(112, 0, _627)) - 1:
                        revert with 'NH{q', 17
                    if mem[_773] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_773] / 2 and mem[_773] / 2 > -1 / 997 * mem[_773] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_773] / 2 * mem[_773] / 2 > (-1000 * Mask(112, 0, _627) * mem[_773]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)):
                        revert with 'NH{q', 18
                    if (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) > (-1997 * Mask(112, 0, _627)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) and (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) > -1 / 997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) > (-1000 * Mask(112, 0, _627) * mem[_773]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > (-1997 * Mask(112, 0, _627)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) and (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > -1 / 997 * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > (-1000 * Mask(112, 0, _627) * mem[_773]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * (997 * mem[_773] / 2 * mem[_773] / 2) + (1000 * Mask(112, 0, _627) * mem[_773]) / (1994 * mem[_773] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1009 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1009] == bool(mem[_1009])
                    _1055 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1055]:
                        revert with 'NH{q', 50
                    mem[_1055 + 32] = stor3
                    if 1 >= mem[_1055]:
                        revert with 'NH{q', 50
                    mem[_1055 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_1055 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1055 + 100] = (997 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _787) / (1994 * (997 * _787 / 2 * _787 / 2) + (1000 * Mask(112, 0, _627) * _787) / (1994 * _787 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                    mem[_1055 + 132] = 0
                    mem[_1055 + 164] = 160
                    mem[_1055 + 260] = mem[_1055]
                    idx = 0
                    s = _1055 + 32
                    t = _1055 + 292
                    while idx < mem[_1055]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1055 + 196] = this.address
                    mem[_1055 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1055 + (32 * mem[_1055]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1459 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1477 = mem[_1459]
                    require mem[_1459] <= test266151307()
                    require _1459 + mem[_1459] + 31 < _1459 + return_data.size
                    _1495 = mem[_1459 + mem[_1459]]
                    if mem[_1459 + mem[_1459]] > test266151307():
                        revert with 'NH{q', 65
                    if _1459 + ceil32(return_data.size) + floor32(mem[_1459 + mem[_1459]]) + 1 > test266151307() or floor32(mem[_1459 + mem[_1459]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _1459 + ceil32(return_data.size) + floor32(mem[_1459 + mem[_1459]]) + 1
                    mem[_1459 + ceil32(return_data.size)] = _1495
                    require _1477 + (32 * _1495) + 32 <= return_data.size
                    idx = 0
                    s = _1459 + _1477 + 32
                    t = _1459 + ceil32(return_data.size) + 32
                    while idx < _1495:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1999 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2023 = mem[_1999]
                    require mem[_1999] == mem[_1999]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2077 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2095 = mem[_2077]
                    require mem[_2077] == mem[_2077]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2023
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2023
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2155] == bool(mem[_2155])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2095
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2095
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2215 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2215] == bool(mem[_2215])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _2095
                    mem[mem[64] + 100] = _2023
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _2095, _2023, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2323 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_2323] == mem[_2323]
                    require mem[_2323 + 32] == mem[_2323 + 32]
                    require mem[_2323 + 64] == mem[_2323 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2419 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2431 = mem[_2419]
                    require mem[_2419] == mem[_2419]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _2431
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _2431
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2479 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2479] == bool(mem[_2479])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2527 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2539 = mem[_2527]
                    require mem[_2527] == mem[_2527]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2575 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2587 = mem[_2575]
                    require mem[_2575] == mem[_2575]
                    require mem[_2575 + 32] == mem[_2575 + 32]
                    require mem[_2575 + 64] == mem[_2575 + 92 len 4]
                    require mem[_2575 + 96] == mem[_2575 + 124 len 4]
                    mem[mem[64] + 4] = _2431
                    mem[mem[64] + 36] = _2539
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _2431, _2539, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2659 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2659] == mem[_2659]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2707 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2707] == mem[_2707]
                    require mem[_2707 + 32] == mem[_2707 + 32]
                    require mem[_2707 + 64] == mem[_2707 + 92 len 4]
                    require mem[_2707 + 96] == mem[_2707 + 124 len 4]
                    if mem[_2707] < _2587:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2707] - _2587
                else:
                    if mem[_669 + 12 len 20] == stor3:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _756 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _774 = mem[_756]
                        require mem[_756] == mem[_756]
                        if Mask(112, 0, _631) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _631) and mem[_756] > -1 / 1000 * Mask(112, 0, _631):
                            revert with 'NH{q', 17
                        if mem[_756] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_756] / 2 > (-1997 * Mask(112, 0, _631)) - 1:
                            revert with 'NH{q', 17
                        if mem[_756] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_756] / 2 and mem[_756] / 2 > -1 / 997 * mem[_756] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_756] / 2 * mem[_756] / 2 > (-1000 * Mask(112, 0, _631) * mem[_756]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)):
                            revert with 'NH{q', 18
                        if (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) > (-1997 * Mask(112, 0, _631)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) and (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) > -1 / 997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) > (-1000 * Mask(112, 0, _631) * mem[_756]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) > (-1997 * Mask(112, 0, _631)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) and (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) > -1 / 997 * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) > (-1000 * Mask(112, 0, _631) * mem[_756]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631)) * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * (997 * mem[_756] / 2 * mem[_756] / 2) + (1000 * Mask(112, 0, _631) * mem[_756]) / (1994 * mem[_756] / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _997 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_997] == bool(mem[_997])
                        _1035 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1035]:
                            revert with 'NH{q', 50
                        mem[_1035 + 32] = stor3
                        if 1 >= mem[_1035]:
                            revert with 'NH{q', 50
                        mem[_1035 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1035 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1035 + 100] = (997 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631)) * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631)) * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1000 * Mask(112, 0, _631) * _774) / (1994 * (997 * _774 / 2 * _774 / 2) + (1000 * Mask(112, 0, _631) * _774) / (1994 * _774 / 2) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))) + (1997 * Mask(112, 0, _631))
                        mem[_1035 + 132] = 0
                        mem[_1035 + 164] = 160
                        mem[_1035 + 260] = mem[_1035]
                        idx = 0
                        s = _1035 + 32
                        t = _1035 + 292
                        while idx < mem[_1035]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1035 + 196] = this.address
                        mem[_1035 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1035 + (32 * mem[_1035]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1461 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1479 = mem[_1461]
                        require mem[_1461] <= test266151307()
                        require _1461 + mem[_1461] + 31 < _1461 + return_data.size
                        _1497 = mem[_1461 + mem[_1461]]
                        if mem[_1461 + mem[_1461]] > test266151307():
                            revert with 'NH{q', 65
                        if _1461 + ceil32(return_data.size) + floor32(mem[_1461 + mem[_1461]]) + 1 > test266151307() or floor32(mem[_1461 + mem[_1461]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1461 + ceil32(return_data.size) + floor32(mem[_1461 + mem[_1461]]) + 1
                        mem[_1461 + ceil32(return_data.size)] = _1497
                        require _1479 + (32 * _1497) + 32 <= return_data.size
                        idx = 0
                        s = _1461 + _1479 + 32
                        t = _1461 + ceil32(return_data.size) + 32
                        while idx < _1497:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2001 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2025 = mem[_2001]
                        require mem[_2001] == mem[_2001]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2079 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2097 = mem[_2079]
                        require mem[_2079] == mem[_2079]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2025
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2025
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2157 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2157] == bool(mem[_2157])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2097
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2097
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2217 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2217] == bool(mem[_2217])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2097
                        mem[mem[64] + 100] = _2025
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2097, _2025, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2325 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2325] == mem[_2325]
                        require mem[_2325 + 32] == mem[_2325 + 32]
                        require mem[_2325 + 64] == mem[_2325 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2421 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2433 = mem[_2421]
                        require mem[_2421] == mem[_2421]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2433
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2433
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2481 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2481] == bool(mem[_2481])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2529 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2541 = mem[_2529]
                        require mem[_2529] == mem[_2529]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2577 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2589 = mem[_2577]
                        require mem[_2577] == mem[_2577]
                        require mem[_2577 + 32] == mem[_2577 + 32]
                        require mem[_2577 + 64] == mem[_2577 + 92 len 4]
                        require mem[_2577 + 96] == mem[_2577 + 124 len 4]
                        mem[mem[64] + 4] = _2433
                        mem[mem[64] + 36] = _2541
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2433, _2541, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2661 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2661] == mem[_2661]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2709 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2709] == mem[_2709]
                        require mem[_2709 + 32] == mem[_2709 + 32]
                        require mem[_2709 + 64] == mem[_2709 + 92 len 4]
                        require mem[_2709 + 96] == mem[_2709 + 124 len 4]
                        if mem[_2709] < _2589:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2709] - _2589
                    else:
                        if mem[_669 + 12 len 20] != address(arg1):
                            revert with 0, 'bad LP token'
                        if address(_651) != stor3:
                            revert with 0, 'bad LP token'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _781 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _791 = mem[_781]
                        require mem[_781] == mem[_781]
                        if Mask(112, 0, _627) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _627) and mem[_781] > -1 / 1000 * Mask(112, 0, _627):
                            revert with 'NH{q', 17
                        if mem[_781] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_781] / 2 > (-1997 * Mask(112, 0, _627)) - 1:
                            revert with 'NH{q', 17
                        if mem[_781] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_781] / 2 and mem[_781] / 2 > -1 / 997 * mem[_781] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_781] / 2 * mem[_781] / 2 > (-1000 * Mask(112, 0, _627) * mem[_781]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)):
                            revert with 'NH{q', 18
                        if (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) > (-1997 * Mask(112, 0, _627)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) and (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) > -1 / 997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) > (-1000 * Mask(112, 0, _627) * mem[_781]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > (-1997 * Mask(112, 0, _627)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) and (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > -1 / 997 * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) > (-1000 * Mask(112, 0, _627) * mem[_781]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627)) * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * (997 * mem[_781] / 2 * mem[_781] / 2) + (1000 * Mask(112, 0, _627) * mem[_781]) / (1994 * mem[_781] / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1023 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1023] == bool(mem[_1023])
                        _1063 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1063]:
                            revert with 'NH{q', 50
                        mem[_1063 + 32] = stor3
                        if 1 >= mem[_1063]:
                            revert with 'NH{q', 50
                        mem[_1063 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1063 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1063 + 100] = (997 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627)) * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627)) * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1000 * Mask(112, 0, _627) * _791) / (1994 * (997 * _791 / 2 * _791 / 2) + (1000 * Mask(112, 0, _627) * _791) / (1994 * _791 / 2) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))) + (1997 * Mask(112, 0, _627))
                        mem[_1063 + 132] = 0
                        mem[_1063 + 164] = 160
                        mem[_1063 + 260] = mem[_1063]
                        idx = 0
                        s = _1063 + 32
                        t = _1063 + 292
                        while idx < mem[_1063]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1063 + 196] = this.address
                        mem[_1063 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1063 + (32 * mem[_1063]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1460 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1478 = mem[_1460]
                        require mem[_1460] <= test266151307()
                        require _1460 + mem[_1460] + 31 < _1460 + return_data.size
                        _1496 = mem[_1460 + mem[_1460]]
                        if mem[_1460 + mem[_1460]] > test266151307():
                            revert with 'NH{q', 65
                        if _1460 + ceil32(return_data.size) + floor32(mem[_1460 + mem[_1460]]) + 1 > test266151307() or floor32(mem[_1460 + mem[_1460]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1460 + ceil32(return_data.size) + floor32(mem[_1460 + mem[_1460]]) + 1
                        mem[_1460 + ceil32(return_data.size)] = _1496
                        require _1478 + (32 * _1496) + 32 <= return_data.size
                        idx = 0
                        s = _1460 + _1478 + 32
                        t = _1460 + ceil32(return_data.size) + 32
                        while idx < _1496:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2000 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2024 = mem[_2000]
                        require mem[_2000] == mem[_2000]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2078 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2096 = mem[_2078]
                        require mem[_2078] == mem[_2078]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2024
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2024
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2156] == bool(mem[_2156])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2096
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2096
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2216 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2216] == bool(mem[_2216])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2096
                        mem[mem[64] + 100] = _2024
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2096, _2024, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2324 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2324] == mem[_2324]
                        require mem[_2324 + 32] == mem[_2324 + 32]
                        require mem[_2324 + 64] == mem[_2324 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2420 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2432 = mem[_2420]
                        require mem[_2420] == mem[_2420]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2432
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2432
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2480 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2480] == bool(mem[_2480])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2528 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2540 = mem[_2528]
                        require mem[_2528] == mem[_2528]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2576 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2588 = mem[_2576]
                        require mem[_2576] == mem[_2576]
                        require mem[_2576 + 32] == mem[_2576 + 32]
                        require mem[_2576 + 64] == mem[_2576 + 92 len 4]
                        require mem[_2576 + 96] == mem[_2576 + 124 len 4]
                        mem[mem[64] + 4] = _2432
                        mem[mem[64] + 36] = _2540
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2432, _2540, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2660 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2660] == mem[_2660]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2708 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2708] == mem[_2708]
                        require mem[_2708 + 32] == mem[_2708 + 32]
                        require mem[_2708 + 64] == mem[_2708 + 92 len 4]
                        require mem[_2708 + 96] == mem[_2708 + 124 len 4]
                        if mem[_2708] < _2588:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2708] - _2588
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = stor3
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _392 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _398 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _392 + (32 * _398) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _392 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _398:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[0] = address(arg1)
                mem[32] = 12
                require stor12[address(arg1)]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _624 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _628 = mem[_624]
                require mem[_624] == mem[_624 + 18 len 14]
                _632 = mem[_624 + 32]
                require mem[_624 + 32] == mem[_624 + 50 len 14]
                require mem[_624 + 64] == mem[_624 + 92 len 4]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _648 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _652 = mem[_648]
                require mem[_648] == mem[_648 + 12 len 20]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0xd21220a7 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _670 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_670] == mem[_670 + 12 len 20]
                if address(_652) != address(arg1):
                    if mem[_670 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_652) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _775 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _788 = mem[_775]
                    require mem[_775] == mem[_775]
                    if Mask(112, 0, _628) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _628) and mem[_775] > -1 / 1000 * Mask(112, 0, _628):
                        revert with 'NH{q', 17
                    if mem[_775] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_775] / 2 > (-1997 * Mask(112, 0, _628)) - 1:
                        revert with 'NH{q', 17
                    if mem[_775] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_775] / 2 and mem[_775] / 2 > -1 / 997 * mem[_775] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_775] / 2 * mem[_775] / 2 > (-1000 * Mask(112, 0, _628) * mem[_775]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)):
                        revert with 'NH{q', 18
                    if (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) > (-1997 * Mask(112, 0, _628)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) and (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) > -1 / 997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) > (-1000 * Mask(112, 0, _628) * mem[_775]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > (-1997 * Mask(112, 0, _628)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) and (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > -1 / 997 * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > (-1000 * Mask(112, 0, _628) * mem[_775]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * (997 * mem[_775] / 2 * mem[_775] / 2) + (1000 * Mask(112, 0, _628) * mem[_775]) / (1994 * mem[_775] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1011 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1011] == bool(mem[_1011])
                    _1057 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1057]:
                        revert with 'NH{q', 50
                    mem[_1057 + 32] = stor3
                    if 1 >= mem[_1057]:
                        revert with 'NH{q', 50
                    mem[_1057 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_1057 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1057 + 100] = (997 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _788) / (1994 * (997 * _788 / 2 * _788 / 2) + (1000 * Mask(112, 0, _628) * _788) / (1994 * _788 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                    mem[_1057 + 132] = 0
                    mem[_1057 + 164] = 160
                    mem[_1057 + 260] = mem[_1057]
                    idx = 0
                    s = _1057 + 32
                    t = _1057 + 292
                    while idx < mem[_1057]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1057 + 196] = this.address
                    mem[_1057 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1057 + (32 * mem[_1057]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1462 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1480 = mem[_1462]
                    require mem[_1462] <= test266151307()
                    require _1462 + mem[_1462] + 31 < _1462 + return_data.size
                    _1498 = mem[_1462 + mem[_1462]]
                    if mem[_1462 + mem[_1462]] > test266151307():
                        revert with 'NH{q', 65
                    if _1462 + ceil32(return_data.size) + floor32(mem[_1462 + mem[_1462]]) + 1 > test266151307() or floor32(mem[_1462 + mem[_1462]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _1462 + ceil32(return_data.size) + floor32(mem[_1462 + mem[_1462]]) + 1
                    mem[_1462 + ceil32(return_data.size)] = _1498
                    require _1480 + (32 * _1498) + 32 <= return_data.size
                    idx = 0
                    s = _1462 + _1480 + 32
                    t = _1462 + ceil32(return_data.size) + 32
                    while idx < _1498:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2002 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2026 = mem[_2002]
                    require mem[_2002] == mem[_2002]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2080 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2098 = mem[_2080]
                    require mem[_2080] == mem[_2080]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2026
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2026
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2158 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2158] == bool(mem[_2158])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2098
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2098
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2218 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2218] == bool(mem[_2218])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _2098
                    mem[mem[64] + 100] = _2026
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _2098, _2026, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2326 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_2326] == mem[_2326]
                    require mem[_2326 + 32] == mem[_2326 + 32]
                    require mem[_2326 + 64] == mem[_2326 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2422 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2434 = mem[_2422]
                    require mem[_2422] == mem[_2422]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _2434
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _2434
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2482 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2482] == bool(mem[_2482])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2530 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2542 = mem[_2530]
                    require mem[_2530] == mem[_2530]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2590 = mem[_2578]
                    require mem[_2578] == mem[_2578]
                    require mem[_2578 + 32] == mem[_2578 + 32]
                    require mem[_2578 + 64] == mem[_2578 + 92 len 4]
                    require mem[_2578 + 96] == mem[_2578 + 124 len 4]
                    mem[mem[64] + 4] = _2434
                    mem[mem[64] + 36] = _2542
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _2434, _2542, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2662 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2662] == mem[_2662]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2710 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2710] == mem[_2710]
                    require mem[_2710 + 32] == mem[_2710 + 32]
                    require mem[_2710 + 64] == mem[_2710 + 92 len 4]
                    require mem[_2710 + 96] == mem[_2710 + 124 len 4]
                    if mem[_2710] < _2590:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2710] - _2590
                else:
                    if mem[_670 + 12 len 20] == stor3:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _758 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _776 = mem[_758]
                        require mem[_758] == mem[_758]
                        if Mask(112, 0, _632) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _632) and mem[_758] > -1 / 1000 * Mask(112, 0, _632):
                            revert with 'NH{q', 17
                        if mem[_758] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_758] / 2 > (-1997 * Mask(112, 0, _632)) - 1:
                            revert with 'NH{q', 17
                        if mem[_758] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_758] / 2 and mem[_758] / 2 > -1 / 997 * mem[_758] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_758] / 2 * mem[_758] / 2 > (-1000 * Mask(112, 0, _632) * mem[_758]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)):
                            revert with 'NH{q', 18
                        if (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) > (-1997 * Mask(112, 0, _632)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) and (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) > -1 / 997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) > (-1000 * Mask(112, 0, _632) * mem[_758]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) > (-1997 * Mask(112, 0, _632)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) and (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) > -1 / 997 * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) > (-1000 * Mask(112, 0, _632) * mem[_758]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632)) * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * (997 * mem[_758] / 2 * mem[_758] / 2) + (1000 * Mask(112, 0, _632) * mem[_758]) / (1994 * mem[_758] / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _998 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_998] == bool(mem[_998])
                        _1036 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1036]:
                            revert with 'NH{q', 50
                        mem[_1036 + 32] = stor3
                        if 1 >= mem[_1036]:
                            revert with 'NH{q', 50
                        mem[_1036 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1036 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1036 + 100] = (997 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632)) * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632)) * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1000 * Mask(112, 0, _632) * _776) / (1994 * (997 * _776 / 2 * _776 / 2) + (1000 * Mask(112, 0, _632) * _776) / (1994 * _776 / 2) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))) + (1997 * Mask(112, 0, _632))
                        mem[_1036 + 132] = 0
                        mem[_1036 + 164] = 160
                        mem[_1036 + 260] = mem[_1036]
                        idx = 0
                        s = _1036 + 32
                        t = _1036 + 292
                        while idx < mem[_1036]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1036 + 196] = this.address
                        mem[_1036 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1036 + (32 * mem[_1036]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1464 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1482 = mem[_1464]
                        require mem[_1464] <= test266151307()
                        require _1464 + mem[_1464] + 31 < _1464 + return_data.size
                        _1500 = mem[_1464 + mem[_1464]]
                        if mem[_1464 + mem[_1464]] > test266151307():
                            revert with 'NH{q', 65
                        if _1464 + ceil32(return_data.size) + floor32(mem[_1464 + mem[_1464]]) + 1 > test266151307() or floor32(mem[_1464 + mem[_1464]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1464 + ceil32(return_data.size) + floor32(mem[_1464 + mem[_1464]]) + 1
                        mem[_1464 + ceil32(return_data.size)] = _1500
                        require _1482 + (32 * _1500) + 32 <= return_data.size
                        idx = 0
                        s = _1464 + _1482 + 32
                        t = _1464 + ceil32(return_data.size) + 32
                        while idx < _1500:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2004 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2028 = mem[_2004]
                        require mem[_2004] == mem[_2004]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2082 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2100 = mem[_2082]
                        require mem[_2082] == mem[_2082]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2028
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2028
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2160 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2160] == bool(mem[_2160])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2100
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2220] == bool(mem[_2220])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2100
                        mem[mem[64] + 100] = _2028
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2100, _2028, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2328 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2328] == mem[_2328]
                        require mem[_2328 + 32] == mem[_2328 + 32]
                        require mem[_2328 + 64] == mem[_2328 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2424 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2436 = mem[_2424]
                        require mem[_2424] == mem[_2424]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2436
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2436
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2484 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2484] == bool(mem[_2484])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2532 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2544 = mem[_2532]
                        require mem[_2532] == mem[_2532]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2580 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2592 = mem[_2580]
                        require mem[_2580] == mem[_2580]
                        require mem[_2580 + 32] == mem[_2580 + 32]
                        require mem[_2580 + 64] == mem[_2580 + 92 len 4]
                        require mem[_2580 + 96] == mem[_2580 + 124 len 4]
                        mem[mem[64] + 4] = _2436
                        mem[mem[64] + 36] = _2544
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2436, _2544, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2664 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2664] == mem[_2664]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2712 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2712] == mem[_2712]
                        require mem[_2712 + 32] == mem[_2712 + 32]
                        require mem[_2712 + 64] == mem[_2712 + 92 len 4]
                        require mem[_2712 + 96] == mem[_2712 + 124 len 4]
                        if mem[_2712] < _2592:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2712] - _2592
                    else:
                        if mem[_670 + 12 len 20] != address(arg1):
                            revert with 0, 'bad LP token'
                        if address(_652) != stor3:
                            revert with 0, 'bad LP token'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _782 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _792 = mem[_782]
                        require mem[_782] == mem[_782]
                        if Mask(112, 0, _628) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _628) and mem[_782] > -1 / 1000 * Mask(112, 0, _628):
                            revert with 'NH{q', 17
                        if mem[_782] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_782] / 2 > (-1997 * Mask(112, 0, _628)) - 1:
                            revert with 'NH{q', 17
                        if mem[_782] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_782] / 2 and mem[_782] / 2 > -1 / 997 * mem[_782] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_782] / 2 * mem[_782] / 2 > (-1000 * Mask(112, 0, _628) * mem[_782]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)):
                            revert with 'NH{q', 18
                        if (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) > (-1997 * Mask(112, 0, _628)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) and (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) > -1 / 997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) > (-1000 * Mask(112, 0, _628) * mem[_782]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > (-1997 * Mask(112, 0, _628)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) and (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > -1 / 997 * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) > (-1000 * Mask(112, 0, _628) * mem[_782]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628)) * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * (997 * mem[_782] / 2 * mem[_782] / 2) + (1000 * Mask(112, 0, _628) * mem[_782]) / (1994 * mem[_782] / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1024 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1024] == bool(mem[_1024])
                        _1064 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1064]:
                            revert with 'NH{q', 50
                        mem[_1064 + 32] = stor3
                        if 1 >= mem[_1064]:
                            revert with 'NH{q', 50
                        mem[_1064 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1064 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1064 + 100] = (997 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628)) * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628)) * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1000 * Mask(112, 0, _628) * _792) / (1994 * (997 * _792 / 2 * _792 / 2) + (1000 * Mask(112, 0, _628) * _792) / (1994 * _792 / 2) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))) + (1997 * Mask(112, 0, _628))
                        mem[_1064 + 132] = 0
                        mem[_1064 + 164] = 160
                        mem[_1064 + 260] = mem[_1064]
                        idx = 0
                        s = _1064 + 32
                        t = _1064 + 292
                        while idx < mem[_1064]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1064 + 196] = this.address
                        mem[_1064 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1064 + (32 * mem[_1064]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1463 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1481 = mem[_1463]
                        require mem[_1463] <= test266151307()
                        require _1463 + mem[_1463] + 31 < _1463 + return_data.size
                        _1499 = mem[_1463 + mem[_1463]]
                        if mem[_1463 + mem[_1463]] > test266151307():
                            revert with 'NH{q', 65
                        if _1463 + ceil32(return_data.size) + floor32(mem[_1463 + mem[_1463]]) + 1 > test266151307() or floor32(mem[_1463 + mem[_1463]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1463 + ceil32(return_data.size) + floor32(mem[_1463 + mem[_1463]]) + 1
                        mem[_1463 + ceil32(return_data.size)] = _1499
                        require _1481 + (32 * _1499) + 32 <= return_data.size
                        idx = 0
                        s = _1463 + _1481 + 32
                        t = _1463 + ceil32(return_data.size) + 32
                        while idx < _1499:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2003 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2027 = mem[_2003]
                        require mem[_2003] == mem[_2003]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2081 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2099 = mem[_2081]
                        require mem[_2081] == mem[_2081]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2027
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2027
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2159 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2159] == bool(mem[_2159])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2099
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2099
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2219 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2219] == bool(mem[_2219])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2099
                        mem[mem[64] + 100] = _2027
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2099, _2027, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2327 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2327] == mem[_2327]
                        require mem[_2327 + 32] == mem[_2327 + 32]
                        require mem[_2327 + 64] == mem[_2327 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2423 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2435 = mem[_2423]
                        require mem[_2423] == mem[_2423]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2435
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2435
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2483 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2483] == bool(mem[_2483])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2531 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2543 = mem[_2531]
                        require mem[_2531] == mem[_2531]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2579 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2591 = mem[_2579]
                        require mem[_2579] == mem[_2579]
                        require mem[_2579 + 32] == mem[_2579 + 32]
                        require mem[_2579 + 64] == mem[_2579 + 92 len 4]
                        require mem[_2579 + 96] == mem[_2579 + 124 len 4]
                        mem[mem[64] + 4] = _2435
                        mem[mem[64] + 36] = _2543
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2435, _2543, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2663 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2663] == mem[_2663]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2711 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2711] == mem[_2711]
                        require mem[_2711 + 32] == mem[_2711 + 32]
                        require mem[_2711 + 64] == mem[_2711 + 92 len 4]
                        require mem[_2711 + 96] == mem[_2711 + 124 len 4]
                        if mem[_2711] < _2591:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2711] - _2591
        else:
            mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require stor3
            if stor3 == stor3:
                mem[(6 * ceil32(return_data.size)) + 100] = stor6
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = stor3
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _393 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _399 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _393 + (32 * _399) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _393 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _399:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[0] = address(arg1)
                mem[32] = 12
                require stor12[address(arg1)]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _625 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _629 = mem[_625]
                require mem[_625] == mem[_625 + 18 len 14]
                _633 = mem[_625 + 32]
                require mem[_625 + 32] == mem[_625 + 50 len 14]
                require mem[_625 + 64] == mem[_625 + 92 len 4]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _649 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _653 = mem[_649]
                require mem[_649] == mem[_649 + 12 len 20]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0xd21220a7 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _671 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_671] == mem[_671 + 12 len 20]
                if address(_653) != address(arg1):
                    if mem[_671 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_653) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _777 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _789 = mem[_777]
                    require mem[_777] == mem[_777]
                    if Mask(112, 0, _629) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _629) and mem[_777] > -1 / 1000 * Mask(112, 0, _629):
                        revert with 'NH{q', 17
                    if mem[_777] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_777] / 2 > (-1997 * Mask(112, 0, _629)) - 1:
                        revert with 'NH{q', 17
                    if mem[_777] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_777] / 2 and mem[_777] / 2 > -1 / 997 * mem[_777] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_777] / 2 * mem[_777] / 2 > (-1000 * Mask(112, 0, _629) * mem[_777]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)):
                        revert with 'NH{q', 18
                    if (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) > (-1997 * Mask(112, 0, _629)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) and (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) > -1 / 997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) > (-1000 * Mask(112, 0, _629) * mem[_777]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > (-1997 * Mask(112, 0, _629)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) and (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > -1 / 997 * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > (-1000 * Mask(112, 0, _629) * mem[_777]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * (997 * mem[_777] / 2 * mem[_777] / 2) + (1000 * Mask(112, 0, _629) * mem[_777]) / (1994 * mem[_777] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1013 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1013] == bool(mem[_1013])
                    _1059 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1059]:
                        revert with 'NH{q', 50
                    mem[_1059 + 32] = stor3
                    if 1 >= mem[_1059]:
                        revert with 'NH{q', 50
                    mem[_1059 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_1059 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1059 + 100] = (997 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _789) / (1994 * (997 * _789 / 2 * _789 / 2) + (1000 * Mask(112, 0, _629) * _789) / (1994 * _789 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                    mem[_1059 + 132] = 0
                    mem[_1059 + 164] = 160
                    mem[_1059 + 260] = mem[_1059]
                    idx = 0
                    s = _1059 + 32
                    t = _1059 + 292
                    while idx < mem[_1059]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1059 + 196] = this.address
                    mem[_1059 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1059 + (32 * mem[_1059]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1465 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1483 = mem[_1465]
                    require mem[_1465] <= test266151307()
                    require _1465 + mem[_1465] + 31 < _1465 + return_data.size
                    _1501 = mem[_1465 + mem[_1465]]
                    if mem[_1465 + mem[_1465]] > test266151307():
                        revert with 'NH{q', 65
                    if _1465 + ceil32(return_data.size) + floor32(mem[_1465 + mem[_1465]]) + 1 > test266151307() or floor32(mem[_1465 + mem[_1465]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _1465 + ceil32(return_data.size) + floor32(mem[_1465 + mem[_1465]]) + 1
                    mem[_1465 + ceil32(return_data.size)] = _1501
                    require _1483 + (32 * _1501) + 32 <= return_data.size
                    idx = 0
                    s = _1465 + _1483 + 32
                    t = _1465 + ceil32(return_data.size) + 32
                    while idx < _1501:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2005 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2029 = mem[_2005]
                    require mem[_2005] == mem[_2005]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2083 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2101 = mem[_2083]
                    require mem[_2083] == mem[_2083]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2029
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2029
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2161 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2161] == bool(mem[_2161])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2101
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2101
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2221] == bool(mem[_2221])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _2101
                    mem[mem[64] + 100] = _2029
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _2101, _2029, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2329 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_2329] == mem[_2329]
                    require mem[_2329 + 32] == mem[_2329 + 32]
                    require mem[_2329 + 64] == mem[_2329 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2425 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2437 = mem[_2425]
                    require mem[_2425] == mem[_2425]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _2437
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _2437
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2485 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2485] == bool(mem[_2485])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2533 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2545 = mem[_2533]
                    require mem[_2533] == mem[_2533]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2581 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2593 = mem[_2581]
                    require mem[_2581] == mem[_2581]
                    require mem[_2581 + 32] == mem[_2581 + 32]
                    require mem[_2581 + 64] == mem[_2581 + 92 len 4]
                    require mem[_2581 + 96] == mem[_2581 + 124 len 4]
                    mem[mem[64] + 4] = _2437
                    mem[mem[64] + 36] = _2545
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _2437, _2545, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2665 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2665] == mem[_2665]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2713 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2713] == mem[_2713]
                    require mem[_2713 + 32] == mem[_2713 + 32]
                    require mem[_2713 + 64] == mem[_2713 + 92 len 4]
                    require mem[_2713 + 96] == mem[_2713 + 124 len 4]
                    if mem[_2713] < _2593:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2713] - _2593
                else:
                    if mem[_671 + 12 len 20] == stor3:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _760 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _778 = mem[_760]
                        require mem[_760] == mem[_760]
                        if Mask(112, 0, _633) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _633) and mem[_760] > -1 / 1000 * Mask(112, 0, _633):
                            revert with 'NH{q', 17
                        if mem[_760] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_760] / 2 > (-1997 * Mask(112, 0, _633)) - 1:
                            revert with 'NH{q', 17
                        if mem[_760] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_760] / 2 and mem[_760] / 2 > -1 / 997 * mem[_760] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_760] / 2 * mem[_760] / 2 > (-1000 * Mask(112, 0, _633) * mem[_760]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)):
                            revert with 'NH{q', 18
                        if (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) > (-1997 * Mask(112, 0, _633)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) and (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) > -1 / 997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) > (-1000 * Mask(112, 0, _633) * mem[_760]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) > (-1997 * Mask(112, 0, _633)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) and (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) > -1 / 997 * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) > (-1000 * Mask(112, 0, _633) * mem[_760]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633)) * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * (997 * mem[_760] / 2 * mem[_760] / 2) + (1000 * Mask(112, 0, _633) * mem[_760]) / (1994 * mem[_760] / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _999 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_999] == bool(mem[_999])
                        _1037 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1037]:
                            revert with 'NH{q', 50
                        mem[_1037 + 32] = stor3
                        if 1 >= mem[_1037]:
                            revert with 'NH{q', 50
                        mem[_1037 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1037 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1037 + 100] = (997 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633)) * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633)) * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1000 * Mask(112, 0, _633) * _778) / (1994 * (997 * _778 / 2 * _778 / 2) + (1000 * Mask(112, 0, _633) * _778) / (1994 * _778 / 2) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))) + (1997 * Mask(112, 0, _633))
                        mem[_1037 + 132] = 0
                        mem[_1037 + 164] = 160
                        mem[_1037 + 260] = mem[_1037]
                        idx = 0
                        s = _1037 + 32
                        t = _1037 + 292
                        while idx < mem[_1037]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1037 + 196] = this.address
                        mem[_1037 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1037 + (32 * mem[_1037]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1467 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1485 = mem[_1467]
                        require mem[_1467] <= test266151307()
                        require _1467 + mem[_1467] + 31 < _1467 + return_data.size
                        _1503 = mem[_1467 + mem[_1467]]
                        if mem[_1467 + mem[_1467]] > test266151307():
                            revert with 'NH{q', 65
                        if _1467 + ceil32(return_data.size) + floor32(mem[_1467 + mem[_1467]]) + 1 > test266151307() or floor32(mem[_1467 + mem[_1467]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1467 + ceil32(return_data.size) + floor32(mem[_1467 + mem[_1467]]) + 1
                        mem[_1467 + ceil32(return_data.size)] = _1503
                        require _1485 + (32 * _1503) + 32 <= return_data.size
                        idx = 0
                        s = _1467 + _1485 + 32
                        t = _1467 + ceil32(return_data.size) + 32
                        while idx < _1503:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2007 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2031 = mem[_2007]
                        require mem[_2007] == mem[_2007]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2085 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2103 = mem[_2085]
                        require mem[_2085] == mem[_2085]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2031
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2031
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2163 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2163] == bool(mem[_2163])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2103
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2103
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2223 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2223] == bool(mem[_2223])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2103
                        mem[mem[64] + 100] = _2031
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2103, _2031, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2331 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2331] == mem[_2331]
                        require mem[_2331 + 32] == mem[_2331 + 32]
                        require mem[_2331 + 64] == mem[_2331 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2427 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2439 = mem[_2427]
                        require mem[_2427] == mem[_2427]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2439
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2439
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2487 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2487] == bool(mem[_2487])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2535 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2547 = mem[_2535]
                        require mem[_2535] == mem[_2535]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2583 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2595 = mem[_2583]
                        require mem[_2583] == mem[_2583]
                        require mem[_2583 + 32] == mem[_2583 + 32]
                        require mem[_2583 + 64] == mem[_2583 + 92 len 4]
                        require mem[_2583 + 96] == mem[_2583 + 124 len 4]
                        mem[mem[64] + 4] = _2439
                        mem[mem[64] + 36] = _2547
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2439, _2547, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2667 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2667] == mem[_2667]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2715 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2715] == mem[_2715]
                        require mem[_2715 + 32] == mem[_2715 + 32]
                        require mem[_2715 + 64] == mem[_2715 + 92 len 4]
                        require mem[_2715 + 96] == mem[_2715 + 124 len 4]
                        if mem[_2715] < _2595:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2715] - _2595
                    else:
                        if mem[_671 + 12 len 20] != address(arg1):
                            revert with 0, 'bad LP token'
                        if address(_653) != stor3:
                            revert with 0, 'bad LP token'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _783 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _793 = mem[_783]
                        require mem[_783] == mem[_783]
                        if Mask(112, 0, _629) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _629) and mem[_783] > -1 / 1000 * Mask(112, 0, _629):
                            revert with 'NH{q', 17
                        if mem[_783] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_783] / 2 > (-1997 * Mask(112, 0, _629)) - 1:
                            revert with 'NH{q', 17
                        if mem[_783] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_783] / 2 and mem[_783] / 2 > -1 / 997 * mem[_783] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_783] / 2 * mem[_783] / 2 > (-1000 * Mask(112, 0, _629) * mem[_783]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)):
                            revert with 'NH{q', 18
                        if (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) > (-1997 * Mask(112, 0, _629)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) and (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) > -1 / 997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) > (-1000 * Mask(112, 0, _629) * mem[_783]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > (-1997 * Mask(112, 0, _629)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) and (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > -1 / 997 * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) > (-1000 * Mask(112, 0, _629) * mem[_783]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629)) * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * (997 * mem[_783] / 2 * mem[_783] / 2) + (1000 * Mask(112, 0, _629) * mem[_783]) / (1994 * mem[_783] / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1025 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1025] == bool(mem[_1025])
                        _1065 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1065]:
                            revert with 'NH{q', 50
                        mem[_1065 + 32] = stor3
                        if 1 >= mem[_1065]:
                            revert with 'NH{q', 50
                        mem[_1065 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1065 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1065 + 100] = (997 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629)) * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629)) * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1000 * Mask(112, 0, _629) * _793) / (1994 * (997 * _793 / 2 * _793 / 2) + (1000 * Mask(112, 0, _629) * _793) / (1994 * _793 / 2) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))) + (1997 * Mask(112, 0, _629))
                        mem[_1065 + 132] = 0
                        mem[_1065 + 164] = 160
                        mem[_1065 + 260] = mem[_1065]
                        idx = 0
                        s = _1065 + 32
                        t = _1065 + 292
                        while idx < mem[_1065]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1065 + 196] = this.address
                        mem[_1065 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1065 + (32 * mem[_1065]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1466 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1484 = mem[_1466]
                        require mem[_1466] <= test266151307()
                        require _1466 + mem[_1466] + 31 < _1466 + return_data.size
                        _1502 = mem[_1466 + mem[_1466]]
                        if mem[_1466 + mem[_1466]] > test266151307():
                            revert with 'NH{q', 65
                        if _1466 + ceil32(return_data.size) + floor32(mem[_1466 + mem[_1466]]) + 1 > test266151307() or floor32(mem[_1466 + mem[_1466]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1466 + ceil32(return_data.size) + floor32(mem[_1466 + mem[_1466]]) + 1
                        mem[_1466 + ceil32(return_data.size)] = _1502
                        require _1484 + (32 * _1502) + 32 <= return_data.size
                        idx = 0
                        s = _1466 + _1484 + 32
                        t = _1466 + ceil32(return_data.size) + 32
                        while idx < _1502:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2006 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2030 = mem[_2006]
                        require mem[_2006] == mem[_2006]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2084 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2102 = mem[_2084]
                        require mem[_2084] == mem[_2084]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2030
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2030
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2162 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2162] == bool(mem[_2162])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2102
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2102
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2222 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2222] == bool(mem[_2222])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2102
                        mem[mem[64] + 100] = _2030
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2102, _2030, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2330 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2330] == mem[_2330]
                        require mem[_2330 + 32] == mem[_2330 + 32]
                        require mem[_2330 + 64] == mem[_2330 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2426 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2438 = mem[_2426]
                        require mem[_2426] == mem[_2426]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2438
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2438
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2486 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2486] == bool(mem[_2486])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2534 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2546 = mem[_2534]
                        require mem[_2534] == mem[_2534]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2582 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2594 = mem[_2582]
                        require mem[_2582] == mem[_2582]
                        require mem[_2582 + 32] == mem[_2582 + 32]
                        require mem[_2582 + 64] == mem[_2582 + 92 len 4]
                        require mem[_2582 + 96] == mem[_2582 + 124 len 4]
                        mem[mem[64] + 4] = _2438
                        mem[mem[64] + 36] = _2546
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2438, _2546, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2666 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2666] == mem[_2666]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2714 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2714] == mem[_2714]
                        require mem[_2714 + 32] == mem[_2714 + 32]
                        require mem[_2714 + 64] == mem[_2714 + 92 len 4]
                        require mem[_2714 + 96] == mem[_2714 + 124 len 4]
                        if mem[_2714] < _2594:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2714] - _2594
            else:
                mem[(6 * ceil32(return_data.size)) + 100] = stor5
                mem[(6 * ceil32(return_data.size)) + 132] = arg2
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, arg2
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(7 * ceil32(return_data.size)) + 96] = 2
                mem[(7 * ceil32(return_data.size)) + 128] = stor2
                mem[(7 * ceil32(return_data.size)) + 160] = stor3
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 228] = 0
                mem[(7 * ceil32(return_data.size)) + 260] = 160
                mem[(7 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (7 * ceil32(return_data.size)) + 128
                t = (7 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(7 * ceil32(return_data.size)) + 292] = this.address
                mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (8 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _394 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
                require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
                _400 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
                mem[(8 * ceil32(return_data.size)) + 192] = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                require _394 + (32 * _400) + 32 <= return_data.size
                idx = 0
                s = (7 * ceil32(return_data.size)) + _394 + 224
                t = (8 * ceil32(return_data.size)) + 224
                while idx < _400:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[0] = address(arg1)
                mem[32] = 12
                require stor12[address(arg1)]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _626 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _630 = mem[_626]
                require mem[_626] == mem[_626 + 18 len 14]
                _634 = mem[_626 + 32]
                require mem[_626 + 32] == mem[_626 + 50 len 14]
                require mem[_626 + 64] == mem[_626 + 92 len 4]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _650 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _654 = mem[_650]
                require mem[_650] == mem[_650 + 12 len 20]
                require ext_code.size(stor12[address(arg1)])
                staticcall stor12[address(arg1)].0xd21220a7 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _672 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_672] == mem[_672 + 12 len 20]
                if address(_654) != address(arg1):
                    if mem[_672 + 12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(_654) != stor3:
                        revert with 0, 'bad LP token'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _779 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _790 = mem[_779]
                    require mem[_779] == mem[_779]
                    if Mask(112, 0, _630) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, _630) and mem[_779] > -1 / 1000 * Mask(112, 0, _630):
                        revert with 'NH{q', 17
                    if mem[_779] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * mem[_779] / 2 > (-1997 * Mask(112, 0, _630)) - 1:
                        revert with 'NH{q', 17
                    if mem[_779] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * mem[_779] / 2 and mem[_779] / 2 > -1 / 997 * mem[_779] / 2:
                        revert with 'NH{q', 17
                    if 997 * mem[_779] / 2 * mem[_779] / 2 > (-1000 * Mask(112, 0, _630) * mem[_779]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)):
                        revert with 'NH{q', 18
                    if (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) > (-1997 * Mask(112, 0, _630)) - 1:
                        revert with 'NH{q', 17
                    if (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) and (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) > -1 / 997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)):
                        revert with 'NH{q', 17
                    if 997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) > (-1000 * Mask(112, 0, _630) * mem[_779]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                        revert with 'NH{q', 18
                    if (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > (-1997 * Mask(112, 0, _630)) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) and (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > -1 / 997 * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > (-1000 * Mask(112, 0, _630) * mem[_779]) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * (997 * mem[_779] / 2 * mem[_779] / 2) + (1000 * Mask(112, 0, _630) * mem[_779]) / (1994 * mem[_779] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                        revert with 'NH{q', 18
                    require address(arg1)
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = (997 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1015 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1015] == bool(mem[_1015])
                    _1061 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1061]:
                        revert with 'NH{q', 50
                    mem[_1061 + 32] = stor3
                    if 1 >= mem[_1061]:
                        revert with 'NH{q', 50
                    mem[_1061 + 64] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[_1061 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1061 + 100] = (997 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _790) / (1994 * (997 * _790 / 2 * _790 / 2) + (1000 * Mask(112, 0, _630) * _790) / (1994 * _790 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                    mem[_1061 + 132] = 0
                    mem[_1061 + 164] = 160
                    mem[_1061 + 260] = mem[_1061]
                    idx = 0
                    s = _1061 + 32
                    t = _1061 + 292
                    while idx < mem[_1061]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1061 + 196] = this.address
                    mem[_1061 + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1061 + (32 * mem[_1061]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1468 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1486 = mem[_1468]
                    require mem[_1468] <= test266151307()
                    require _1468 + mem[_1468] + 31 < _1468 + return_data.size
                    _1504 = mem[_1468 + mem[_1468]]
                    if mem[_1468 + mem[_1468]] > test266151307():
                        revert with 'NH{q', 65
                    if _1468 + ceil32(return_data.size) + floor32(mem[_1468 + mem[_1468]]) + 1 > test266151307() or floor32(mem[_1468 + mem[_1468]]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = _1468 + ceil32(return_data.size) + floor32(mem[_1468 + mem[_1468]]) + 1
                    mem[_1468 + ceil32(return_data.size)] = _1504
                    require _1486 + (32 * _1504) + 32 <= return_data.size
                    idx = 0
                    s = _1468 + _1486 + 32
                    t = _1468 + ceil32(return_data.size) + 32
                    while idx < _1504:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2008 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2032 = mem[_2008]
                    require mem[_2008] == mem[_2008]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor3)
                    staticcall stor3.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2086 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2104 = mem[_2086]
                    require mem[_2086] == mem[_2086]
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2032
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2032
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2164 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2164] == bool(mem[_2164])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _2104
                    require ext_code.size(stor3)
                    call stor3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _2104
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2224 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2224] == bool(mem[_2224])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _2104
                    mem[mem[64] + 100] = _2032
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor3, address(arg1), _2104, _2032, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2332 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_2332] == mem[_2332]
                    require mem[_2332 + 32] == mem[_2332 + 32]
                    require mem[_2332 + 64] == mem[_2332 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 12
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor12[address(arg1)])
                    staticcall stor12[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2428 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2440 = mem[_2428]
                    require mem[_2428] == mem[_2428]
                    mem[0] = stor12[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                    mem[mem[64] + 36] = _2440
                    require ext_code.size(stor12[address(arg1)])
                    call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor12[address(arg1)]], _2440
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2488 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2488] == bool(mem[_2488])
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2536 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2548 = mem[_2536]
                    require mem[_2536] == mem[_2536]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2584 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2596 = mem[_2584]
                    require mem[_2584] == mem[_2584]
                    require mem[_2584 + 32] == mem[_2584 + 32]
                    require mem[_2584 + 64] == mem[_2584 + 92 len 4]
                    require mem[_2584 + 96] == mem[_2584 + 124 len 4]
                    mem[mem[64] + 4] = _2440
                    mem[mem[64] + 36] = _2548
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _2440, _2548, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2668 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2668] == mem[_2668]
                    require ext_code.size(stor13[stor12[address(arg1)]])
                    staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2716 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2716] == mem[_2716]
                    require mem[_2716 + 32] == mem[_2716 + 32]
                    require mem[_2716 + 64] == mem[_2716 + 92 len 4]
                    require mem[_2716 + 96] == mem[_2716 + 124 len 4]
                    if mem[_2716] < _2596:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2716] - _2596
                else:
                    if mem[_672 + 12 len 20] == stor3:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _762 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _780 = mem[_762]
                        require mem[_762] == mem[_762]
                        if Mask(112, 0, _634) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _634) and mem[_762] > -1 / 1000 * Mask(112, 0, _634):
                            revert with 'NH{q', 17
                        if mem[_762] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_762] / 2 > (-1997 * Mask(112, 0, _634)) - 1:
                            revert with 'NH{q', 17
                        if mem[_762] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_762] / 2 and mem[_762] / 2 > -1 / 997 * mem[_762] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_762] / 2 * mem[_762] / 2 > (-1000 * Mask(112, 0, _634) * mem[_762]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)):
                            revert with 'NH{q', 18
                        if (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) > (-1997 * Mask(112, 0, _634)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) and (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) > -1 / 997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) > (-1000 * Mask(112, 0, _634) * mem[_762]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) > (-1997 * Mask(112, 0, _634)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) and (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) > -1 / 997 * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) > (-1000 * Mask(112, 0, _634) * mem[_762]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634)) * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * (997 * mem[_762] / 2 * mem[_762] / 2) + (1000 * Mask(112, 0, _634) * mem[_762]) / (1994 * mem[_762] / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1000 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1000] == bool(mem[_1000])
                        _1038 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1038]:
                            revert with 'NH{q', 50
                        mem[_1038 + 32] = stor3
                        if 1 >= mem[_1038]:
                            revert with 'NH{q', 50
                        mem[_1038 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1038 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1038 + 100] = (997 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634)) * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634)) * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1000 * Mask(112, 0, _634) * _780) / (1994 * (997 * _780 / 2 * _780 / 2) + (1000 * Mask(112, 0, _634) * _780) / (1994 * _780 / 2) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))) + (1997 * Mask(112, 0, _634))
                        mem[_1038 + 132] = 0
                        mem[_1038 + 164] = 160
                        mem[_1038 + 260] = mem[_1038]
                        idx = 0
                        s = _1038 + 32
                        t = _1038 + 292
                        while idx < mem[_1038]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1038 + 196] = this.address
                        mem[_1038 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1038 + (32 * mem[_1038]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1470 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1488 = mem[_1470]
                        require mem[_1470] <= test266151307()
                        require _1470 + mem[_1470] + 31 < _1470 + return_data.size
                        _1506 = mem[_1470 + mem[_1470]]
                        if mem[_1470 + mem[_1470]] > test266151307():
                            revert with 'NH{q', 65
                        if _1470 + ceil32(return_data.size) + floor32(mem[_1470 + mem[_1470]]) + 1 > test266151307() or floor32(mem[_1470 + mem[_1470]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1470 + ceil32(return_data.size) + floor32(mem[_1470 + mem[_1470]]) + 1
                        mem[_1470 + ceil32(return_data.size)] = _1506
                        require _1488 + (32 * _1506) + 32 <= return_data.size
                        idx = 0
                        s = _1470 + _1488 + 32
                        t = _1470 + ceil32(return_data.size) + 32
                        while idx < _1506:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2010 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2034 = mem[_2010]
                        require mem[_2010] == mem[_2010]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2088 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2106 = mem[_2088]
                        require mem[_2088] == mem[_2088]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2034
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2034
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2166 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2166] == bool(mem[_2166])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2106
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2106
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2226 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2226] == bool(mem[_2226])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2106
                        mem[mem[64] + 100] = _2034
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2106, _2034, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2334 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2334] == mem[_2334]
                        require mem[_2334 + 32] == mem[_2334 + 32]
                        require mem[_2334 + 64] == mem[_2334 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2430 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2442 = mem[_2430]
                        require mem[_2430] == mem[_2430]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2442
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2442
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2490 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2490] == bool(mem[_2490])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2538 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2550 = mem[_2538]
                        require mem[_2538] == mem[_2538]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2586 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2598 = mem[_2586]
                        require mem[_2586] == mem[_2586]
                        require mem[_2586 + 32] == mem[_2586 + 32]
                        require mem[_2586 + 64] == mem[_2586 + 92 len 4]
                        require mem[_2586 + 96] == mem[_2586 + 124 len 4]
                        mem[mem[64] + 4] = _2442
                        mem[mem[64] + 36] = _2550
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2442, _2550, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2670 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2670] == mem[_2670]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2718 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2718] == mem[_2718]
                        require mem[_2718 + 32] == mem[_2718 + 32]
                        require mem[_2718 + 64] == mem[_2718 + 92 len 4]
                        require mem[_2718 + 96] == mem[_2718 + 124 len 4]
                        if mem[_2718] < _2598:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2718] - _2598
                    else:
                        if mem[_672 + 12 len 20] != address(arg1):
                            revert with 0, 'bad LP token'
                        if address(_654) != stor3:
                            revert with 0, 'bad LP token'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _784 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _794 = mem[_784]
                        require mem[_784] == mem[_784]
                        if Mask(112, 0, _630) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                            revert with 'NH{q', 17
                        if 1000 * Mask(112, 0, _630) and mem[_784] > -1 / 1000 * Mask(112, 0, _630):
                            revert with 'NH{q', 17
                        if mem[_784] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * mem[_784] / 2 > (-1997 * Mask(112, 0, _630)) - 1:
                            revert with 'NH{q', 17
                        if mem[_784] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * mem[_784] / 2 and mem[_784] / 2 > -1 / 997 * mem[_784] / 2:
                            revert with 'NH{q', 17
                        if 997 * mem[_784] / 2 * mem[_784] / 2 > (-1000 * Mask(112, 0, _630) * mem[_784]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)):
                            revert with 'NH{q', 18
                        if (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) > (-1997 * Mask(112, 0, _630)) - 1:
                            revert with 'NH{q', 17
                        if (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) and (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) > -1 / 997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)):
                            revert with 'NH{q', 17
                        if 997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) > (-1000 * Mask(112, 0, _630) * mem[_784]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                            revert with 'NH{q', 18
                        if (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                            revert with 'NH{q', 17
                        if 1994 * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > (-1997 * Mask(112, 0, _630)) - 1:
                            revert with 'NH{q', 17
                        if (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) and (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > -1 / 997 * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                            revert with 'NH{q', 17
                        if 997 * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) > (-1000 * Mask(112, 0, _630) * mem[_784]) - 1:
                            revert with 'NH{q', 17
                        if not (1994 * (997 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630)) * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * (997 * mem[_784] / 2 * mem[_784] / 2) + (1000 * Mask(112, 0, _630) * mem[_784]) / (1994 * mem[_784] / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)):
                            revert with 'NH{q', 18
                        require address(arg1)
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = (997 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1026 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1026] == bool(mem[_1026])
                        _1066 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1066]:
                            revert with 'NH{q', 50
                        mem[_1066 + 32] = stor3
                        if 1 >= mem[_1066]:
                            revert with 'NH{q', 50
                        mem[_1066 + 64] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[_1066 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1066 + 100] = (997 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630)) * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630)) * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1000 * Mask(112, 0, _630) * _794) / (1994 * (997 * _794 / 2 * _794 / 2) + (1000 * Mask(112, 0, _630) * _794) / (1994 * _794 / 2) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))) + (1997 * Mask(112, 0, _630))
                        mem[_1066 + 132] = 0
                        mem[_1066 + 164] = 160
                        mem[_1066 + 260] = mem[_1066]
                        idx = 0
                        s = _1066 + 32
                        t = _1066 + 292
                        while idx < mem[_1066]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1066 + 196] = this.address
                        mem[_1066 + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1066 + (32 * mem[_1066]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1469 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1487 = mem[_1469]
                        require mem[_1469] <= test266151307()
                        require _1469 + mem[_1469] + 31 < _1469 + return_data.size
                        _1505 = mem[_1469 + mem[_1469]]
                        if mem[_1469 + mem[_1469]] > test266151307():
                            revert with 'NH{q', 65
                        if _1469 + ceil32(return_data.size) + floor32(mem[_1469 + mem[_1469]]) + 1 > test266151307() or floor32(mem[_1469 + mem[_1469]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _1469 + ceil32(return_data.size) + floor32(mem[_1469 + mem[_1469]]) + 1
                        mem[_1469 + ceil32(return_data.size)] = _1505
                        require _1487 + (32 * _1505) + 32 <= return_data.size
                        idx = 0
                        s = _1469 + _1487 + 32
                        t = _1469 + ceil32(return_data.size) + 32
                        while idx < _1505:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2009 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2033 = mem[_2009]
                        require mem[_2009] == mem[_2009]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor3)
                        staticcall stor3.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2087 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2105 = mem[_2087]
                        require mem[_2087] == mem[_2087]
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2033
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2033
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2165 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2165] == bool(mem[_2165])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _2105
                        require ext_code.size(stor3)
                        call stor3.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _2105
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2225 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2225] == bool(mem[_2225])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _2105
                        mem[mem[64] + 100] = _2033
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor3, address(arg1), _2105, _2033, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2333 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2333] == mem[_2333]
                        require mem[_2333 + 32] == mem[_2333 + 32]
                        require mem[_2333 + 64] == mem[_2333 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 12
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor12[address(arg1)])
                        staticcall stor12[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2429 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2441 = mem[_2429]
                        require mem[_2429] == mem[_2429]
                        mem[0] = stor12[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor12[address(arg1)]]
                        mem[mem[64] + 36] = _2441
                        require ext_code.size(stor12[address(arg1)])
                        call stor12[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor12[address(arg1)]], _2441
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2489 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2489] == bool(mem[_2489])
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2537 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2549 = mem[_2537]
                        require mem[_2537] == mem[_2537]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2585 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2597 = mem[_2585]
                        require mem[_2585] == mem[_2585]
                        require mem[_2585 + 32] == mem[_2585 + 32]
                        require mem[_2585 + 64] == mem[_2585 + 92 len 4]
                        require mem[_2585 + 96] == mem[_2585 + 124 len 4]
                        mem[mem[64] + 4] = _2441
                        mem[mem[64] + 36] = _2549
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        call stor13[stor12[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2441, _2549, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2669 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2669] == mem[_2669]
                        require ext_code.size(stor13[stor12[address(arg1)]])
                        staticcall stor13[stor12[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2717 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2717] == mem[_2717]
                        require mem[_2717 + 32] == mem[_2717 + 32]
                        require mem[_2717 + 64] == mem[_2717 + 92 len 4]
                        require mem[_2717 + 96] == mem[_2717 + 124 len 4]
                        if mem[_2717] < _2597:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2717] - _2597
    return memory
      from mem[64]
       len 32
}

function sub_943a051e(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == arg2
    mem[100] = msg.sender
    require ext_code.size(stor2)
    staticcall stor2.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] >= arg2:
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = this.address
        mem[ceil32(return_data.size) + 164] = arg2
        require ext_code.size(stor2)
        call stor2.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[0] = address(arg1)
        mem[32] = 11
        require stor11[address(arg1)]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].getReserves() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].token0() with:
                gas gas_remaining wei
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].0xd21220a7 with:
                gas gas_remaining wei
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != address(arg1):
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor2:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            if address(arg1) == stor3:
                mem[(7 * ceil32(return_data.size)) + 100] = stor6
                mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(8 * ceil32(return_data.size)) + 96] = 2
                mem[(8 * ceil32(return_data.size)) + 128] = stor2
                mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(8 * ceil32(return_data.size)) + 228] = 0
                mem[(8 * ceil32(return_data.size)) + 260] = 160
                mem[(8 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (8 * ceil32(return_data.size)) + 128
                t = (8 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(8 * ceil32(return_data.size)) + 292] = this.address
                mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (10 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _336 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                _350 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                require _336 + (32 * _350) + 32 <= return_data.size
                idx = 0
                s = (8 * ceil32(return_data.size)) + _336 + 224
                t = (10 * ceil32(return_data.size)) + 224
                while idx < _350:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1030 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1048 = mem[_1030]
                require mem[_1030] == mem[_1030]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1090 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1108 = mem[_1090]
                require mem[_1090] == mem[_1090]
                if address(arg1) == stor3:
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1048
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1048
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1198 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1198] == bool(mem[_1198])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1108
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1108
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1306] == bool(mem[_1306])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1108
                    mem[mem[64] + 100] = _1048
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1108, _1048, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1546 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1546] == mem[_1546]
                    require mem[_1546 + 32] == mem[_1546 + 32]
                    require mem[_1546 + 64] == mem[_1546 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1678 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1714 = mem[_1678]
                    require mem[_1678] == mem[_1678]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1714
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1714
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1810 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1810] == bool(mem[_1810])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1894 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1906 = mem[_1894]
                    require mem[_1894] == mem[_1894]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1990 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2002 = mem[_1990]
                    require mem[_1990] == mem[_1990]
                    require mem[_1990 + 32] == mem[_1990 + 32]
                    require mem[_1990 + 64] == mem[_1990 + 92 len 4]
                    require mem[_1990 + 96] == mem[_1990 + 124 len 4]
                    mem[mem[64] + 4] = _1714
                    mem[mem[64] + 36] = _1906
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1714, _1906, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2266 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2266] == mem[_2266]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2338 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2338] == mem[_2338]
                    require mem[_2338 + 32] == mem[_2338 + 32]
                    require mem[_2338 + 64] == mem[_2338 + 92 len 4]
                    require mem[_2338 + 96] == mem[_2338 + 124 len 4]
                    if mem[_2338] < _2002:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2338] - _2002
                else:
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1048
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1048
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1199 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1199] == bool(mem[_1199])
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1108
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1108
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1307] == bool(mem[_1307])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1108
                    mem[mem[64] + 100] = _1048
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1108, _1048, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1547 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1547] == mem[_1547]
                    require mem[_1547 + 32] == mem[_1547 + 32]
                    require mem[_1547 + 64] == mem[_1547 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1679 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1715 = mem[_1679]
                    require mem[_1679] == mem[_1679]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1715
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1715
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1811 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1811] == bool(mem[_1811])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1895 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1907 = mem[_1895]
                    require mem[_1895] == mem[_1895]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1991 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2003 = mem[_1991]
                    require mem[_1991] == mem[_1991]
                    require mem[_1991 + 32] == mem[_1991 + 32]
                    require mem[_1991 + 64] == mem[_1991 + 92 len 4]
                    require mem[_1991 + 96] == mem[_1991 + 124 len 4]
                    mem[mem[64] + 4] = _1715
                    mem[mem[64] + 36] = _1907
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1715, _1907, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2267 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2267] == mem[_2267]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2339 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2339] == mem[_2339]
                    require mem[_2339 + 32] == mem[_2339 + 32]
                    require mem[_2339 + 64] == mem[_2339 + 92 len 4]
                    require mem[_2339 + 96] == mem[_2339 + 124 len 4]
                    if mem[_2339] < _2003:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2339] - _2003
            else:
                mem[(7 * ceil32(return_data.size)) + 100] = stor5
                mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(8 * ceil32(return_data.size)) + 96] = 2
                mem[(8 * ceil32(return_data.size)) + 128] = stor2
                mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(8 * ceil32(return_data.size)) + 228] = 0
                mem[(8 * ceil32(return_data.size)) + 260] = 160
                mem[(8 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (8 * ceil32(return_data.size)) + 128
                t = (8 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(8 * ceil32(return_data.size)) + 292] = this.address
                mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (10 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _337 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                _351 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                require _337 + (32 * _351) + 32 <= return_data.size
                idx = 0
                s = (8 * ceil32(return_data.size)) + _337 + 224
                t = (10 * ceil32(return_data.size)) + 224
                while idx < _351:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1031 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1049 = mem[_1031]
                require mem[_1031] == mem[_1031]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1091 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1109 = mem[_1091]
                require mem[_1091] == mem[_1091]
                if address(arg1) == stor3:
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1049
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1049
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1200 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1200] == bool(mem[_1200])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1109
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1109
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1308 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1308] == bool(mem[_1308])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1109
                    mem[mem[64] + 100] = _1049
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1109, _1049, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1548 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1548] == mem[_1548]
                    require mem[_1548 + 32] == mem[_1548 + 32]
                    require mem[_1548 + 64] == mem[_1548 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1680 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1716 = mem[_1680]
                    require mem[_1680] == mem[_1680]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1716
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1716
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1812 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1812] == bool(mem[_1812])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1896 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1908 = mem[_1896]
                    require mem[_1896] == mem[_1896]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1992 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2004 = mem[_1992]
                    require mem[_1992] == mem[_1992]
                    require mem[_1992 + 32] == mem[_1992 + 32]
                    require mem[_1992 + 64] == mem[_1992 + 92 len 4]
                    require mem[_1992 + 96] == mem[_1992 + 124 len 4]
                    mem[mem[64] + 4] = _1716
                    mem[mem[64] + 36] = _1908
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1716, _1908, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2268 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2268] == mem[_2268]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2340 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2340] == mem[_2340]
                    require mem[_2340 + 32] == mem[_2340 + 32]
                    require mem[_2340 + 64] == mem[_2340 + 92 len 4]
                    require mem[_2340 + 96] == mem[_2340 + 124 len 4]
                    if mem[_2340] < _2004:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2340] - _2004
                else:
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1049
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1049
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1201 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1201] == bool(mem[_1201])
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1109
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1109
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1309 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1309] == bool(mem[_1309])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1109
                    mem[mem[64] + 100] = _1049
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1109, _1049, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1549 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1549] == mem[_1549]
                    require mem[_1549 + 32] == mem[_1549 + 32]
                    require mem[_1549 + 64] == mem[_1549 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1681 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1717 = mem[_1681]
                    require mem[_1681] == mem[_1681]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1717
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1717
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1813 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1813] == bool(mem[_1813])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1897 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1909 = mem[_1897]
                    require mem[_1897] == mem[_1897]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1993 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _2005 = mem[_1993]
                    require mem[_1993] == mem[_1993]
                    require mem[_1993 + 32] == mem[_1993 + 32]
                    require mem[_1993 + 64] == mem[_1993 + 92 len 4]
                    require mem[_1993 + 96] == mem[_1993 + 124 len 4]
                    mem[mem[64] + 4] = _1717
                    mem[mem[64] + 36] = _1909
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1717, _1909, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2269 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2269] == mem[_2269]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2341 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2341] == mem[_2341]
                    require mem[_2341 + 32] == mem[_2341 + 32]
                    require mem[_2341 + 64] == mem[_2341 + 92 len 4]
                    require mem[_2341 + 96] == mem[_2341 + 124 len 4]
                    if mem[_2341] < _2005:
                        revert with 'NH{q', 17
                    mem[mem[64]] = mem[_2341] - _2005
        else:
            if ext_call.return_data[12 len 20] == stor2:
                if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor6
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _340 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _354 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    require _340 + (32 * _354) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _340 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _354:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1034 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1052 = mem[_1034]
                    require mem[_1034] == mem[_1034]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1094 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1112 = mem[_1094]
                    require mem[_1094] == mem[_1094]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1052
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1052
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1206 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1206] == bool(mem[_1206])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1112
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1112
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1314 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1314] == bool(mem[_1314])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1112
                        mem[mem[64] + 100] = _1052
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1112, _1052, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1554 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1554] == mem[_1554]
                        require mem[_1554 + 32] == mem[_1554 + 32]
                        require mem[_1554 + 64] == mem[_1554 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1686 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1722 = mem[_1686]
                        require mem[_1686] == mem[_1686]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1722
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1722
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1818 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1818] == bool(mem[_1818])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1902 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1914 = mem[_1902]
                        require mem[_1902] == mem[_1902]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1998 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2010 = mem[_1998]
                        require mem[_1998] == mem[_1998]
                        require mem[_1998 + 32] == mem[_1998 + 32]
                        require mem[_1998 + 64] == mem[_1998 + 92 len 4]
                        require mem[_1998 + 96] == mem[_1998 + 124 len 4]
                        mem[mem[64] + 4] = _1722
                        mem[mem[64] + 36] = _1914
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1722, _1914, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2274 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2274] == mem[_2274]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2346 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2346] == mem[_2346]
                        require mem[_2346 + 32] == mem[_2346 + 32]
                        require mem[_2346 + 64] == mem[_2346 + 92 len 4]
                        require mem[_2346 + 96] == mem[_2346 + 124 len 4]
                        if mem[_2346] < _2010:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2346] - _2010
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1052
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1052
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1207 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1207] == bool(mem[_1207])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1112
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1112
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1315 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1315] == bool(mem[_1315])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1112
                        mem[mem[64] + 100] = _1052
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1112, _1052, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1555 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1555] == mem[_1555]
                        require mem[_1555 + 32] == mem[_1555 + 32]
                        require mem[_1555 + 64] == mem[_1555 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1687 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1723 = mem[_1687]
                        require mem[_1687] == mem[_1687]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1723
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1723
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1819 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1819] == bool(mem[_1819])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1903 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1915 = mem[_1903]
                        require mem[_1903] == mem[_1903]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1999 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2011 = mem[_1999]
                        require mem[_1999] == mem[_1999]
                        require mem[_1999 + 32] == mem[_1999 + 32]
                        require mem[_1999 + 64] == mem[_1999 + 92 len 4]
                        require mem[_1999 + 96] == mem[_1999 + 124 len 4]
                        mem[mem[64] + 4] = _1723
                        mem[mem[64] + 36] = _1915
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1723, _1915, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2275 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2275] == mem[_2275]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2347 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2347] == mem[_2347]
                        require mem[_2347 + 32] == mem[_2347 + 32]
                        require mem[_2347 + 64] == mem[_2347 + 92 len 4]
                        require mem[_2347 + 96] == mem[_2347 + 124 len 4]
                        if mem[_2347] < _2011:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2347] - _2011
                else:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor5
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _341 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _355 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    require _341 + (32 * _355) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _341 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _355:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1035 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1053 = mem[_1035]
                    require mem[_1035] == mem[_1035]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1095 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1113 = mem[_1095]
                    require mem[_1095] == mem[_1095]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1053
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1053
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1208 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1208] == bool(mem[_1208])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1113
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1113
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1316 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1316] == bool(mem[_1316])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1113
                        mem[mem[64] + 100] = _1053
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1113, _1053, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1556 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1556] == mem[_1556]
                        require mem[_1556 + 32] == mem[_1556 + 32]
                        require mem[_1556 + 64] == mem[_1556 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1688 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1724 = mem[_1688]
                        require mem[_1688] == mem[_1688]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1724
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1724
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1820 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1820] == bool(mem[_1820])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1904 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1916 = mem[_1904]
                        require mem[_1904] == mem[_1904]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2000 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2012 = mem[_2000]
                        require mem[_2000] == mem[_2000]
                        require mem[_2000 + 32] == mem[_2000 + 32]
                        require mem[_2000 + 64] == mem[_2000 + 92 len 4]
                        require mem[_2000 + 96] == mem[_2000 + 124 len 4]
                        mem[mem[64] + 4] = _1724
                        mem[mem[64] + 36] = _1916
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1724, _1916, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2276 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2276] == mem[_2276]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2348 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2348] == mem[_2348]
                        require mem[_2348 + 32] == mem[_2348 + 32]
                        require mem[_2348 + 64] == mem[_2348 + 92 len 4]
                        require mem[_2348 + 96] == mem[_2348 + 124 len 4]
                        if mem[_2348] < _2012:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2348] - _2012
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1053
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1053
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1209 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1209] == bool(mem[_1209])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1113
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1113
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1317 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1317] == bool(mem[_1317])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1113
                        mem[mem[64] + 100] = _1053
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1113, _1053, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1557 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1557] == mem[_1557]
                        require mem[_1557 + 32] == mem[_1557 + 32]
                        require mem[_1557 + 64] == mem[_1557 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1689 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1725 = mem[_1689]
                        require mem[_1689] == mem[_1689]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1725
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1725
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1821 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1821] == bool(mem[_1821])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1905 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1917 = mem[_1905]
                        require mem[_1905] == mem[_1905]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2001 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2013 = mem[_2001]
                        require mem[_2001] == mem[_2001]
                        require mem[_2001 + 32] == mem[_2001 + 32]
                        require mem[_2001 + 64] == mem[_2001 + 92 len 4]
                        require mem[_2001 + 96] == mem[_2001 + 124 len 4]
                        mem[mem[64] + 4] = _1725
                        mem[mem[64] + 36] = _1917
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1725, _1917, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2277 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2277] == mem[_2277]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2349 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2349] == mem[_2349]
                        require mem[_2349 + 32] == mem[_2349 + 32]
                        require mem[_2349 + 64] == mem[_2349 + 92 len 4]
                        require mem[_2349 + 96] == mem[_2349 + 124 len 4]
                        if mem[_2349] < _2013:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2349] - _2013
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor6
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _338 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _352 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _338 + (32 * _352) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _338 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _352:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1032 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1050 = mem[_1032]
                    require mem[_1032] == mem[_1032]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1092 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1110 = mem[_1092]
                    require mem[_1092] == mem[_1092]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1050
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1050
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1202 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1202] == bool(mem[_1202])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1110
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1110
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1310 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1310] == bool(mem[_1310])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1110
                        mem[mem[64] + 100] = _1050
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1110, _1050, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1550 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1550] == mem[_1550]
                        require mem[_1550 + 32] == mem[_1550 + 32]
                        require mem[_1550 + 64] == mem[_1550 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1682 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1718 = mem[_1682]
                        require mem[_1682] == mem[_1682]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1718
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1718
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1814 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1814] == bool(mem[_1814])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1898 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1910 = mem[_1898]
                        require mem[_1898] == mem[_1898]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1994 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2006 = mem[_1994]
                        require mem[_1994] == mem[_1994]
                        require mem[_1994 + 32] == mem[_1994 + 32]
                        require mem[_1994 + 64] == mem[_1994 + 92 len 4]
                        require mem[_1994 + 96] == mem[_1994 + 124 len 4]
                        mem[mem[64] + 4] = _1718
                        mem[mem[64] + 36] = _1910
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1718, _1910, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2270 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2270] == mem[_2270]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2342 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2342] == mem[_2342]
                        require mem[_2342 + 32] == mem[_2342 + 32]
                        require mem[_2342 + 64] == mem[_2342 + 92 len 4]
                        require mem[_2342 + 96] == mem[_2342 + 124 len 4]
                        if mem[_2342] < _2006:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2342] - _2006
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1050
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1050
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1203 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1203] == bool(mem[_1203])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1110
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1110
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1311 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1311] == bool(mem[_1311])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1110
                        mem[mem[64] + 100] = _1050
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1110, _1050, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1551 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1551] == mem[_1551]
                        require mem[_1551 + 32] == mem[_1551 + 32]
                        require mem[_1551 + 64] == mem[_1551 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1683 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1719 = mem[_1683]
                        require mem[_1683] == mem[_1683]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1719
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1719
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1815 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1815] == bool(mem[_1815])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1899 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1911 = mem[_1899]
                        require mem[_1899] == mem[_1899]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1995 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2007 = mem[_1995]
                        require mem[_1995] == mem[_1995]
                        require mem[_1995 + 32] == mem[_1995 + 32]
                        require mem[_1995 + 64] == mem[_1995 + 92 len 4]
                        require mem[_1995 + 96] == mem[_1995 + 124 len 4]
                        mem[mem[64] + 4] = _1719
                        mem[mem[64] + 36] = _1911
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1719, _1911, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2271 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2271] == mem[_2271]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2343 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2343] == mem[_2343]
                        require mem[_2343 + 32] == mem[_2343 + 32]
                        require mem[_2343 + 64] == mem[_2343 + 92 len 4]
                        require mem[_2343 + 96] == mem[_2343 + 124 len 4]
                        if mem[_2343] < _2007:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2343] - _2007
                else:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor5
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _339 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _353 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _339 + (32 * _353) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _339 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _353:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1033 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1051 = mem[_1033]
                    require mem[_1033] == mem[_1033]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1093 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1111 = mem[_1093]
                    require mem[_1093] == mem[_1093]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1051
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1051
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1204 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1204] == bool(mem[_1204])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1111
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1111
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1312 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1312] == bool(mem[_1312])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1111
                        mem[mem[64] + 100] = _1051
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1111, _1051, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1552 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1552] == mem[_1552]
                        require mem[_1552 + 32] == mem[_1552 + 32]
                        require mem[_1552 + 64] == mem[_1552 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1684 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1720 = mem[_1684]
                        require mem[_1684] == mem[_1684]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1720
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1720
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1816 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1816] == bool(mem[_1816])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1900 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1912 = mem[_1900]
                        require mem[_1900] == mem[_1900]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1996 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2008 = mem[_1996]
                        require mem[_1996] == mem[_1996]
                        require mem[_1996 + 32] == mem[_1996 + 32]
                        require mem[_1996 + 64] == mem[_1996 + 92 len 4]
                        require mem[_1996 + 96] == mem[_1996 + 124 len 4]
                        mem[mem[64] + 4] = _1720
                        mem[mem[64] + 36] = _1912
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1720, _1912, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2272 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2272] == mem[_2272]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2344 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2344] == mem[_2344]
                        require mem[_2344 + 32] == mem[_2344 + 32]
                        require mem[_2344 + 64] == mem[_2344 + 92 len 4]
                        require mem[_2344 + 96] == mem[_2344 + 124 len 4]
                        if mem[_2344] < _2008:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2344] - _2008
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1051
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1051
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1205 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1205] == bool(mem[_1205])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1111
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1111
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1313 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1313] == bool(mem[_1313])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1111
                        mem[mem[64] + 100] = _1051
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1111, _1051, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1553 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1553] == mem[_1553]
                        require mem[_1553 + 32] == mem[_1553 + 32]
                        require mem[_1553 + 64] == mem[_1553 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1685 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1721 = mem[_1685]
                        require mem[_1685] == mem[_1685]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1721
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1721
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1817 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1817] == bool(mem[_1817])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1901 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1913 = mem[_1901]
                        require mem[_1901] == mem[_1901]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1997 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2009 = mem[_1997]
                        require mem[_1997] == mem[_1997]
                        require mem[_1997 + 32] == mem[_1997 + 32]
                        require mem[_1997 + 64] == mem[_1997 + 92 len 4]
                        require mem[_1997 + 96] == mem[_1997 + 124 len 4]
                        mem[mem[64] + 4] = _1721
                        mem[mem[64] + 36] = _1913
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1721, _1913, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2273 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2273] == mem[_2273]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2345 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2345] == mem[_2345]
                        require mem[_2345 + 32] == mem[_2345 + 32]
                        require mem[_2345 + 64] == mem[_2345 + 92 len 4]
                        require mem[_2345 + 96] == mem[_2345 + 124 len 4]
                        if mem[_2345] < _2009:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_2345] - _2009
    else:
        if arg2 < ext_call.return_data[0]:
            revert with 'NH{q', 17
        mem[ceil32(return_data.size) + 100] = msg.sender
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = this.address
        if ext_call.return_data[0] >= arg2 - ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + 164] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg2 - ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, arg2 - ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args arg2 - ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[0] = address(arg1)
            mem[32] = 11
            require stor11[address(arg1)]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[(6 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) != address(arg1):
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor6
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1036 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1054 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1036 + (32 * _1054) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1036 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1054:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1846 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1858 = mem[_1846]
                    require mem[_1846] == mem[_1846]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1954 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1966 = mem[_1954]
                    require mem[_1954] == mem[_1954]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1858
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1858
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2086 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2086] == bool(mem[_2086])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1966
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1966
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2206 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2206] == bool(mem[_2206])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1966
                        mem[mem[64] + 100] = _1858
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1966, _1858, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2422 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2422] == mem[_2422]
                        require mem[_2422 + 32] == mem[_2422 + 32]
                        require mem[_2422 + 64] == mem[_2422 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2614 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2638 = mem[_2614]
                        require mem[_2614] == mem[_2614]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2638
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2638
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2734] == bool(mem[_2734])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2830 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2854 = mem[_2830]
                        require mem[_2830] == mem[_2830]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2926 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2950 = mem[_2926]
                        require mem[_2926] == mem[_2926]
                        require mem[_2926 + 32] == mem[_2926 + 32]
                        require mem[_2926 + 64] == mem[_2926 + 92 len 4]
                        require mem[_2926 + 96] == mem[_2926 + 124 len 4]
                        mem[mem[64] + 4] = _2638
                        mem[mem[64] + 36] = _2854
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2638, _2854, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3094 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3094] == mem[_3094]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3190 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3190] == mem[_3190]
                        require mem[_3190 + 32] == mem[_3190 + 32]
                        require mem[_3190 + 64] == mem[_3190 + 92 len 4]
                        require mem[_3190 + 96] == mem[_3190 + 124 len 4]
                        if mem[_3190] < _2950:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3190] - _2950
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1858
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1858
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2087 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2087] == bool(mem[_2087])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1966
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1966
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2207 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2207] == bool(mem[_2207])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1966
                        mem[mem[64] + 100] = _1858
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1966, _1858, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2423 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2423] == mem[_2423]
                        require mem[_2423 + 32] == mem[_2423 + 32]
                        require mem[_2423 + 64] == mem[_2423 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2615 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2639 = mem[_2615]
                        require mem[_2615] == mem[_2615]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2639
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2639
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2735 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2735] == bool(mem[_2735])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2831 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2855 = mem[_2831]
                        require mem[_2831] == mem[_2831]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2927 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2951 = mem[_2927]
                        require mem[_2927] == mem[_2927]
                        require mem[_2927 + 32] == mem[_2927 + 32]
                        require mem[_2927 + 64] == mem[_2927 + 92 len 4]
                        require mem[_2927 + 96] == mem[_2927 + 124 len 4]
                        mem[mem[64] + 4] = _2639
                        mem[mem[64] + 36] = _2855
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2639, _2855, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3095 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3095] == mem[_3095]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3191 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3191] == mem[_3191]
                        require mem[_3191 + 32] == mem[_3191 + 32]
                        require mem[_3191 + 64] == mem[_3191 + 92 len 4]
                        require mem[_3191 + 96] == mem[_3191 + 124 len 4]
                        if mem[_3191] < _2951:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3191] - _2951
                else:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor5
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1037 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1055 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1037 + (32 * _1055) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1037 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1055:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1847 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1859 = mem[_1847]
                    require mem[_1847] == mem[_1847]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1967 = mem[_1955]
                    require mem[_1955] == mem[_1955]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1859
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1859
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2088 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2088] == bool(mem[_2088])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1967
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1967
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2208 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2208] == bool(mem[_2208])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1967
                        mem[mem[64] + 100] = _1859
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1967, _1859, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2424 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2424] == mem[_2424]
                        require mem[_2424 + 32] == mem[_2424 + 32]
                        require mem[_2424 + 64] == mem[_2424 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2616 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2640 = mem[_2616]
                        require mem[_2616] == mem[_2616]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2640
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2640
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2736 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2736] == bool(mem[_2736])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2832 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2856 = mem[_2832]
                        require mem[_2832] == mem[_2832]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2952 = mem[_2928]
                        require mem[_2928] == mem[_2928]
                        require mem[_2928 + 32] == mem[_2928 + 32]
                        require mem[_2928 + 64] == mem[_2928 + 92 len 4]
                        require mem[_2928 + 96] == mem[_2928 + 124 len 4]
                        mem[mem[64] + 4] = _2640
                        mem[mem[64] + 36] = _2856
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2640, _2856, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3096 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3096] == mem[_3096]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3192 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3192] == mem[_3192]
                        require mem[_3192 + 32] == mem[_3192 + 32]
                        require mem[_3192 + 64] == mem[_3192 + 92 len 4]
                        require mem[_3192 + 96] == mem[_3192 + 124 len 4]
                        if mem[_3192] < _2952:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3192] - _2952
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1859
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1859
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2089 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2089] == bool(mem[_2089])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1967
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1967
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2209 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2209] == bool(mem[_2209])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1967
                        mem[mem[64] + 100] = _1859
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1967, _1859, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2425 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2425] == mem[_2425]
                        require mem[_2425 + 32] == mem[_2425 + 32]
                        require mem[_2425 + 64] == mem[_2425 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2617 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2641 = mem[_2617]
                        require mem[_2617] == mem[_2617]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2641
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2641
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2737 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2737] == bool(mem[_2737])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2833 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2857 = mem[_2833]
                        require mem[_2833] == mem[_2833]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2953 = mem[_2929]
                        require mem[_2929] == mem[_2929]
                        require mem[_2929 + 32] == mem[_2929 + 32]
                        require mem[_2929 + 64] == mem[_2929 + 92 len 4]
                        require mem[_2929 + 96] == mem[_2929 + 124 len 4]
                        mem[mem[64] + 4] = _2641
                        mem[mem[64] + 36] = _2857
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2641, _2857, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3097 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3097] == mem[_3097]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3193 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3193] == mem[_3193]
                        require mem[_3193 + 32] == mem[_3193 + 32]
                        require mem[_3193 + 64] == mem[_3193 + 92 len 4]
                        require mem[_3193 + 96] == mem[_3193 + 124 len 4]
                        if mem[_3193] < _2953:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3193] - _2953
            else:
                if ext_call.return_data[12 len 20] == stor2:
                    if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1040 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1058 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1040 + (32 * _1058) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1040 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1058:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1850 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1862 = mem[_1850]
                        require mem[_1850] == mem[_1850]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1958 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1970 = mem[_1958]
                        require mem[_1958] == mem[_1958]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1862
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1862
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2094 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2094] == bool(mem[_2094])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1970
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1970
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2214 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2214] == bool(mem[_2214])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1970
                            mem[mem[64] + 100] = _1862
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1970, _1862, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2430 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2430] == mem[_2430]
                            require mem[_2430 + 32] == mem[_2430 + 32]
                            require mem[_2430 + 64] == mem[_2430 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2622 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2646 = mem[_2622]
                            require mem[_2622] == mem[_2622]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2646
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2646
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2742 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2742] == bool(mem[_2742])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2838 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2862 = mem[_2838]
                            require mem[_2838] == mem[_2838]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2934 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2958 = mem[_2934]
                            require mem[_2934] == mem[_2934]
                            require mem[_2934 + 32] == mem[_2934 + 32]
                            require mem[_2934 + 64] == mem[_2934 + 92 len 4]
                            require mem[_2934 + 96] == mem[_2934 + 124 len 4]
                            mem[mem[64] + 4] = _2646
                            mem[mem[64] + 36] = _2862
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2646, _2862, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3102 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3102] == mem[_3102]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3198 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3198] == mem[_3198]
                            require mem[_3198 + 32] == mem[_3198 + 32]
                            require mem[_3198 + 64] == mem[_3198 + 92 len 4]
                            require mem[_3198 + 96] == mem[_3198 + 124 len 4]
                            if mem[_3198] < _2958:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3198] - _2958
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1862
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1862
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2095 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2095] == bool(mem[_2095])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1970
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1970
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2215 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2215] == bool(mem[_2215])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1970
                            mem[mem[64] + 100] = _1862
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1970, _1862, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2431 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2431] == mem[_2431]
                            require mem[_2431 + 32] == mem[_2431 + 32]
                            require mem[_2431 + 64] == mem[_2431 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2623 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2647 = mem[_2623]
                            require mem[_2623] == mem[_2623]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2647
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2647
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2743 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2743] == bool(mem[_2743])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2839 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2863 = mem[_2839]
                            require mem[_2839] == mem[_2839]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2935 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2959 = mem[_2935]
                            require mem[_2935] == mem[_2935]
                            require mem[_2935 + 32] == mem[_2935 + 32]
                            require mem[_2935 + 64] == mem[_2935 + 92 len 4]
                            require mem[_2935 + 96] == mem[_2935 + 124 len 4]
                            mem[mem[64] + 4] = _2647
                            mem[mem[64] + 36] = _2863
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2647, _2863, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3103 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3103] == mem[_3103]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3199 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3199] == mem[_3199]
                            require mem[_3199 + 32] == mem[_3199 + 32]
                            require mem[_3199 + 64] == mem[_3199 + 92 len 4]
                            require mem[_3199 + 96] == mem[_3199 + 124 len 4]
                            if mem[_3199] < _2959:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3199] - _2959
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1041 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1059 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1041 + (32 * _1059) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1041 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1059:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1851 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1863 = mem[_1851]
                        require mem[_1851] == mem[_1851]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1971 = mem[_1959]
                        require mem[_1959] == mem[_1959]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1863
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1863
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2096 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2096] == bool(mem[_2096])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1971
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1971
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2216 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2216] == bool(mem[_2216])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1971
                            mem[mem[64] + 100] = _1863
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1971, _1863, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2432 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2432] == mem[_2432]
                            require mem[_2432 + 32] == mem[_2432 + 32]
                            require mem[_2432 + 64] == mem[_2432 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2624 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2648 = mem[_2624]
                            require mem[_2624] == mem[_2624]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2648
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2648
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2744 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2744] == bool(mem[_2744])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2840 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2864 = mem[_2840]
                            require mem[_2840] == mem[_2840]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2936 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2960 = mem[_2936]
                            require mem[_2936] == mem[_2936]
                            require mem[_2936 + 32] == mem[_2936 + 32]
                            require mem[_2936 + 64] == mem[_2936 + 92 len 4]
                            require mem[_2936 + 96] == mem[_2936 + 124 len 4]
                            mem[mem[64] + 4] = _2648
                            mem[mem[64] + 36] = _2864
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2648, _2864, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3104 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3104] == mem[_3104]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3200 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3200] == mem[_3200]
                            require mem[_3200 + 32] == mem[_3200 + 32]
                            require mem[_3200 + 64] == mem[_3200 + 92 len 4]
                            require mem[_3200 + 96] == mem[_3200 + 124 len 4]
                            if mem[_3200] < _2960:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3200] - _2960
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1863
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1863
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2097 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2097] == bool(mem[_2097])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1971
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1971
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2217 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2217] == bool(mem[_2217])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1971
                            mem[mem[64] + 100] = _1863
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1971, _1863, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2433 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2433] == mem[_2433]
                            require mem[_2433 + 32] == mem[_2433 + 32]
                            require mem[_2433 + 64] == mem[_2433 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2625 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2649 = mem[_2625]
                            require mem[_2625] == mem[_2625]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2649
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2649
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2745 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2745] == bool(mem[_2745])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2841 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2865 = mem[_2841]
                            require mem[_2841] == mem[_2841]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2937 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2961 = mem[_2937]
                            require mem[_2937] == mem[_2937]
                            require mem[_2937 + 32] == mem[_2937 + 32]
                            require mem[_2937 + 64] == mem[_2937 + 92 len 4]
                            require mem[_2937 + 96] == mem[_2937 + 124 len 4]
                            mem[mem[64] + 4] = _2649
                            mem[mem[64] + 36] = _2865
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2649, _2865, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3105 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3105] == mem[_3105]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3201 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3201] == mem[_3201]
                            require mem[_3201 + 32] == mem[_3201 + 32]
                            require mem[_3201 + 64] == mem[_3201 + 92 len 4]
                            require mem[_3201 + 96] == mem[_3201 + 124 len 4]
                            if mem[_3201] < _2961:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3201] - _2961
                else:
                    if ext_call.return_data[12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(ext_call.return_data[0]) != stor2:
                        revert with 0, 'bad LP token'
                    if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1038 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1056 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1038 + (32 * _1056) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1038 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1056:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1848 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1860 = mem[_1848]
                        require mem[_1848] == mem[_1848]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1956 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1968 = mem[_1956]
                        require mem[_1956] == mem[_1956]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1860
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1860
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2090 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2090] == bool(mem[_2090])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1968
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1968
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2210 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2210] == bool(mem[_2210])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1968
                            mem[mem[64] + 100] = _1860
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1968, _1860, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2426 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2426] == mem[_2426]
                            require mem[_2426 + 32] == mem[_2426 + 32]
                            require mem[_2426 + 64] == mem[_2426 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2618 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2642 = mem[_2618]
                            require mem[_2618] == mem[_2618]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2642
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2642
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2738 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2738] == bool(mem[_2738])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2834 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2858 = mem[_2834]
                            require mem[_2834] == mem[_2834]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2930 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2954 = mem[_2930]
                            require mem[_2930] == mem[_2930]
                            require mem[_2930 + 32] == mem[_2930 + 32]
                            require mem[_2930 + 64] == mem[_2930 + 92 len 4]
                            require mem[_2930 + 96] == mem[_2930 + 124 len 4]
                            mem[mem[64] + 4] = _2642
                            mem[mem[64] + 36] = _2858
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2642, _2858, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3098 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3098] == mem[_3098]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3194 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3194] == mem[_3194]
                            require mem[_3194 + 32] == mem[_3194 + 32]
                            require mem[_3194 + 64] == mem[_3194 + 92 len 4]
                            require mem[_3194 + 96] == mem[_3194 + 124 len 4]
                            if mem[_3194] < _2954:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3194] - _2954
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1860
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1860
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2091 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2091] == bool(mem[_2091])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1968
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1968
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2211 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2211] == bool(mem[_2211])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1968
                            mem[mem[64] + 100] = _1860
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1968, _1860, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2427 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2427] == mem[_2427]
                            require mem[_2427 + 32] == mem[_2427 + 32]
                            require mem[_2427 + 64] == mem[_2427 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2619 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2643 = mem[_2619]
                            require mem[_2619] == mem[_2619]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2643
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2643
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2739 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2739] == bool(mem[_2739])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2835 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2859 = mem[_2835]
                            require mem[_2835] == mem[_2835]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2931 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2955 = mem[_2931]
                            require mem[_2931] == mem[_2931]
                            require mem[_2931 + 32] == mem[_2931 + 32]
                            require mem[_2931 + 64] == mem[_2931 + 92 len 4]
                            require mem[_2931 + 96] == mem[_2931 + 124 len 4]
                            mem[mem[64] + 4] = _2643
                            mem[mem[64] + 36] = _2859
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2643, _2859, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3099 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3099] == mem[_3099]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3195 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3195] == mem[_3195]
                            require mem[_3195 + 32] == mem[_3195 + 32]
                            require mem[_3195 + 64] == mem[_3195 + 92 len 4]
                            require mem[_3195 + 96] == mem[_3195 + 124 len 4]
                            if mem[_3195] < _2955:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3195] - _2955
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1039 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1057 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1039 + (32 * _1057) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1039 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1057:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1849 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1861 = mem[_1849]
                        require mem[_1849] == mem[_1849]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1957 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1969 = mem[_1957]
                        require mem[_1957] == mem[_1957]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1861
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1861
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2092 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2092] == bool(mem[_2092])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1969
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1969
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2212 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2212] == bool(mem[_2212])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1969
                            mem[mem[64] + 100] = _1861
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1969, _1861, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2428 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2428] == mem[_2428]
                            require mem[_2428 + 32] == mem[_2428 + 32]
                            require mem[_2428 + 64] == mem[_2428 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2620 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2644 = mem[_2620]
                            require mem[_2620] == mem[_2620]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2644
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2644
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2740 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2740] == bool(mem[_2740])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2836 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2860 = mem[_2836]
                            require mem[_2836] == mem[_2836]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2932 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2956 = mem[_2932]
                            require mem[_2932] == mem[_2932]
                            require mem[_2932 + 32] == mem[_2932 + 32]
                            require mem[_2932 + 64] == mem[_2932 + 92 len 4]
                            require mem[_2932 + 96] == mem[_2932 + 124 len 4]
                            mem[mem[64] + 4] = _2644
                            mem[mem[64] + 36] = _2860
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2644, _2860, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3100 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3100] == mem[_3100]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3196 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3196] == mem[_3196]
                            require mem[_3196 + 32] == mem[_3196 + 32]
                            require mem[_3196 + 64] == mem[_3196 + 92 len 4]
                            require mem[_3196 + 96] == mem[_3196 + 124 len 4]
                            if mem[_3196] < _2956:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3196] - _2956
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1861
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1861
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2093 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2093] == bool(mem[_2093])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1969
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1969
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2213 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2213] == bool(mem[_2213])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1969
                            mem[mem[64] + 100] = _1861
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1969, _1861, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2429 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2429] == mem[_2429]
                            require mem[_2429 + 32] == mem[_2429 + 32]
                            require mem[_2429 + 64] == mem[_2429 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2621 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2645 = mem[_2621]
                            require mem[_2621] == mem[_2621]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2645
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2645
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2741 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2741] == bool(mem[_2741])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2837 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2861 = mem[_2837]
                            require mem[_2837] == mem[_2837]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2933 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2957 = mem[_2933]
                            require mem[_2933] == mem[_2933]
                            require mem[_2933 + 32] == mem[_2933 + 32]
                            require mem[_2933 + 64] == mem[_2933 + 92 len 4]
                            require mem[_2933 + 96] == mem[_2933 + 124 len 4]
                            mem[mem[64] + 4] = _2645
                            mem[mem[64] + 36] = _2861
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2645, _2861, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3101 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3101] == mem[_3101]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3197 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3197] == mem[_3197]
                            require mem[_3197 + 32] == mem[_3197 + 32]
                            require mem[_3197 + 64] == mem[_3197 + 92 len 4]
                            require mem[_3197 + 96] == mem[_3197 + 124 len 4]
                            if mem[_3197] < _2957:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3197] - _2957
        else:
            mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[0] = address(arg1)
            mem[32] = 11
            require stor11[address(arg1)]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[(6 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) != address(arg1):
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor6
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1042 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1060 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1042 + (32 * _1060) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1042 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1060:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1852 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1864 = mem[_1852]
                    require mem[_1852] == mem[_1852]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1972 = mem[_1960]
                    require mem[_1960] == mem[_1960]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1864
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1864
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2098 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2098] == bool(mem[_2098])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1972
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1972
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2218 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2218] == bool(mem[_2218])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1972
                        mem[mem[64] + 100] = _1864
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1972, _1864, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2434 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2434] == mem[_2434]
                        require mem[_2434 + 32] == mem[_2434 + 32]
                        require mem[_2434 + 64] == mem[_2434 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2626 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2650 = mem[_2626]
                        require mem[_2626] == mem[_2626]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2650
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2650
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2746 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2746] == bool(mem[_2746])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2842 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2866 = mem[_2842]
                        require mem[_2842] == mem[_2842]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2938 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2962 = mem[_2938]
                        require mem[_2938] == mem[_2938]
                        require mem[_2938 + 32] == mem[_2938 + 32]
                        require mem[_2938 + 64] == mem[_2938 + 92 len 4]
                        require mem[_2938 + 96] == mem[_2938 + 124 len 4]
                        mem[mem[64] + 4] = _2650
                        mem[mem[64] + 36] = _2866
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2650, _2866, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3106 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3106] == mem[_3106]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3202 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3202] == mem[_3202]
                        require mem[_3202 + 32] == mem[_3202 + 32]
                        require mem[_3202 + 64] == mem[_3202 + 92 len 4]
                        require mem[_3202 + 96] == mem[_3202 + 124 len 4]
                        if mem[_3202] < _2962:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3202] - _2962
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1864
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1864
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2099 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2099] == bool(mem[_2099])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1972
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1972
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2219 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2219] == bool(mem[_2219])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1972
                        mem[mem[64] + 100] = _1864
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1972, _1864, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2435 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2435] == mem[_2435]
                        require mem[_2435 + 32] == mem[_2435 + 32]
                        require mem[_2435 + 64] == mem[_2435 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2627 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2651 = mem[_2627]
                        require mem[_2627] == mem[_2627]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2651
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2651
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2747 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2747] == bool(mem[_2747])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2843 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2867 = mem[_2843]
                        require mem[_2843] == mem[_2843]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2963 = mem[_2939]
                        require mem[_2939] == mem[_2939]
                        require mem[_2939 + 32] == mem[_2939 + 32]
                        require mem[_2939 + 64] == mem[_2939 + 92 len 4]
                        require mem[_2939 + 96] == mem[_2939 + 124 len 4]
                        mem[mem[64] + 4] = _2651
                        mem[mem[64] + 36] = _2867
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2651, _2867, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3107 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3107] == mem[_3107]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3203 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3203] == mem[_3203]
                        require mem[_3203 + 32] == mem[_3203 + 32]
                        require mem[_3203 + 64] == mem[_3203 + 92 len 4]
                        require mem[_3203 + 96] == mem[_3203 + 124 len 4]
                        if mem[_3203] < _2963:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3203] - _2963
                else:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor5
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1043 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1061 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1043 + (32 * _1061) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1043 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1061:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1853 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1865 = mem[_1853]
                    require mem[_1853] == mem[_1853]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1973 = mem[_1961]
                    require mem[_1961] == mem[_1961]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1865
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1865
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2100 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2100] == bool(mem[_2100])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1973
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1973
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2220] == bool(mem[_2220])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1973
                        mem[mem[64] + 100] = _1865
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1973, _1865, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2436 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2436] == mem[_2436]
                        require mem[_2436 + 32] == mem[_2436 + 32]
                        require mem[_2436 + 64] == mem[_2436 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2628 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2652 = mem[_2628]
                        require mem[_2628] == mem[_2628]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2652
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2652
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2748 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2748] == bool(mem[_2748])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2844 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2868 = mem[_2844]
                        require mem[_2844] == mem[_2844]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2940 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2964 = mem[_2940]
                        require mem[_2940] == mem[_2940]
                        require mem[_2940 + 32] == mem[_2940 + 32]
                        require mem[_2940 + 64] == mem[_2940 + 92 len 4]
                        require mem[_2940 + 96] == mem[_2940 + 124 len 4]
                        mem[mem[64] + 4] = _2652
                        mem[mem[64] + 36] = _2868
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2652, _2868, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3108 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3108] == mem[_3108]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3204 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3204] == mem[_3204]
                        require mem[_3204 + 32] == mem[_3204 + 32]
                        require mem[_3204 + 64] == mem[_3204 + 92 len 4]
                        require mem[_3204 + 96] == mem[_3204 + 124 len 4]
                        if mem[_3204] < _2964:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3204] - _2964
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1865
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1865
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2101 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2101] == bool(mem[_2101])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1973
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1973
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2221 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2221] == bool(mem[_2221])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1973
                        mem[mem[64] + 100] = _1865
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1973, _1865, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2437 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2437] == mem[_2437]
                        require mem[_2437 + 32] == mem[_2437 + 32]
                        require mem[_2437 + 64] == mem[_2437 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2629 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2653 = mem[_2629]
                        require mem[_2629] == mem[_2629]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2653
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2653
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2749 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2749] == bool(mem[_2749])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2845 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2869 = mem[_2845]
                        require mem[_2845] == mem[_2845]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2965 = mem[_2941]
                        require mem[_2941] == mem[_2941]
                        require mem[_2941 + 32] == mem[_2941 + 32]
                        require mem[_2941 + 64] == mem[_2941 + 92 len 4]
                        require mem[_2941 + 96] == mem[_2941 + 124 len 4]
                        mem[mem[64] + 4] = _2653
                        mem[mem[64] + 36] = _2869
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2653, _2869, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3109 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3109] == mem[_3109]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3205 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3205] == mem[_3205]
                        require mem[_3205 + 32] == mem[_3205 + 32]
                        require mem[_3205 + 64] == mem[_3205 + 92 len 4]
                        require mem[_3205 + 96] == mem[_3205 + 124 len 4]
                        if mem[_3205] < _2965:
                            revert with 'NH{q', 17
                        mem[mem[64]] = mem[_3205] - _2965
            else:
                if ext_call.return_data[12 len 20] == stor2:
                    if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1046 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1064 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1046 + (32 * _1064) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1046 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1064:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1856 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1868 = mem[_1856]
                        require mem[_1856] == mem[_1856]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1964 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1976 = mem[_1964]
                        require mem[_1964] == mem[_1964]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1868
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1868
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2106 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2106] == bool(mem[_2106])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1976
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1976
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2226 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2226] == bool(mem[_2226])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1976
                            mem[mem[64] + 100] = _1868
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1976, _1868, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2442 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2442] == mem[_2442]
                            require mem[_2442 + 32] == mem[_2442 + 32]
                            require mem[_2442 + 64] == mem[_2442 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2634 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2658 = mem[_2634]
                            require mem[_2634] == mem[_2634]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2658
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2658
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2754 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2754] == bool(mem[_2754])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2850 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2874 = mem[_2850]
                            require mem[_2850] == mem[_2850]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2946 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2970 = mem[_2946]
                            require mem[_2946] == mem[_2946]
                            require mem[_2946 + 32] == mem[_2946 + 32]
                            require mem[_2946 + 64] == mem[_2946 + 92 len 4]
                            require mem[_2946 + 96] == mem[_2946 + 124 len 4]
                            mem[mem[64] + 4] = _2658
                            mem[mem[64] + 36] = _2874
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2658, _2874, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3114 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3114] == mem[_3114]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3210 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3210] == mem[_3210]
                            require mem[_3210 + 32] == mem[_3210 + 32]
                            require mem[_3210 + 64] == mem[_3210 + 92 len 4]
                            require mem[_3210 + 96] == mem[_3210 + 124 len 4]
                            if mem[_3210] < _2970:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3210] - _2970
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1868
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1868
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2107 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2107] == bool(mem[_2107])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1976
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1976
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2227 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2227] == bool(mem[_2227])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1976
                            mem[mem[64] + 100] = _1868
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1976, _1868, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2443 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2443] == mem[_2443]
                            require mem[_2443 + 32] == mem[_2443 + 32]
                            require mem[_2443 + 64] == mem[_2443 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2635 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2659 = mem[_2635]
                            require mem[_2635] == mem[_2635]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2659
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2659
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2755 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2755] == bool(mem[_2755])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2851 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2875 = mem[_2851]
                            require mem[_2851] == mem[_2851]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2947 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2971 = mem[_2947]
                            require mem[_2947] == mem[_2947]
                            require mem[_2947 + 32] == mem[_2947 + 32]
                            require mem[_2947 + 64] == mem[_2947 + 92 len 4]
                            require mem[_2947 + 96] == mem[_2947 + 124 len 4]
                            mem[mem[64] + 4] = _2659
                            mem[mem[64] + 36] = _2875
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2659, _2875, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3115 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3115] == mem[_3115]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3211 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3211] == mem[_3211]
                            require mem[_3211 + 32] == mem[_3211 + 32]
                            require mem[_3211 + 64] == mem[_3211 + 92 len 4]
                            require mem[_3211 + 96] == mem[_3211 + 124 len 4]
                            if mem[_3211] < _2971:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3211] - _2971
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1047 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1065 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1047 + (32 * _1065) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1047 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1065:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1857 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1869 = mem[_1857]
                        require mem[_1857] == mem[_1857]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1965 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1977 = mem[_1965]
                        require mem[_1965] == mem[_1965]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1869
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1869
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2108 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2108] == bool(mem[_2108])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1977
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1977
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2228 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2228] == bool(mem[_2228])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1977
                            mem[mem[64] + 100] = _1869
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1977, _1869, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2444 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2444] == mem[_2444]
                            require mem[_2444 + 32] == mem[_2444 + 32]
                            require mem[_2444 + 64] == mem[_2444 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2636 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2660 = mem[_2636]
                            require mem[_2636] == mem[_2636]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2660
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2660
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2756 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2756] == bool(mem[_2756])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2852 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2876 = mem[_2852]
                            require mem[_2852] == mem[_2852]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2948 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2972 = mem[_2948]
                            require mem[_2948] == mem[_2948]
                            require mem[_2948 + 32] == mem[_2948 + 32]
                            require mem[_2948 + 64] == mem[_2948 + 92 len 4]
                            require mem[_2948 + 96] == mem[_2948 + 124 len 4]
                            mem[mem[64] + 4] = _2660
                            mem[mem[64] + 36] = _2876
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2660, _2876, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3116 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3116] == mem[_3116]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3212 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3212] == mem[_3212]
                            require mem[_3212 + 32] == mem[_3212 + 32]
                            require mem[_3212 + 64] == mem[_3212 + 92 len 4]
                            require mem[_3212 + 96] == mem[_3212 + 124 len 4]
                            if mem[_3212] < _2972:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3212] - _2972
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1869
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1869
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2109 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2109] == bool(mem[_2109])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1977
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1977
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2229 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2229] == bool(mem[_2229])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1977
                            mem[mem[64] + 100] = _1869
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1977, _1869, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2445 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2445] == mem[_2445]
                            require mem[_2445 + 32] == mem[_2445 + 32]
                            require mem[_2445 + 64] == mem[_2445 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2637 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2661 = mem[_2637]
                            require mem[_2637] == mem[_2637]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2661
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2661
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2757 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2757] == bool(mem[_2757])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2853 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2877 = mem[_2853]
                            require mem[_2853] == mem[_2853]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2949 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2973 = mem[_2949]
                            require mem[_2949] == mem[_2949]
                            require mem[_2949 + 32] == mem[_2949 + 32]
                            require mem[_2949 + 64] == mem[_2949 + 92 len 4]
                            require mem[_2949 + 96] == mem[_2949 + 124 len 4]
                            mem[mem[64] + 4] = _2661
                            mem[mem[64] + 36] = _2877
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2661, _2877, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3117 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3117] == mem[_3117]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3213 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3213] == mem[_3213]
                            require mem[_3213 + 32] == mem[_3213 + 32]
                            require mem[_3213 + 64] == mem[_3213 + 92 len 4]
                            require mem[_3213 + 96] == mem[_3213 + 124 len 4]
                            if mem[_3213] < _2973:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3213] - _2973
                else:
                    if ext_call.return_data[12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(ext_call.return_data[0]) != stor2:
                        revert with 0, 'bad LP token'
                    if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1044 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1062 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1044 + (32 * _1062) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1044 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1062:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1854 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1866 = mem[_1854]
                        require mem[_1854] == mem[_1854]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1962 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1974 = mem[_1962]
                        require mem[_1962] == mem[_1962]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1866
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1866
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2102 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2102] == bool(mem[_2102])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1974
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1974
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2222 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2222] == bool(mem[_2222])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1974
                            mem[mem[64] + 100] = _1866
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1974, _1866, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2438 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2438] == mem[_2438]
                            require mem[_2438 + 32] == mem[_2438 + 32]
                            require mem[_2438 + 64] == mem[_2438 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2630 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2654 = mem[_2630]
                            require mem[_2630] == mem[_2630]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2654
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2654
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2750 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2750] == bool(mem[_2750])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2846 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2870 = mem[_2846]
                            require mem[_2846] == mem[_2846]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2942 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2966 = mem[_2942]
                            require mem[_2942] == mem[_2942]
                            require mem[_2942 + 32] == mem[_2942 + 32]
                            require mem[_2942 + 64] == mem[_2942 + 92 len 4]
                            require mem[_2942 + 96] == mem[_2942 + 124 len 4]
                            mem[mem[64] + 4] = _2654
                            mem[mem[64] + 36] = _2870
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2654, _2870, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3110 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3110] == mem[_3110]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3206 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3206] == mem[_3206]
                            require mem[_3206 + 32] == mem[_3206 + 32]
                            require mem[_3206 + 64] == mem[_3206 + 92 len 4]
                            require mem[_3206 + 96] == mem[_3206 + 124 len 4]
                            if mem[_3206] < _2966:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3206] - _2966
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1866
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1866
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2103 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2103] == bool(mem[_2103])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1974
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1974
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2223 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2223] == bool(mem[_2223])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1974
                            mem[mem[64] + 100] = _1866
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1974, _1866, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2439 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2439] == mem[_2439]
                            require mem[_2439 + 32] == mem[_2439 + 32]
                            require mem[_2439 + 64] == mem[_2439 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2631 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2655 = mem[_2631]
                            require mem[_2631] == mem[_2631]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2655
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2655
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2751 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2751] == bool(mem[_2751])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2847 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2871 = mem[_2847]
                            require mem[_2847] == mem[_2847]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2943 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2967 = mem[_2943]
                            require mem[_2943] == mem[_2943]
                            require mem[_2943 + 32] == mem[_2943 + 32]
                            require mem[_2943 + 64] == mem[_2943 + 92 len 4]
                            require mem[_2943 + 96] == mem[_2943 + 124 len 4]
                            mem[mem[64] + 4] = _2655
                            mem[mem[64] + 36] = _2871
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2655, _2871, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3111 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3111] == mem[_3111]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3207 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3207] == mem[_3207]
                            require mem[_3207 + 32] == mem[_3207 + 32]
                            require mem[_3207 + 64] == mem[_3207 + 92 len 4]
                            require mem[_3207 + 96] == mem[_3207 + 124 len 4]
                            if mem[_3207] < _2967:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3207] - _2967
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1045 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1063 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1045 + (32 * _1063) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1045 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1063:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1855 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1867 = mem[_1855]
                        require mem[_1855] == mem[_1855]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1963 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1975 = mem[_1963]
                        require mem[_1963] == mem[_1963]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1867
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1867
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2104 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2104] == bool(mem[_2104])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1975
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1975
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2224 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2224] == bool(mem[_2224])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1975
                            mem[mem[64] + 100] = _1867
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1975, _1867, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2440 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2440] == mem[_2440]
                            require mem[_2440 + 32] == mem[_2440 + 32]
                            require mem[_2440 + 64] == mem[_2440 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2632 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2656 = mem[_2632]
                            require mem[_2632] == mem[_2632]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2656
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2656
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2752 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2752] == bool(mem[_2752])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2848 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2872 = mem[_2848]
                            require mem[_2848] == mem[_2848]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2944 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2968 = mem[_2944]
                            require mem[_2944] == mem[_2944]
                            require mem[_2944 + 32] == mem[_2944 + 32]
                            require mem[_2944 + 64] == mem[_2944 + 92 len 4]
                            require mem[_2944 + 96] == mem[_2944 + 124 len 4]
                            mem[mem[64] + 4] = _2656
                            mem[mem[64] + 36] = _2872
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2656, _2872, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3112 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3112] == mem[_3112]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3208 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3208] == mem[_3208]
                            require mem[_3208 + 32] == mem[_3208 + 32]
                            require mem[_3208 + 64] == mem[_3208 + 92 len 4]
                            require mem[_3208 + 96] == mem[_3208 + 124 len 4]
                            if mem[_3208] < _2968:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3208] - _2968
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1867
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1867
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2105 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2105] == bool(mem[_2105])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1975
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1975
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2225 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2225] == bool(mem[_2225])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1975
                            mem[mem[64] + 100] = _1867
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1975, _1867, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2441 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2441] == mem[_2441]
                            require mem[_2441 + 32] == mem[_2441 + 32]
                            require mem[_2441 + 64] == mem[_2441 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2633 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2657 = mem[_2633]
                            require mem[_2633] == mem[_2633]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2657
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2657
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2753 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2753] == bool(mem[_2753])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2849 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2873 = mem[_2849]
                            require mem[_2849] == mem[_2849]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2945 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _2969 = mem[_2945]
                            require mem[_2945] == mem[_2945]
                            require mem[_2945 + 32] == mem[_2945 + 32]
                            require mem[_2945 + 64] == mem[_2945 + 92 len 4]
                            require mem[_2945 + 96] == mem[_2945 + 124 len 4]
                            mem[mem[64] + 4] = _2657
                            mem[mem[64] + 36] = _2873
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2657, _2873, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3113 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3113] == mem[_3113]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3209 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3209] == mem[_3209]
                            require mem[_3209 + 32] == mem[_3209 + 32]
                            require mem[_3209 + 64] == mem[_3209 + 92 len 4]
                            require mem[_3209 + 96] == mem[_3209 + 124 len 4]
                            if mem[_3209] < _2969:
                                revert with 'NH{q', 17
                            mem[mem[64]] = mem[_3209] - _2969
    return memory
      from mem[64]
       len 32
}

function sub_251b1a6a(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    mem[100] = msg.sender
    require ext_code.size(stor2)
    staticcall stor2.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] >= arg2:
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = this.address
        mem[ceil32(return_data.size) + 164] = arg2
        require ext_code.size(stor2)
        call stor2.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[0] = address(arg1)
        mem[32] = 11
        require stor11[address(arg1)]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].getReserves() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].token0() with:
                gas gas_remaining wei
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor11[address(arg1)])
        staticcall stor11[address(arg1)].0xd21220a7 with:
                gas gas_remaining wei
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != address(arg1):
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor2:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            if address(arg1) == stor3:
                mem[(7 * ceil32(return_data.size)) + 100] = stor6
                mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(8 * ceil32(return_data.size)) + 96] = 2
                mem[(8 * ceil32(return_data.size)) + 128] = stor2
                mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(8 * ceil32(return_data.size)) + 228] = 0
                mem[(8 * ceil32(return_data.size)) + 260] = 160
                mem[(8 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (8 * ceil32(return_data.size)) + 128
                t = (8 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(8 * ceil32(return_data.size)) + 292] = this.address
                mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor6)
                call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (10 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _318 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                _330 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                require _318 + (32 * _330) + 32 <= return_data.size
                idx = 0
                s = (8 * ceil32(return_data.size)) + _318 + 224
                t = (10 * ceil32(return_data.size)) + 224
                while idx < _330:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1004 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1022 = mem[_1004]
                require mem[_1004] == mem[_1004]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1064 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1082 = mem[_1064]
                require mem[_1064] == mem[_1064]
                if address(arg1) == stor3:
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1022
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1022
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1172 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1172] == bool(mem[_1172])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1082
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1082
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1280 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1280] == bool(mem[_1280])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1082
                    mem[mem[64] + 100] = _1022
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1082, _1022, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1520 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1520] == mem[_1520]
                    require mem[_1520 + 32] == mem[_1520 + 32]
                    require mem[_1520 + 64] == mem[_1520 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1688 = mem[_1652]
                    require mem[_1652] == mem[_1652]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1688
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1688
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1784 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1784] == bool(mem[_1784])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1868 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1880 = mem[_1868]
                    require mem[_1868] == mem[_1868]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1964 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _1976 = mem[_1964]
                    require mem[_1964] == mem[_1964]
                    require mem[_1964 + 32] == mem[_1964 + 32]
                    require mem[_1964 + 64] == mem[_1964 + 92 len 4]
                    require mem[_1964 + 96] == mem[_1964 + 124 len 4]
                    mem[mem[64] + 4] = _1688
                    mem[mem[64] + 36] = _1880
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1688, _1880, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2240 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2240] == mem[_2240]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2312 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2312] == mem[_2312]
                    require mem[_2312 + 32] == mem[_2312 + 32]
                    require mem[_2312 + 64] == mem[_2312 + 92 len 4]
                    require mem[_2312 + 96] == mem[_2312 + 124 len 4]
                    if mem[_2312] < _1976:
                        revert with 'NH{q', 17
                    if mem[_2312] - _1976 < arg3:
                        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2516 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2528 = mem[_2516]
                    require mem[_2516] == mem[_2516]
                    if mem[_2516] <= 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2696 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2756 = mem[_2696]
                        require mem[_2696] == mem[_2696]
                        if mem[_2696] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2756
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2756
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2924 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2924] == bool(mem[_2924])
                    else:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _2528
                        require ext_code.size(address(arg1))
                        call address(arg1).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _2528
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2720 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2720] == bool(mem[_2720])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2925 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2973 = mem[_2925]
                        require mem[_2925] == mem[_2925]
                        if mem[_2925] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2973
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2973
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3140 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3140] == bool(mem[_3140])
                else:
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1022
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1022
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1173 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1173] == bool(mem[_1173])
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1082
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1082
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1281 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1281] == bool(mem[_1281])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1082
                    mem[mem[64] + 100] = _1022
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1082, _1022, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1521 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1521] == mem[_1521]
                    require mem[_1521 + 32] == mem[_1521 + 32]
                    require mem[_1521 + 64] == mem[_1521 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1653 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1689 = mem[_1653]
                    require mem[_1653] == mem[_1653]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1689
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1689
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1785] == bool(mem[_1785])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1869 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1881 = mem[_1869]
                    require mem[_1869] == mem[_1869]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1965 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _1977 = mem[_1965]
                    require mem[_1965] == mem[_1965]
                    require mem[_1965 + 32] == mem[_1965 + 32]
                    require mem[_1965 + 64] == mem[_1965 + 92 len 4]
                    require mem[_1965 + 96] == mem[_1965 + 124 len 4]
                    mem[mem[64] + 4] = _1689
                    mem[mem[64] + 36] = _1881
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1689, _1881, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2241 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2241] == mem[_2241]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2313 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2313] == mem[_2313]
                    require mem[_2313 + 32] == mem[_2313 + 32]
                    require mem[_2313 + 64] == mem[_2313 + 92 len 4]
                    require mem[_2313 + 96] == mem[_2313 + 124 len 4]
                    if mem[_2313] < _1977:
                        revert with 'NH{q', 17
                    if mem[_2313] - _1977 < arg3:
                        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2517 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2529 = mem[_2517]
                    require mem[_2517] == mem[_2517]
                    if mem[_2517] <= 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2698 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2757 = mem[_2698]
                        require mem[_2698] == mem[_2698]
                        if mem[_2698] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2757
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2757
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2926 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2926] == bool(mem[_2926])
                    else:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _2529
                        require ext_code.size(address(arg1))
                        call address(arg1).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _2529
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2721 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2721] == bool(mem[_2721])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2927 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2975 = mem[_2927]
                        require mem[_2927] == mem[_2927]
                        if mem[_2927] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2975
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2975
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3141 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3141] == bool(mem[_3141])
            else:
                mem[(7 * ceil32(return_data.size)) + 100] = stor5
                mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[(8 * ceil32(return_data.size)) + 96] = 2
                mem[(8 * ceil32(return_data.size)) + 128] = stor2
                mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                mem[(8 * ceil32(return_data.size)) + 228] = 0
                mem[(8 * ceil32(return_data.size)) + 260] = 160
                mem[(8 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (8 * ceil32(return_data.size)) + 128
                t = (8 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(8 * ceil32(return_data.size)) + 292] = this.address
                mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                require ext_code.size(stor5)
                call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (10 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _319 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                _331 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                    revert with 'NH{q', 65
                if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                require _319 + (32 * _331) + 32 <= return_data.size
                idx = 0
                s = (8 * ceil32(return_data.size)) + _319 + 224
                t = (10 * ceil32(return_data.size)) + 224
                while idx < _331:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1005 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1023 = mem[_1005]
                require mem[_1005] == mem[_1005]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1065 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1083 = mem[_1065]
                require mem[_1065] == mem[_1065]
                if address(arg1) == stor3:
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1023
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1023
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1174 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1174] == bool(mem[_1174])
                    mem[mem[64] + 4] = stor6
                    mem[mem[64] + 36] = _1083
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, _1083
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1282 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1282] == bool(mem[_1282])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1083
                    mem[mem[64] + 100] = _1023
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1083, _1023, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1522 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1522] == mem[_1522]
                    require mem[_1522 + 32] == mem[_1522 + 32]
                    require mem[_1522 + 64] == mem[_1522 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1654 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1690 = mem[_1654]
                    require mem[_1654] == mem[_1654]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1690
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1690
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1786 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1786] == bool(mem[_1786])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1870 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1882 = mem[_1870]
                    require mem[_1870] == mem[_1870]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1966 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _1978 = mem[_1966]
                    require mem[_1966] == mem[_1966]
                    require mem[_1966 + 32] == mem[_1966 + 32]
                    require mem[_1966 + 64] == mem[_1966 + 92 len 4]
                    require mem[_1966 + 96] == mem[_1966 + 124 len 4]
                    mem[mem[64] + 4] = _1690
                    mem[mem[64] + 36] = _1882
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1690, _1882, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2242 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2242] == mem[_2242]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2314 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2314] == mem[_2314]
                    require mem[_2314 + 32] == mem[_2314 + 32]
                    require mem[_2314 + 64] == mem[_2314 + 92 len 4]
                    require mem[_2314 + 96] == mem[_2314 + 124 len 4]
                    if mem[_2314] < _1978:
                        revert with 'NH{q', 17
                    if mem[_2314] - _1978 < arg3:
                        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2518 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2530 = mem[_2518]
                    require mem[_2518] == mem[_2518]
                    if mem[_2518] <= 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2700 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2758 = mem[_2700]
                        require mem[_2700] == mem[_2700]
                        if mem[_2700] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2758
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2758
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2928 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2928] == bool(mem[_2928])
                    else:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _2530
                        require ext_code.size(address(arg1))
                        call address(arg1).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _2530
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2722 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2722] == bool(mem[_2722])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2977 = mem[_2929]
                        require mem[_2929] == mem[_2929]
                        if mem[_2929] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2977
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2977
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3142 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3142] == bool(mem[_3142])
                else:
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1023
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1023
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1175] == bool(mem[_1175])
                    mem[mem[64] + 4] = stor5
                    mem[mem[64] + 36] = _1083
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, _1083
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1283 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1283] == bool(mem[_1283])
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[mem[64] + 68] = _1083
                    mem[mem[64] + 100] = _1023
                    mem[mem[64] + 132] = 0
                    mem[mem[64] + 164] = 0
                    mem[mem[64] + 196] = this.address
                    mem[mem[64] + 228] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                         gas gas_remaining wei
                        args stor2, address(arg1), _1083, _1023, 0, 0, address(this.address), block.timestamp + 60
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1523 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_1523] == mem[_1523]
                    require mem[_1523 + 32] == mem[_1523 + 32]
                    require mem[_1523 + 64] == mem[_1523 + 64]
                    mem[0] = address(arg1)
                    mem[32] = 11
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor11[address(arg1)])
                    staticcall stor11[address(arg1)].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1655 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1691 = mem[_1655]
                    require mem[_1655] == mem[_1655]
                    mem[0] = stor11[address(arg1)]
                    mem[32] = 13
                    mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                    mem[mem[64] + 36] = _1691
                    require ext_code.size(stor11[address(arg1)])
                    call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor13[stor11[address(arg1)]], _1691
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1787 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1787] == bool(mem[_1787])
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1871 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1883 = mem[_1871]
                    require mem[_1871] == mem[_1871]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _1979 = mem[_1967]
                    require mem[_1967] == mem[_1967]
                    require mem[_1967 + 32] == mem[_1967 + 32]
                    require mem[_1967 + 64] == mem[_1967 + 92 len 4]
                    require mem[_1967 + 96] == mem[_1967 + 124 len 4]
                    mem[mem[64] + 4] = _1691
                    mem[mem[64] + 36] = _1883
                    mem[mem[64] + 68] = msg.sender
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args _1691, _1883, msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2243 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2243] == mem[_2243]
                    require ext_code.size(stor13[stor11[address(arg1)]])
                    staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2315 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    require mem[_2315] == mem[_2315]
                    require mem[_2315 + 32] == mem[_2315 + 32]
                    require mem[_2315 + 64] == mem[_2315 + 92 len 4]
                    require mem[_2315 + 96] == mem[_2315 + 124 len 4]
                    if mem[_2315] < _1979:
                        revert with 'NH{q', 17
                    if mem[_2315] - _1979 < arg3:
                        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2519 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2531 = mem[_2519]
                    require mem[_2519] == mem[_2519]
                    if mem[_2519] <= 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2702 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2759 = mem[_2702]
                        require mem[_2702] == mem[_2702]
                        if mem[_2702] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2759
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2759
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2930 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2930] == bool(mem[_2930])
                    else:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _2531
                        require ext_code.size(address(arg1))
                        call address(arg1).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _2531
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2723 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2723] == bool(mem[_2723])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2931 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2979 = mem[_2931]
                        require mem[_2931] == mem[_2931]
                        if mem[_2931] > 0:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2979
                            require ext_code.size(stor2)
                            call stor2.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2979
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3143 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3143] == bool(mem[_3143])
        else:
            if ext_call.return_data[12 len 20] == stor2:
                if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor6
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _322 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _334 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    require _322 + (32 * _334) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _322 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _334:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1008 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1026 = mem[_1008]
                    require mem[_1008] == mem[_1008]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1068 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1086 = mem[_1068]
                    require mem[_1068] == mem[_1068]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1026
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1026
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1180 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1180] == bool(mem[_1180])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1086
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1086
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1288 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1288] == bool(mem[_1288])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1086
                        mem[mem[64] + 100] = _1026
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1086, _1026, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1528 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1528] == mem[_1528]
                        require mem[_1528 + 32] == mem[_1528 + 32]
                        require mem[_1528 + 64] == mem[_1528 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1660 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1696 = mem[_1660]
                        require mem[_1660] == mem[_1660]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1696
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1696
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1792 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1792] == bool(mem[_1792])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1876 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1888 = mem[_1876]
                        require mem[_1876] == mem[_1876]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1972 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1984 = mem[_1972]
                        require mem[_1972] == mem[_1972]
                        require mem[_1972 + 32] == mem[_1972 + 32]
                        require mem[_1972 + 64] == mem[_1972 + 92 len 4]
                        require mem[_1972 + 96] == mem[_1972 + 124 len 4]
                        mem[mem[64] + 4] = _1696
                        mem[mem[64] + 36] = _1888
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1696, _1888, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2248 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2248] == mem[_2248]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2320 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2320] == mem[_2320]
                        require mem[_2320 + 32] == mem[_2320 + 32]
                        require mem[_2320 + 64] == mem[_2320 + 92 len 4]
                        require mem[_2320 + 96] == mem[_2320 + 124 len 4]
                        if mem[_2320] < _1984:
                            revert with 'NH{q', 17
                        if mem[_2320] - _1984 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2524 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2536 = mem[_2524]
                        require mem[_2524] == mem[_2524]
                        if mem[_2524] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2712 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2764 = mem[_2712]
                            require mem[_2712] == mem[_2712]
                            if mem[_2712] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2764
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2764
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2940 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2940] == bool(mem[_2940])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2536
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2536
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2728 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2728] == bool(mem[_2728])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2941 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2989 = mem[_2941]
                            require mem[_2941] == mem[_2941]
                            if mem[_2941] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2989
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2989
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3148 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3148] == bool(mem[_3148])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1026
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1026
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1181 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1181] == bool(mem[_1181])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1086
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1086
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1289 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1289] == bool(mem[_1289])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1086
                        mem[mem[64] + 100] = _1026
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1086, _1026, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1529 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1529] == mem[_1529]
                        require mem[_1529 + 32] == mem[_1529 + 32]
                        require mem[_1529 + 64] == mem[_1529 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1661 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1697 = mem[_1661]
                        require mem[_1661] == mem[_1661]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1697
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1697
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1793 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1793] == bool(mem[_1793])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1877 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1889 = mem[_1877]
                        require mem[_1877] == mem[_1877]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1973 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1985 = mem[_1973]
                        require mem[_1973] == mem[_1973]
                        require mem[_1973 + 32] == mem[_1973 + 32]
                        require mem[_1973 + 64] == mem[_1973 + 92 len 4]
                        require mem[_1973 + 96] == mem[_1973 + 124 len 4]
                        mem[mem[64] + 4] = _1697
                        mem[mem[64] + 36] = _1889
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1697, _1889, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2249 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2249] == mem[_2249]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2321 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2321] == mem[_2321]
                        require mem[_2321 + 32] == mem[_2321 + 32]
                        require mem[_2321 + 64] == mem[_2321 + 92 len 4]
                        require mem[_2321 + 96] == mem[_2321 + 124 len 4]
                        if mem[_2321] < _1985:
                            revert with 'NH{q', 17
                        if mem[_2321] - _1985 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2525 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2537 = mem[_2525]
                        require mem[_2525] == mem[_2525]
                        if mem[_2525] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2714 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2765 = mem[_2714]
                            require mem[_2714] == mem[_2714]
                            if mem[_2714] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2765
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2765
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2942 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2942] == bool(mem[_2942])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2537
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2537
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2729 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2729] == bool(mem[_2729])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2943 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2991 = mem[_2943]
                            require mem[_2943] == mem[_2943]
                            if mem[_2943] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2991
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2991
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3149 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3149] == bool(mem[_3149])
                else:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor5
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _323 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _335 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                    require _323 + (32 * _335) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _323 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _335:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1009 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1027 = mem[_1009]
                    require mem[_1009] == mem[_1009]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1069 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1087 = mem[_1069]
                    require mem[_1069] == mem[_1069]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1027
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1027
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1182 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1182] == bool(mem[_1182])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1087
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1087
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1290 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1290] == bool(mem[_1290])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1087
                        mem[mem[64] + 100] = _1027
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1087, _1027, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1530 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1530] == mem[_1530]
                        require mem[_1530 + 32] == mem[_1530 + 32]
                        require mem[_1530 + 64] == mem[_1530 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1662 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1698 = mem[_1662]
                        require mem[_1662] == mem[_1662]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1698
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1698
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1794 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1794] == bool(mem[_1794])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1878 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1890 = mem[_1878]
                        require mem[_1878] == mem[_1878]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1974 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1986 = mem[_1974]
                        require mem[_1974] == mem[_1974]
                        require mem[_1974 + 32] == mem[_1974 + 32]
                        require mem[_1974 + 64] == mem[_1974 + 92 len 4]
                        require mem[_1974 + 96] == mem[_1974 + 124 len 4]
                        mem[mem[64] + 4] = _1698
                        mem[mem[64] + 36] = _1890
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1698, _1890, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2250 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2250] == mem[_2250]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2322 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2322] == mem[_2322]
                        require mem[_2322 + 32] == mem[_2322 + 32]
                        require mem[_2322 + 64] == mem[_2322 + 92 len 4]
                        require mem[_2322 + 96] == mem[_2322 + 124 len 4]
                        if mem[_2322] < _1986:
                            revert with 'NH{q', 17
                        if mem[_2322] - _1986 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2526 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2538 = mem[_2526]
                        require mem[_2526] == mem[_2526]
                        if mem[_2526] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2716 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2766 = mem[_2716]
                            require mem[_2716] == mem[_2716]
                            if mem[_2716] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2766
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2766
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2944 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2944] == bool(mem[_2944])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2538
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2538
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2730 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2730] == bool(mem[_2730])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2945 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2993 = mem[_2945]
                            require mem[_2945] == mem[_2945]
                            if mem[_2945] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2993
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2993
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3150 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3150] == bool(mem[_3150])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1027
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1027
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1183 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1183] == bool(mem[_1183])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1087
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1087
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1291 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1291] == bool(mem[_1291])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1087
                        mem[mem[64] + 100] = _1027
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1087, _1027, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1531 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1531] == mem[_1531]
                        require mem[_1531 + 32] == mem[_1531 + 32]
                        require mem[_1531 + 64] == mem[_1531 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1663 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1699 = mem[_1663]
                        require mem[_1663] == mem[_1663]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1699
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1699
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1795 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1795] == bool(mem[_1795])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1879 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1891 = mem[_1879]
                        require mem[_1879] == mem[_1879]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1975 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1987 = mem[_1975]
                        require mem[_1975] == mem[_1975]
                        require mem[_1975 + 32] == mem[_1975 + 32]
                        require mem[_1975 + 64] == mem[_1975 + 92 len 4]
                        require mem[_1975 + 96] == mem[_1975 + 124 len 4]
                        mem[mem[64] + 4] = _1699
                        mem[mem[64] + 36] = _1891
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1699, _1891, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2251 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2251] == mem[_2251]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2323 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2323] == mem[_2323]
                        require mem[_2323 + 32] == mem[_2323 + 32]
                        require mem[_2323 + 64] == mem[_2323 + 92 len 4]
                        require mem[_2323 + 96] == mem[_2323 + 124 len 4]
                        if mem[_2323] < _1987:
                            revert with 'NH{q', 17
                        if mem[_2323] - _1987 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2527 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2539 = mem[_2527]
                        require mem[_2527] == mem[_2527]
                        if mem[_2527] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2718 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2767 = mem[_2718]
                            require mem[_2718] == mem[_2718]
                            if mem[_2718] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2767
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2767
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2946 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2946] == bool(mem[_2946])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2539
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2539
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2731 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2731] == bool(mem[_2731])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2947 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2995 = mem[_2947]
                            require mem[_2947] == mem[_2947]
                            if mem[_2947] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2995
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2995
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3151 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3151] == bool(mem[_3151])
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor6
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _320 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _332 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _320 + (32 * _332) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _320 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _332:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1006 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1024 = mem[_1006]
                    require mem[_1006] == mem[_1006]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1066 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1084 = mem[_1066]
                    require mem[_1066] == mem[_1066]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1024
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1024
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1176 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1176] == bool(mem[_1176])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1084
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1084
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1284 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1284] == bool(mem[_1284])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1084
                        mem[mem[64] + 100] = _1024
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1084, _1024, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1524 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1524] == mem[_1524]
                        require mem[_1524 + 32] == mem[_1524 + 32]
                        require mem[_1524 + 64] == mem[_1524 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1656 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1692 = mem[_1656]
                        require mem[_1656] == mem[_1656]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1692
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1692
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1788 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1788] == bool(mem[_1788])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1872 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1884 = mem[_1872]
                        require mem[_1872] == mem[_1872]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1968 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1980 = mem[_1968]
                        require mem[_1968] == mem[_1968]
                        require mem[_1968 + 32] == mem[_1968 + 32]
                        require mem[_1968 + 64] == mem[_1968 + 92 len 4]
                        require mem[_1968 + 96] == mem[_1968 + 124 len 4]
                        mem[mem[64] + 4] = _1692
                        mem[mem[64] + 36] = _1884
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1692, _1884, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2244 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2244] == mem[_2244]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2316 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2316] == mem[_2316]
                        require mem[_2316 + 32] == mem[_2316 + 32]
                        require mem[_2316 + 64] == mem[_2316 + 92 len 4]
                        require mem[_2316 + 96] == mem[_2316 + 124 len 4]
                        if mem[_2316] < _1980:
                            revert with 'NH{q', 17
                        if mem[_2316] - _1980 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2520 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2532 = mem[_2520]
                        require mem[_2520] == mem[_2520]
                        if mem[_2520] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2704 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2760 = mem[_2704]
                            require mem[_2704] == mem[_2704]
                            if mem[_2704] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2760
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2760
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2932 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2932] == bool(mem[_2932])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2532
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2532
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2724] == bool(mem[_2724])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2933 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2981 = mem[_2933]
                            require mem[_2933] == mem[_2933]
                            if mem[_2933] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2981
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2981
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3144 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3144] == bool(mem[_3144])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1024
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1024
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1177 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1177] == bool(mem[_1177])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1084
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1084
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1285 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1285] == bool(mem[_1285])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1084
                        mem[mem[64] + 100] = _1024
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1084, _1024, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1525 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1525] == mem[_1525]
                        require mem[_1525 + 32] == mem[_1525 + 32]
                        require mem[_1525 + 64] == mem[_1525 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1657 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1693 = mem[_1657]
                        require mem[_1657] == mem[_1657]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1693
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1693
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1789 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1789] == bool(mem[_1789])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1873 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1885 = mem[_1873]
                        require mem[_1873] == mem[_1873]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1969 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1981 = mem[_1969]
                        require mem[_1969] == mem[_1969]
                        require mem[_1969 + 32] == mem[_1969 + 32]
                        require mem[_1969 + 64] == mem[_1969 + 92 len 4]
                        require mem[_1969 + 96] == mem[_1969 + 124 len 4]
                        mem[mem[64] + 4] = _1693
                        mem[mem[64] + 36] = _1885
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1693, _1885, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2245 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2245] == mem[_2245]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2317 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2317] == mem[_2317]
                        require mem[_2317 + 32] == mem[_2317 + 32]
                        require mem[_2317 + 64] == mem[_2317 + 92 len 4]
                        require mem[_2317 + 96] == mem[_2317 + 124 len 4]
                        if mem[_2317] < _1981:
                            revert with 'NH{q', 17
                        if mem[_2317] - _1981 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2521 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2533 = mem[_2521]
                        require mem[_2521] == mem[_2521]
                        if mem[_2521] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2706 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2761 = mem[_2706]
                            require mem[_2706] == mem[_2706]
                            if mem[_2706] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2761
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2761
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2934 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2934] == bool(mem[_2934])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2533
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2533
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2725] == bool(mem[_2725])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2935 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2983 = mem[_2935]
                            require mem[_2935] == mem[_2935]
                            if mem[_2935] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2983
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2983
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3145 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3145] == bool(mem[_3145])
                else:
                    mem[(7 * ceil32(return_data.size)) + 100] = stor5
                    mem[(7 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(8 * ceil32(return_data.size)) + 96] = 2
                    mem[(8 * ceil32(return_data.size)) + 128] = stor2
                    mem[(8 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(8 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(8 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(8 * ceil32(return_data.size)) + 228] = 0
                    mem[(8 * ceil32(return_data.size)) + 260] = 160
                    mem[(8 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + 128
                    t = (8 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(8 * ceil32(return_data.size)) + 292] = this.address
                    mem[(8 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(8 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(8 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (10 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _321 = mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (8 * ceil32(return_data.size)) + return_data.size + 192
                    _333 = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (10 * ceil32(return_data.size)) + floor32(mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(10 * ceil32(return_data.size)) + 192] = mem[(8 * ceil32(return_data.size)) + mem[(8 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _321 + (32 * _333) + 32 <= return_data.size
                    idx = 0
                    s = (8 * ceil32(return_data.size)) + _321 + 224
                    t = (10 * ceil32(return_data.size)) + 224
                    while idx < _333:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1007 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1025 = mem[_1007]
                    require mem[_1007] == mem[_1007]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1067 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1085 = mem[_1067]
                    require mem[_1067] == mem[_1067]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1025
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1025
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1178 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1178] == bool(mem[_1178])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1085
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1085
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1286 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1286] == bool(mem[_1286])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1085
                        mem[mem[64] + 100] = _1025
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1085, _1025, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1526 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1526] == mem[_1526]
                        require mem[_1526 + 32] == mem[_1526 + 32]
                        require mem[_1526 + 64] == mem[_1526 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1658 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1694 = mem[_1658]
                        require mem[_1658] == mem[_1658]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1694
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1694
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1790 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1790] == bool(mem[_1790])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1874 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1886 = mem[_1874]
                        require mem[_1874] == mem[_1874]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1970 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1982 = mem[_1970]
                        require mem[_1970] == mem[_1970]
                        require mem[_1970 + 32] == mem[_1970 + 32]
                        require mem[_1970 + 64] == mem[_1970 + 92 len 4]
                        require mem[_1970 + 96] == mem[_1970 + 124 len 4]
                        mem[mem[64] + 4] = _1694
                        mem[mem[64] + 36] = _1886
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1694, _1886, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2246 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2246] == mem[_2246]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2318 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2318] == mem[_2318]
                        require mem[_2318 + 32] == mem[_2318 + 32]
                        require mem[_2318 + 64] == mem[_2318 + 92 len 4]
                        require mem[_2318 + 96] == mem[_2318 + 124 len 4]
                        if mem[_2318] < _1982:
                            revert with 'NH{q', 17
                        if mem[_2318] - _1982 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2522 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2534 = mem[_2522]
                        require mem[_2522] == mem[_2522]
                        if mem[_2522] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2708 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2762 = mem[_2708]
                            require mem[_2708] == mem[_2708]
                            if mem[_2708] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2762
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2762
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2936 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2936] == bool(mem[_2936])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2534
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2534
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2726] == bool(mem[_2726])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2937 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2985 = mem[_2937]
                            require mem[_2937] == mem[_2937]
                            if mem[_2937] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2985
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2985
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3146 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3146] == bool(mem[_3146])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1025
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1025
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1179 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1179] == bool(mem[_1179])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1085
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1085
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1287 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1287] == bool(mem[_1287])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1085
                        mem[mem[64] + 100] = _1025
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1085, _1025, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1527 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_1527] == mem[_1527]
                        require mem[_1527 + 32] == mem[_1527 + 32]
                        require mem[_1527 + 64] == mem[_1527 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1659 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1695 = mem[_1659]
                        require mem[_1659] == mem[_1659]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _1695
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _1695
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1791 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1791] == bool(mem[_1791])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1875 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1887 = mem[_1875]
                        require mem[_1875] == mem[_1875]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1971 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1983 = mem[_1971]
                        require mem[_1971] == mem[_1971]
                        require mem[_1971 + 32] == mem[_1971 + 32]
                        require mem[_1971 + 64] == mem[_1971 + 92 len 4]
                        require mem[_1971 + 96] == mem[_1971 + 124 len 4]
                        mem[mem[64] + 4] = _1695
                        mem[mem[64] + 36] = _1887
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _1695, _1887, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2247 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2247] == mem[_2247]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2319 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_2319] == mem[_2319]
                        require mem[_2319 + 32] == mem[_2319 + 32]
                        require mem[_2319 + 64] == mem[_2319 + 92 len 4]
                        require mem[_2319 + 96] == mem[_2319 + 124 len 4]
                        if mem[_2319] < _1983:
                            revert with 'NH{q', 17
                        if mem[_2319] - _1983 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2523 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2535 = mem[_2523]
                        require mem[_2523] == mem[_2523]
                        if mem[_2523] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2710 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2763 = mem[_2710]
                            require mem[_2710] == mem[_2710]
                            if mem[_2710] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2763
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2763
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2938 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2938] == bool(mem[_2938])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _2535
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _2535
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2727 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2727] == bool(mem[_2727])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2939 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2987 = mem[_2939]
                            require mem[_2939] == mem[_2939]
                            if mem[_2939] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _2987
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _2987
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3147 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3147] == bool(mem[_3147])
    else:
        if arg2 < ext_call.return_data[0]:
            revert with 'NH{q', 17
        mem[ceil32(return_data.size) + 100] = msg.sender
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = this.address
        if ext_call.return_data[0] >= arg2 - ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + 164] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg2 - ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = arg2 - ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, arg2 - ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args arg2 - ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[0] = address(arg1)
            mem[32] = 11
            require stor11[address(arg1)]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[(6 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) != address(arg1):
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor6
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1010 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1028 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1010 + (32 * _1028) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1010 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1028:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1832 = mem[_1820]
                    require mem[_1820] == mem[_1820]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1928 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1940 = mem[_1928]
                    require mem[_1928] == mem[_1928]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1832
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1832
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2060 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2060] == bool(mem[_2060])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1940
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1940
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2180 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2180] == bool(mem[_2180])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1940
                        mem[mem[64] + 100] = _1832
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1940, _1832, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2396 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2396] == mem[_2396]
                        require mem[_2396 + 32] == mem[_2396 + 32]
                        require mem[_2396 + 64] == mem[_2396 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2672 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2732 = mem[_2672]
                        require mem[_2672] == mem[_2672]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2732
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2732
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2900 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2900] == bool(mem[_2900])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3044 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3080 = mem[_3044]
                        require mem[_3044] == mem[_3044]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3188 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3212 = mem[_3188]
                        require mem[_3188] == mem[_3188]
                        require mem[_3188 + 32] == mem[_3188 + 32]
                        require mem[_3188 + 64] == mem[_3188 + 92 len 4]
                        require mem[_3188 + 96] == mem[_3188 + 124 len 4]
                        mem[mem[64] + 4] = _2732
                        mem[mem[64] + 36] = _3080
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2732, _3080, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3356 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3356] == mem[_3356]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3452 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3452] == mem[_3452]
                        require mem[_3452 + 32] == mem[_3452 + 32]
                        require mem[_3452 + 64] == mem[_3452 + 92 len 4]
                        require mem[_3452 + 96] == mem[_3452 + 124 len 4]
                        if mem[_3452] < _3212:
                            revert with 'NH{q', 17
                        if mem[_3452] - _3212 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3668 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3692 = mem[_3668]
                        require mem[_3668] == mem[_3668]
                        if mem[_3668] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3788 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3860 = mem[_3788]
                            require mem[_3788] == mem[_3788]
                            if mem[_3788] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3860
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3860
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4004 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4004] == bool(mem[_4004])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3692
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3692
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3836 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3836] == bool(mem[_3836])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4005 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4053 = mem[_4005]
                            require mem[_4005] == mem[_4005]
                            if mem[_4005] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4053
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4053
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4148 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4148] == bool(mem[_4148])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1832
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1832
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2061 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2061] == bool(mem[_2061])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1940
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1940
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2181 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2181] == bool(mem[_2181])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1940
                        mem[mem[64] + 100] = _1832
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1940, _1832, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2397 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2397] == mem[_2397]
                        require mem[_2397 + 32] == mem[_2397 + 32]
                        require mem[_2397 + 64] == mem[_2397 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2673 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2733 = mem[_2673]
                        require mem[_2673] == mem[_2673]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2733
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2733
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2901 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2901] == bool(mem[_2901])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3045 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3081 = mem[_3045]
                        require mem[_3045] == mem[_3045]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3189 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3213 = mem[_3189]
                        require mem[_3189] == mem[_3189]
                        require mem[_3189 + 32] == mem[_3189 + 32]
                        require mem[_3189 + 64] == mem[_3189 + 92 len 4]
                        require mem[_3189 + 96] == mem[_3189 + 124 len 4]
                        mem[mem[64] + 4] = _2733
                        mem[mem[64] + 36] = _3081
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2733, _3081, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3357 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3357] == mem[_3357]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3453 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3453] == mem[_3453]
                        require mem[_3453 + 32] == mem[_3453 + 32]
                        require mem[_3453 + 64] == mem[_3453 + 92 len 4]
                        require mem[_3453 + 96] == mem[_3453 + 124 len 4]
                        if mem[_3453] < _3213:
                            revert with 'NH{q', 17
                        if mem[_3453] - _3213 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3669 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3693 = mem[_3669]
                        require mem[_3669] == mem[_3669]
                        if mem[_3669] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3790 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3861 = mem[_3790]
                            require mem[_3790] == mem[_3790]
                            if mem[_3790] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3861
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3861
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4006 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4006] == bool(mem[_4006])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3693
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3693
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3837 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3837] == bool(mem[_3837])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4007 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4055 = mem[_4007]
                            require mem[_4007] == mem[_4007]
                            if mem[_4007] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4055
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4055
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4149 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4149] == bool(mem[_4149])
                else:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor5
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1011 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1029 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1011 + (32 * _1029) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1011 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1029:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1821 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1833 = mem[_1821]
                    require mem[_1821] == mem[_1821]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1929 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1941 = mem[_1929]
                    require mem[_1929] == mem[_1929]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1833
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1833
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2062 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2062] == bool(mem[_2062])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1941
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1941
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2182 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2182] == bool(mem[_2182])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1941
                        mem[mem[64] + 100] = _1833
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1941, _1833, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2398 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2398] == mem[_2398]
                        require mem[_2398 + 32] == mem[_2398 + 32]
                        require mem[_2398 + 64] == mem[_2398 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2674 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2734 = mem[_2674]
                        require mem[_2674] == mem[_2674]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2734
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2734
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2902 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2902] == bool(mem[_2902])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3046 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3082 = mem[_3046]
                        require mem[_3046] == mem[_3046]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3190 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3214 = mem[_3190]
                        require mem[_3190] == mem[_3190]
                        require mem[_3190 + 32] == mem[_3190 + 32]
                        require mem[_3190 + 64] == mem[_3190 + 92 len 4]
                        require mem[_3190 + 96] == mem[_3190 + 124 len 4]
                        mem[mem[64] + 4] = _2734
                        mem[mem[64] + 36] = _3082
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2734, _3082, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3358 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3358] == mem[_3358]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3454 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3454] == mem[_3454]
                        require mem[_3454 + 32] == mem[_3454 + 32]
                        require mem[_3454 + 64] == mem[_3454 + 92 len 4]
                        require mem[_3454 + 96] == mem[_3454 + 124 len 4]
                        if mem[_3454] < _3214:
                            revert with 'NH{q', 17
                        if mem[_3454] - _3214 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3670 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3694 = mem[_3670]
                        require mem[_3670] == mem[_3670]
                        if mem[_3670] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3792 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3862 = mem[_3792]
                            require mem[_3792] == mem[_3792]
                            if mem[_3792] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3862
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3862
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4008 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4008] == bool(mem[_4008])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3694
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3694
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3838 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3838] == bool(mem[_3838])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4009 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4057 = mem[_4009]
                            require mem[_4009] == mem[_4009]
                            if mem[_4009] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4057
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4057
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4150 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4150] == bool(mem[_4150])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1833
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1833
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2063 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2063] == bool(mem[_2063])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1941
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1941
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2183 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2183] == bool(mem[_2183])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1941
                        mem[mem[64] + 100] = _1833
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1941, _1833, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2399 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2399] == mem[_2399]
                        require mem[_2399 + 32] == mem[_2399 + 32]
                        require mem[_2399 + 64] == mem[_2399 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2675 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2735 = mem[_2675]
                        require mem[_2675] == mem[_2675]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2735
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2735
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2903 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2903] == bool(mem[_2903])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3047 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3083 = mem[_3047]
                        require mem[_3047] == mem[_3047]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3191 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3215 = mem[_3191]
                        require mem[_3191] == mem[_3191]
                        require mem[_3191 + 32] == mem[_3191 + 32]
                        require mem[_3191 + 64] == mem[_3191 + 92 len 4]
                        require mem[_3191 + 96] == mem[_3191 + 124 len 4]
                        mem[mem[64] + 4] = _2735
                        mem[mem[64] + 36] = _3083
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2735, _3083, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3359 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3359] == mem[_3359]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3455 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3455] == mem[_3455]
                        require mem[_3455 + 32] == mem[_3455 + 32]
                        require mem[_3455 + 64] == mem[_3455 + 92 len 4]
                        require mem[_3455 + 96] == mem[_3455 + 124 len 4]
                        if mem[_3455] < _3215:
                            revert with 'NH{q', 17
                        if mem[_3455] - _3215 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3671 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3695 = mem[_3671]
                        require mem[_3671] == mem[_3671]
                        if mem[_3671] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3794 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3863 = mem[_3794]
                            require mem[_3794] == mem[_3794]
                            if mem[_3794] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3863
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3863
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4010 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4010] == bool(mem[_4010])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3695
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3695
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3839 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3839] == bool(mem[_3839])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4011 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4059 = mem[_4011]
                            require mem[_4011] == mem[_4011]
                            if mem[_4011] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4059
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4059
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4151 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4151] == bool(mem[_4151])
            else:
                if ext_call.return_data[12 len 20] == stor2:
                    if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1014 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1032 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1014 + (32 * _1032) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1014 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1032:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1824 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1836 = mem[_1824]
                        require mem[_1824] == mem[_1824]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1932 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1944 = mem[_1932]
                        require mem[_1932] == mem[_1932]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1836
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1836
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2068 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2068] == bool(mem[_2068])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1944
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1944
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2188] == bool(mem[_2188])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1944
                            mem[mem[64] + 100] = _1836
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1944, _1836, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2404 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2404] == mem[_2404]
                            require mem[_2404 + 32] == mem[_2404 + 32]
                            require mem[_2404 + 64] == mem[_2404 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2680 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2740 = mem[_2680]
                            require mem[_2680] == mem[_2680]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2740
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2740
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2908 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2908] == bool(mem[_2908])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3052 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3088 = mem[_3052]
                            require mem[_3052] == mem[_3052]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3196 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3220 = mem[_3196]
                            require mem[_3196] == mem[_3196]
                            require mem[_3196 + 32] == mem[_3196 + 32]
                            require mem[_3196 + 64] == mem[_3196 + 92 len 4]
                            require mem[_3196 + 96] == mem[_3196 + 124 len 4]
                            mem[mem[64] + 4] = _2740
                            mem[mem[64] + 36] = _3088
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2740, _3088, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3364 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3364] == mem[_3364]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3460 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3460] == mem[_3460]
                            require mem[_3460 + 32] == mem[_3460 + 32]
                            require mem[_3460 + 64] == mem[_3460 + 92 len 4]
                            require mem[_3460 + 96] == mem[_3460 + 124 len 4]
                            if mem[_3460] < _3220:
                                revert with 'NH{q', 17
                            if mem[_3460] - _3220 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3676 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3700 = mem[_3676]
                            require mem[_3676] == mem[_3676]
                            if mem[_3676] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3804 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3868 = mem[_3804]
                                require mem[_3804] == mem[_3804]
                                if mem[_3804] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3868
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3868
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4020 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4020] == bool(mem[_4020])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3700
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3700
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3844 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3844] == bool(mem[_3844])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4021 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4069 = mem[_4021]
                                require mem[_4021] == mem[_4021]
                                if mem[_4021] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4069
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4069
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4156 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4156] == bool(mem[_4156])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1836
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1836
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2069 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2069] == bool(mem[_2069])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1944
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1944
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2189 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2189] == bool(mem[_2189])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1944
                            mem[mem[64] + 100] = _1836
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1944, _1836, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2405 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2405] == mem[_2405]
                            require mem[_2405 + 32] == mem[_2405 + 32]
                            require mem[_2405 + 64] == mem[_2405 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2681 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2741 = mem[_2681]
                            require mem[_2681] == mem[_2681]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2741
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2741
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2909 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2909] == bool(mem[_2909])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3053 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3089 = mem[_3053]
                            require mem[_3053] == mem[_3053]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3197 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3221 = mem[_3197]
                            require mem[_3197] == mem[_3197]
                            require mem[_3197 + 32] == mem[_3197 + 32]
                            require mem[_3197 + 64] == mem[_3197 + 92 len 4]
                            require mem[_3197 + 96] == mem[_3197 + 124 len 4]
                            mem[mem[64] + 4] = _2741
                            mem[mem[64] + 36] = _3089
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2741, _3089, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3365 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3365] == mem[_3365]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3461 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3461] == mem[_3461]
                            require mem[_3461 + 32] == mem[_3461 + 32]
                            require mem[_3461 + 64] == mem[_3461 + 92 len 4]
                            require mem[_3461 + 96] == mem[_3461 + 124 len 4]
                            if mem[_3461] < _3221:
                                revert with 'NH{q', 17
                            if mem[_3461] - _3221 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3677 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3701 = mem[_3677]
                            require mem[_3677] == mem[_3677]
                            if mem[_3677] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3806 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3869 = mem[_3806]
                                require mem[_3806] == mem[_3806]
                                if mem[_3806] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3869
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3869
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4022 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4022] == bool(mem[_4022])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3701
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3701
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3845 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3845] == bool(mem[_3845])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4023 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4071 = mem[_4023]
                                require mem[_4023] == mem[_4023]
                                if mem[_4023] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4071
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4071
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4157 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4157] == bool(mem[_4157])
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1015 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1033 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1015 + (32 * _1033) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1015 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1033:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1825 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1837 = mem[_1825]
                        require mem[_1825] == mem[_1825]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1933 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1945 = mem[_1933]
                        require mem[_1933] == mem[_1933]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1837
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1837
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2070 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2070] == bool(mem[_2070])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1945
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1945
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2190 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2190] == bool(mem[_2190])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1945
                            mem[mem[64] + 100] = _1837
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1945, _1837, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2406 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2406] == mem[_2406]
                            require mem[_2406 + 32] == mem[_2406 + 32]
                            require mem[_2406 + 64] == mem[_2406 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2682 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2742 = mem[_2682]
                            require mem[_2682] == mem[_2682]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2742
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2742
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2910 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2910] == bool(mem[_2910])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3054 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3090 = mem[_3054]
                            require mem[_3054] == mem[_3054]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3198 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3222 = mem[_3198]
                            require mem[_3198] == mem[_3198]
                            require mem[_3198 + 32] == mem[_3198 + 32]
                            require mem[_3198 + 64] == mem[_3198 + 92 len 4]
                            require mem[_3198 + 96] == mem[_3198 + 124 len 4]
                            mem[mem[64] + 4] = _2742
                            mem[mem[64] + 36] = _3090
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2742, _3090, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3366 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3366] == mem[_3366]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3462 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3462] == mem[_3462]
                            require mem[_3462 + 32] == mem[_3462 + 32]
                            require mem[_3462 + 64] == mem[_3462 + 92 len 4]
                            require mem[_3462 + 96] == mem[_3462 + 124 len 4]
                            if mem[_3462] < _3222:
                                revert with 'NH{q', 17
                            if mem[_3462] - _3222 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3678 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3702 = mem[_3678]
                            require mem[_3678] == mem[_3678]
                            if mem[_3678] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3808 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3870 = mem[_3808]
                                require mem[_3808] == mem[_3808]
                                if mem[_3808] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3870
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3870
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4024 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4024] == bool(mem[_4024])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3702
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3702
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3846 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3846] == bool(mem[_3846])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4025 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4073 = mem[_4025]
                                require mem[_4025] == mem[_4025]
                                if mem[_4025] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4073
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4073
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4158 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4158] == bool(mem[_4158])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1837
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1837
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2071 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2071] == bool(mem[_2071])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1945
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1945
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2191 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2191] == bool(mem[_2191])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1945
                            mem[mem[64] + 100] = _1837
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1945, _1837, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2407 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2407] == mem[_2407]
                            require mem[_2407 + 32] == mem[_2407 + 32]
                            require mem[_2407 + 64] == mem[_2407 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2683 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2743 = mem[_2683]
                            require mem[_2683] == mem[_2683]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2743
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2743
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2911 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2911] == bool(mem[_2911])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3055 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3091 = mem[_3055]
                            require mem[_3055] == mem[_3055]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3199 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3223 = mem[_3199]
                            require mem[_3199] == mem[_3199]
                            require mem[_3199 + 32] == mem[_3199 + 32]
                            require mem[_3199 + 64] == mem[_3199 + 92 len 4]
                            require mem[_3199 + 96] == mem[_3199 + 124 len 4]
                            mem[mem[64] + 4] = _2743
                            mem[mem[64] + 36] = _3091
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2743, _3091, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3367 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3367] == mem[_3367]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3463 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3463] == mem[_3463]
                            require mem[_3463 + 32] == mem[_3463 + 32]
                            require mem[_3463 + 64] == mem[_3463 + 92 len 4]
                            require mem[_3463 + 96] == mem[_3463 + 124 len 4]
                            if mem[_3463] < _3223:
                                revert with 'NH{q', 17
                            if mem[_3463] - _3223 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3679 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3703 = mem[_3679]
                            require mem[_3679] == mem[_3679]
                            if mem[_3679] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3810 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3871 = mem[_3810]
                                require mem[_3810] == mem[_3810]
                                if mem[_3810] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3871
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3871
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4026 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4026] == bool(mem[_4026])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3703
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3703
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3847 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3847] == bool(mem[_3847])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4027 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4075 = mem[_4027]
                                require mem[_4027] == mem[_4027]
                                if mem[_4027] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4075
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4075
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4159 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4159] == bool(mem[_4159])
                else:
                    if ext_call.return_data[12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(ext_call.return_data[0]) != stor2:
                        revert with 0, 'bad LP token'
                    if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1012 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1030 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1012 + (32 * _1030) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1012 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1030:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1822 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1834 = mem[_1822]
                        require mem[_1822] == mem[_1822]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1930 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1942 = mem[_1930]
                        require mem[_1930] == mem[_1930]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1834
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1834
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2064 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2064] == bool(mem[_2064])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1942
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1942
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2184 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2184] == bool(mem[_2184])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1942
                            mem[mem[64] + 100] = _1834
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1942, _1834, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2400 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2400] == mem[_2400]
                            require mem[_2400 + 32] == mem[_2400 + 32]
                            require mem[_2400 + 64] == mem[_2400 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2676 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2736 = mem[_2676]
                            require mem[_2676] == mem[_2676]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2736
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2736
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2904 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2904] == bool(mem[_2904])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3048 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3084 = mem[_3048]
                            require mem[_3048] == mem[_3048]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3192 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3216 = mem[_3192]
                            require mem[_3192] == mem[_3192]
                            require mem[_3192 + 32] == mem[_3192 + 32]
                            require mem[_3192 + 64] == mem[_3192 + 92 len 4]
                            require mem[_3192 + 96] == mem[_3192 + 124 len 4]
                            mem[mem[64] + 4] = _2736
                            mem[mem[64] + 36] = _3084
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2736, _3084, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3360 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3360] == mem[_3360]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3456 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3456] == mem[_3456]
                            require mem[_3456 + 32] == mem[_3456 + 32]
                            require mem[_3456 + 64] == mem[_3456 + 92 len 4]
                            require mem[_3456 + 96] == mem[_3456 + 124 len 4]
                            if mem[_3456] < _3216:
                                revert with 'NH{q', 17
                            if mem[_3456] - _3216 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3672 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3696 = mem[_3672]
                            require mem[_3672] == mem[_3672]
                            if mem[_3672] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3796 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3864 = mem[_3796]
                                require mem[_3796] == mem[_3796]
                                if mem[_3796] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3864
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3864
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4012 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4012] == bool(mem[_4012])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3696
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3696
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3840 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3840] == bool(mem[_3840])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4013 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4061 = mem[_4013]
                                require mem[_4013] == mem[_4013]
                                if mem[_4013] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4061
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4061
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4152 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4152] == bool(mem[_4152])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1834
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1834
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2065 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2065] == bool(mem[_2065])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1942
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1942
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2185 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2185] == bool(mem[_2185])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1942
                            mem[mem[64] + 100] = _1834
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1942, _1834, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2401 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2401] == mem[_2401]
                            require mem[_2401 + 32] == mem[_2401 + 32]
                            require mem[_2401 + 64] == mem[_2401 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2677 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2737 = mem[_2677]
                            require mem[_2677] == mem[_2677]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2737
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2737
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2905 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2905] == bool(mem[_2905])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3049 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3085 = mem[_3049]
                            require mem[_3049] == mem[_3049]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3193 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3217 = mem[_3193]
                            require mem[_3193] == mem[_3193]
                            require mem[_3193 + 32] == mem[_3193 + 32]
                            require mem[_3193 + 64] == mem[_3193 + 92 len 4]
                            require mem[_3193 + 96] == mem[_3193 + 124 len 4]
                            mem[mem[64] + 4] = _2737
                            mem[mem[64] + 36] = _3085
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2737, _3085, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3361 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3361] == mem[_3361]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3457 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3457] == mem[_3457]
                            require mem[_3457 + 32] == mem[_3457 + 32]
                            require mem[_3457 + 64] == mem[_3457 + 92 len 4]
                            require mem[_3457 + 96] == mem[_3457 + 124 len 4]
                            if mem[_3457] < _3217:
                                revert with 'NH{q', 17
                            if mem[_3457] - _3217 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3673 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3697 = mem[_3673]
                            require mem[_3673] == mem[_3673]
                            if mem[_3673] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3798 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3865 = mem[_3798]
                                require mem[_3798] == mem[_3798]
                                if mem[_3798] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3865
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3865
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4014 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4014] == bool(mem[_4014])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3697
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3697
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3841 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3841] == bool(mem[_3841])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4015 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4063 = mem[_4015]
                                require mem[_4015] == mem[_4015]
                                if mem[_4015] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4063
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4063
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4153 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4153] == bool(mem[_4153])
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1013 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1031 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1013 + (32 * _1031) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1013 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1031:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1823 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1835 = mem[_1823]
                        require mem[_1823] == mem[_1823]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1931 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1943 = mem[_1931]
                        require mem[_1931] == mem[_1931]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1835
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1835
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2066 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2066] == bool(mem[_2066])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1943
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1943
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2186 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2186] == bool(mem[_2186])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1943
                            mem[mem[64] + 100] = _1835
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1943, _1835, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2402 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2402] == mem[_2402]
                            require mem[_2402 + 32] == mem[_2402 + 32]
                            require mem[_2402 + 64] == mem[_2402 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2678 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2738 = mem[_2678]
                            require mem[_2678] == mem[_2678]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2738
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2738
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2906 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2906] == bool(mem[_2906])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3050 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3086 = mem[_3050]
                            require mem[_3050] == mem[_3050]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3194 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3218 = mem[_3194]
                            require mem[_3194] == mem[_3194]
                            require mem[_3194 + 32] == mem[_3194 + 32]
                            require mem[_3194 + 64] == mem[_3194 + 92 len 4]
                            require mem[_3194 + 96] == mem[_3194 + 124 len 4]
                            mem[mem[64] + 4] = _2738
                            mem[mem[64] + 36] = _3086
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2738, _3086, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3362 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3362] == mem[_3362]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3458 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3458] == mem[_3458]
                            require mem[_3458 + 32] == mem[_3458 + 32]
                            require mem[_3458 + 64] == mem[_3458 + 92 len 4]
                            require mem[_3458 + 96] == mem[_3458 + 124 len 4]
                            if mem[_3458] < _3218:
                                revert with 'NH{q', 17
                            if mem[_3458] - _3218 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3674 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3698 = mem[_3674]
                            require mem[_3674] == mem[_3674]
                            if mem[_3674] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3800 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3866 = mem[_3800]
                                require mem[_3800] == mem[_3800]
                                if mem[_3800] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3866
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3866
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4016 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4016] == bool(mem[_4016])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3698
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3698
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3842 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3842] == bool(mem[_3842])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4017 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4065 = mem[_4017]
                                require mem[_4017] == mem[_4017]
                                if mem[_4017] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4065
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4065
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4154 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4154] == bool(mem[_4154])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1835
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1835
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2067 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2067] == bool(mem[_2067])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1943
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1943
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2187 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2187] == bool(mem[_2187])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1943
                            mem[mem[64] + 100] = _1835
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1943, _1835, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2403 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2403] == mem[_2403]
                            require mem[_2403 + 32] == mem[_2403 + 32]
                            require mem[_2403 + 64] == mem[_2403 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2679 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2739 = mem[_2679]
                            require mem[_2679] == mem[_2679]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2739
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2739
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2907 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2907] == bool(mem[_2907])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3051 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3087 = mem[_3051]
                            require mem[_3051] == mem[_3051]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3195 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3219 = mem[_3195]
                            require mem[_3195] == mem[_3195]
                            require mem[_3195 + 32] == mem[_3195 + 32]
                            require mem[_3195 + 64] == mem[_3195 + 92 len 4]
                            require mem[_3195 + 96] == mem[_3195 + 124 len 4]
                            mem[mem[64] + 4] = _2739
                            mem[mem[64] + 36] = _3087
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2739, _3087, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3363 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3363] == mem[_3363]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3459 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3459] == mem[_3459]
                            require mem[_3459 + 32] == mem[_3459 + 32]
                            require mem[_3459 + 64] == mem[_3459 + 92 len 4]
                            require mem[_3459 + 96] == mem[_3459 + 124 len 4]
                            if mem[_3459] < _3219:
                                revert with 'NH{q', 17
                            if mem[_3459] - _3219 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3675 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3699 = mem[_3675]
                            require mem[_3675] == mem[_3675]
                            if mem[_3675] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3802 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3867 = mem[_3802]
                                require mem[_3802] == mem[_3802]
                                if mem[_3802] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3867
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3867
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4018 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4018] == bool(mem[_4018])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3699
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3699
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3843 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3843] == bool(mem[_3843])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4019 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4067 = mem[_4019]
                                require mem[_4019] == mem[_4019]
                                if mem[_4019] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4067
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4067
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4155 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4155] == bool(mem[_4155])
        else:
            mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 100] = stor4
            mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(stor4)
            call stor4.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor4)
            call stor4.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[0] = address(arg1)
            mem[32] = 11
            require stor11[address(arg1)]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].getReserves() with:
                    gas gas_remaining wei
            mem[(6 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].token0() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(stor11[address(arg1)])
            staticcall stor11[address(arg1)].0xd21220a7 with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) != address(arg1):
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(ext_call.return_data[0]) != stor2:
                    revert with 0, 'bad LP token'
                if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                    revert with 'NH{q', 17
                if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                    revert with 'NH{q', 18
                require address(arg1)
                if address(arg1) == stor3:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor6
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor6)
                    call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1016 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1034 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1016 + (32 * _1034) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1016 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1034:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1826 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1838 = mem[_1826]
                    require mem[_1826] == mem[_1826]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1934 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1946 = mem[_1934]
                    require mem[_1934] == mem[_1934]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1838
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1838
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2072 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2072] == bool(mem[_2072])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1946
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1946
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2192 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2192] == bool(mem[_2192])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1946
                        mem[mem[64] + 100] = _1838
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1946, _1838, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2408 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2408] == mem[_2408]
                        require mem[_2408 + 32] == mem[_2408 + 32]
                        require mem[_2408 + 64] == mem[_2408 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2684 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2744 = mem[_2684]
                        require mem[_2684] == mem[_2684]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2744
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2744
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2912 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2912] == bool(mem[_2912])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3056 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3092 = mem[_3056]
                        require mem[_3056] == mem[_3056]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3200 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3224 = mem[_3200]
                        require mem[_3200] == mem[_3200]
                        require mem[_3200 + 32] == mem[_3200 + 32]
                        require mem[_3200 + 64] == mem[_3200 + 92 len 4]
                        require mem[_3200 + 96] == mem[_3200 + 124 len 4]
                        mem[mem[64] + 4] = _2744
                        mem[mem[64] + 36] = _3092
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2744, _3092, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3368 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3368] == mem[_3368]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3464 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3464] == mem[_3464]
                        require mem[_3464 + 32] == mem[_3464 + 32]
                        require mem[_3464 + 64] == mem[_3464 + 92 len 4]
                        require mem[_3464 + 96] == mem[_3464 + 124 len 4]
                        if mem[_3464] < _3224:
                            revert with 'NH{q', 17
                        if mem[_3464] - _3224 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3680 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3704 = mem[_3680]
                        require mem[_3680] == mem[_3680]
                        if mem[_3680] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3812 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3872 = mem[_3812]
                            require mem[_3812] == mem[_3812]
                            if mem[_3812] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3872
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3872
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4028 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4028] == bool(mem[_4028])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3704
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3704
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3848 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3848] == bool(mem[_3848])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4029 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4077 = mem[_4029]
                            require mem[_4029] == mem[_4029]
                            if mem[_4029] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4077
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4077
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4160 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4160] == bool(mem[_4160])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1838
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1838
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2073 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2073] == bool(mem[_2073])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1946
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1946
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2193 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2193] == bool(mem[_2193])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1946
                        mem[mem[64] + 100] = _1838
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1946, _1838, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2409 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2409] == mem[_2409]
                        require mem[_2409 + 32] == mem[_2409 + 32]
                        require mem[_2409 + 64] == mem[_2409 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2685 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2745 = mem[_2685]
                        require mem[_2685] == mem[_2685]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2745
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2745
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2913 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2913] == bool(mem[_2913])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3057 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3093 = mem[_3057]
                        require mem[_3057] == mem[_3057]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3201 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3225 = mem[_3201]
                        require mem[_3201] == mem[_3201]
                        require mem[_3201 + 32] == mem[_3201 + 32]
                        require mem[_3201 + 64] == mem[_3201 + 92 len 4]
                        require mem[_3201 + 96] == mem[_3201 + 124 len 4]
                        mem[mem[64] + 4] = _2745
                        mem[mem[64] + 36] = _3093
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2745, _3093, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3369 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3369] == mem[_3369]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3465 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3465] == mem[_3465]
                        require mem[_3465 + 32] == mem[_3465 + 32]
                        require mem[_3465 + 64] == mem[_3465 + 92 len 4]
                        require mem[_3465 + 96] == mem[_3465 + 124 len 4]
                        if mem[_3465] < _3225:
                            revert with 'NH{q', 17
                        if mem[_3465] - _3225 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3681 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3705 = mem[_3681]
                        require mem[_3681] == mem[_3681]
                        if mem[_3681] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3814 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3873 = mem[_3814]
                            require mem[_3814] == mem[_3814]
                            if mem[_3814] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3873
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3873
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4030 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4030] == bool(mem[_4030])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3705
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3705
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3849 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3849] == bool(mem[_3849])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4031 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4079 = mem[_4031]
                            require mem[_4031] == mem[_4031]
                            if mem[_4031] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4079
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4079
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4161 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4161] == bool(mem[_4161])
                else:
                    mem[(10 * ceil32(return_data.size)) + 100] = stor5
                    mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    require ext_code.size(stor2)
                    call stor2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(11 * ceil32(return_data.size)) + 96] = 2
                    mem[(11 * ceil32(return_data.size)) + 128] = stor2
                    mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                    if block.timestamp > -61:
                        revert with 'NH{q', 17
                    mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                    mem[(11 * ceil32(return_data.size)) + 228] = 0
                    mem[(11 * ceil32(return_data.size)) + 260] = 160
                    mem[(11 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + 128
                    t = (11 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(11 * ceil32(return_data.size)) + 292] = this.address
                    mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                    require ext_code.size(stor5)
                    call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (12 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1017 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                    require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                    require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                    _1035 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                        revert with 'NH{q', 65
                    if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                    mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                    require _1017 + (32 * _1035) + 32 <= return_data.size
                    idx = 0
                    s = (11 * ceil32(return_data.size)) + _1017 + 224
                    t = (12 * ceil32(return_data.size)) + 224
                    while idx < _1035:
                        require mem[s] == mem[s]
                        mem[t] = mem[s]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1827 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1839 = mem[_1827]
                    require mem[_1827] == mem[_1827]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1935 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1947 = mem[_1935]
                    require mem[_1935] == mem[_1935]
                    if address(arg1) == stor3:
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1839
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1839
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2074 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2074] == bool(mem[_2074])
                        mem[mem[64] + 4] = stor6
                        mem[mem[64] + 36] = _1947
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, _1947
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2194 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2194] == bool(mem[_2194])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1947
                        mem[mem[64] + 100] = _1839
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1947, _1839, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2410 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2410] == mem[_2410]
                        require mem[_2410 + 32] == mem[_2410 + 32]
                        require mem[_2410 + 64] == mem[_2410 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2686 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2746 = mem[_2686]
                        require mem[_2686] == mem[_2686]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2746
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2746
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2914 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2914] == bool(mem[_2914])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3058 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3094 = mem[_3058]
                        require mem[_3058] == mem[_3058]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3202 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3226 = mem[_3202]
                        require mem[_3202] == mem[_3202]
                        require mem[_3202 + 32] == mem[_3202 + 32]
                        require mem[_3202 + 64] == mem[_3202 + 92 len 4]
                        require mem[_3202 + 96] == mem[_3202 + 124 len 4]
                        mem[mem[64] + 4] = _2746
                        mem[mem[64] + 36] = _3094
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2746, _3094, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3370 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3370] == mem[_3370]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3466 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3466] == mem[_3466]
                        require mem[_3466 + 32] == mem[_3466 + 32]
                        require mem[_3466 + 64] == mem[_3466 + 92 len 4]
                        require mem[_3466 + 96] == mem[_3466 + 124 len 4]
                        if mem[_3466] < _3226:
                            revert with 'NH{q', 17
                        if mem[_3466] - _3226 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3682 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3706 = mem[_3682]
                        require mem[_3682] == mem[_3682]
                        if mem[_3682] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3816 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3874 = mem[_3816]
                            require mem[_3816] == mem[_3816]
                            if mem[_3816] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3874
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3874
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4032 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4032] == bool(mem[_4032])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3706
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3706
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3850 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3850] == bool(mem[_3850])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4033 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4081 = mem[_4033]
                            require mem[_4033] == mem[_4033]
                            if mem[_4033] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4081
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4081
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4162 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4162] == bool(mem[_4162])
                    else:
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1839
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1839
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2075 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2075] == bool(mem[_2075])
                        mem[mem[64] + 4] = stor5
                        mem[mem[64] + 36] = _1947
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, _1947
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2195 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2195] == bool(mem[_2195])
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[mem[64] + 68] = _1947
                        mem[mem[64] + 100] = _1839
                        mem[mem[64] + 132] = 0
                        mem[mem[64] + 164] = 0
                        mem[mem[64] + 196] = this.address
                        mem[mem[64] + 228] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                             gas gas_remaining wei
                            args stor2, address(arg1), _1947, _1839, 0, 0, address(this.address), block.timestamp + 60
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2411 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_2411] == mem[_2411]
                        require mem[_2411 + 32] == mem[_2411 + 32]
                        require mem[_2411 + 64] == mem[_2411 + 64]
                        mem[0] = address(arg1)
                        mem[32] = 11
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor11[address(arg1)])
                        staticcall stor11[address(arg1)].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2687 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2747 = mem[_2687]
                        require mem[_2687] == mem[_2687]
                        mem[0] = stor11[address(arg1)]
                        mem[32] = 13
                        mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                        mem[mem[64] + 36] = _2747
                        require ext_code.size(stor11[address(arg1)])
                        call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor13[stor11[address(arg1)]], _2747
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2915 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2915] == bool(mem[_2915])
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3059 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3095 = mem[_3059]
                        require mem[_3059] == mem[_3059]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3203 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _3227 = mem[_3203]
                        require mem[_3203] == mem[_3203]
                        require mem[_3203 + 32] == mem[_3203 + 32]
                        require mem[_3203 + 64] == mem[_3203 + 92 len 4]
                        require mem[_3203 + 96] == mem[_3203 + 124 len 4]
                        mem[mem[64] + 4] = _2747
                        mem[mem[64] + 36] = _3095
                        mem[mem[64] + 68] = msg.sender
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args _2747, _3095, msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3371 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3371] == mem[_3371]
                        require ext_code.size(stor13[stor11[address(arg1)]])
                        staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3467 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        require mem[_3467] == mem[_3467]
                        require mem[_3467 + 32] == mem[_3467 + 32]
                        require mem[_3467 + 64] == mem[_3467 + 92 len 4]
                        require mem[_3467 + 96] == mem[_3467 + 124 len 4]
                        if mem[_3467] < _3227:
                            revert with 'NH{q', 17
                        if mem[_3467] - _3227 < arg3:
                            revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3683 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3707 = mem[_3683]
                        require mem[_3683] == mem[_3683]
                        if mem[_3683] <= 0:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3818 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3875 = mem[_3818]
                            require mem[_3818] == mem[_3818]
                            if mem[_3818] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3875
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3875
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4034 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4034] == bool(mem[_4034])
                        else:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = _3707
                            require ext_code.size(address(arg1))
                            call address(arg1).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, _3707
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3851 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3851] == bool(mem[_3851])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor2)
                            staticcall stor2.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4035 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4083 = mem[_4035]
                            require mem[_4035] == mem[_4035]
                            if mem[_4035] > 0:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _4083
                                require ext_code.size(stor2)
                                call stor2.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _4083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4163 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4163] == bool(mem[_4163])
            else:
                if ext_call.return_data[12 len 20] == stor2:
                    if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1020 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1038 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1020 + (32 * _1038) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1020 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1038:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1830 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1842 = mem[_1830]
                        require mem[_1830] == mem[_1830]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1938 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1950 = mem[_1938]
                        require mem[_1938] == mem[_1938]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1842
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1842
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2080 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2080] == bool(mem[_2080])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1950
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1950
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2200 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2200] == bool(mem[_2200])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1950
                            mem[mem[64] + 100] = _1842
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1950, _1842, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2416 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2416] == mem[_2416]
                            require mem[_2416 + 32] == mem[_2416 + 32]
                            require mem[_2416 + 64] == mem[_2416 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2692 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2752 = mem[_2692]
                            require mem[_2692] == mem[_2692]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2752
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2752
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2920 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2920] == bool(mem[_2920])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3064 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3100 = mem[_3064]
                            require mem[_3064] == mem[_3064]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3208 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3232 = mem[_3208]
                            require mem[_3208] == mem[_3208]
                            require mem[_3208 + 32] == mem[_3208 + 32]
                            require mem[_3208 + 64] == mem[_3208 + 92 len 4]
                            require mem[_3208 + 96] == mem[_3208 + 124 len 4]
                            mem[mem[64] + 4] = _2752
                            mem[mem[64] + 36] = _3100
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2752, _3100, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3376 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3376] == mem[_3376]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3472 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3472] == mem[_3472]
                            require mem[_3472 + 32] == mem[_3472 + 32]
                            require mem[_3472 + 64] == mem[_3472 + 92 len 4]
                            require mem[_3472 + 96] == mem[_3472 + 124 len 4]
                            if mem[_3472] < _3232:
                                revert with 'NH{q', 17
                            if mem[_3472] - _3232 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3688 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3712 = mem[_3688]
                            require mem[_3688] == mem[_3688]
                            if mem[_3688] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3828 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3880 = mem[_3828]
                                require mem[_3828] == mem[_3828]
                                if mem[_3828] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3880
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3880
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4044 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4044] == bool(mem[_4044])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3712
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3712
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3856 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3856] == bool(mem[_3856])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4045 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4093 = mem[_4045]
                                require mem[_4045] == mem[_4045]
                                if mem[_4045] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4093
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4093
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4168 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4168] == bool(mem[_4168])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1842
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1842
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2081 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2081] == bool(mem[_2081])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1950
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1950
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2201 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2201] == bool(mem[_2201])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1950
                            mem[mem[64] + 100] = _1842
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1950, _1842, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2417 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2417] == mem[_2417]
                            require mem[_2417 + 32] == mem[_2417 + 32]
                            require mem[_2417 + 64] == mem[_2417 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2693 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2753 = mem[_2693]
                            require mem[_2693] == mem[_2693]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2753
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2753
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2921 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2921] == bool(mem[_2921])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3065 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3101 = mem[_3065]
                            require mem[_3065] == mem[_3065]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3209 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3233 = mem[_3209]
                            require mem[_3209] == mem[_3209]
                            require mem[_3209 + 32] == mem[_3209 + 32]
                            require mem[_3209 + 64] == mem[_3209 + 92 len 4]
                            require mem[_3209 + 96] == mem[_3209 + 124 len 4]
                            mem[mem[64] + 4] = _2753
                            mem[mem[64] + 36] = _3101
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2753, _3101, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3377 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3377] == mem[_3377]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3473] == mem[_3473]
                            require mem[_3473 + 32] == mem[_3473 + 32]
                            require mem[_3473 + 64] == mem[_3473 + 92 len 4]
                            require mem[_3473 + 96] == mem[_3473 + 124 len 4]
                            if mem[_3473] < _3233:
                                revert with 'NH{q', 17
                            if mem[_3473] - _3233 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3689 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3713 = mem[_3689]
                            require mem[_3689] == mem[_3689]
                            if mem[_3689] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3830 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3881 = mem[_3830]
                                require mem[_3830] == mem[_3830]
                                if mem[_3830] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3881
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3881
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4046 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4046] == bool(mem[_4046])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3713
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3713
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3857 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3857] == bool(mem[_3857])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4047 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4095 = mem[_4047]
                                require mem[_4047] == mem[_4047]
                                if mem[_4047] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4095
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4095
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4169 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4169] == bool(mem[_4169])
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1021 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1039 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
                        require _1021 + (32 * _1039) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1021 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1039:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1831 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1843 = mem[_1831]
                        require mem[_1831] == mem[_1831]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1951 = mem[_1939]
                        require mem[_1939] == mem[_1939]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1843
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1843
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2082 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2082] == bool(mem[_2082])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1951
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1951
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2202 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2202] == bool(mem[_2202])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1951
                            mem[mem[64] + 100] = _1843
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1951, _1843, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2418 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2418] == mem[_2418]
                            require mem[_2418 + 32] == mem[_2418 + 32]
                            require mem[_2418 + 64] == mem[_2418 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2694 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2754 = mem[_2694]
                            require mem[_2694] == mem[_2694]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2754
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2754
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2922 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2922] == bool(mem[_2922])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3066 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3102 = mem[_3066]
                            require mem[_3066] == mem[_3066]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3210 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3234 = mem[_3210]
                            require mem[_3210] == mem[_3210]
                            require mem[_3210 + 32] == mem[_3210 + 32]
                            require mem[_3210 + 64] == mem[_3210 + 92 len 4]
                            require mem[_3210 + 96] == mem[_3210 + 124 len 4]
                            mem[mem[64] + 4] = _2754
                            mem[mem[64] + 36] = _3102
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2754, _3102, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3378 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3378] == mem[_3378]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3474 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3474] == mem[_3474]
                            require mem[_3474 + 32] == mem[_3474 + 32]
                            require mem[_3474 + 64] == mem[_3474 + 92 len 4]
                            require mem[_3474 + 96] == mem[_3474 + 124 len 4]
                            if mem[_3474] < _3234:
                                revert with 'NH{q', 17
                            if mem[_3474] - _3234 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3690 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3714 = mem[_3690]
                            require mem[_3690] == mem[_3690]
                            if mem[_3690] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3832 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3882 = mem[_3832]
                                require mem[_3832] == mem[_3832]
                                if mem[_3832] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3882
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3882
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4048 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4048] == bool(mem[_4048])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3714
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3714
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3858 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3858] == bool(mem[_3858])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4049 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4097 = mem[_4049]
                                require mem[_4049] == mem[_4049]
                                if mem[_4049] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4097
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4097
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4170 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4170] == bool(mem[_4170])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1843
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1843
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2083 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2083] == bool(mem[_2083])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1951
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1951
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2203 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2203] == bool(mem[_2203])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1951
                            mem[mem[64] + 100] = _1843
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1951, _1843, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2419 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2419] == mem[_2419]
                            require mem[_2419 + 32] == mem[_2419 + 32]
                            require mem[_2419 + 64] == mem[_2419 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2695 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2755 = mem[_2695]
                            require mem[_2695] == mem[_2695]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2755
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2755
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2923 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2923] == bool(mem[_2923])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3067 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3103 = mem[_3067]
                            require mem[_3067] == mem[_3067]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3211 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3235 = mem[_3211]
                            require mem[_3211] == mem[_3211]
                            require mem[_3211 + 32] == mem[_3211 + 32]
                            require mem[_3211 + 64] == mem[_3211 + 92 len 4]
                            require mem[_3211 + 96] == mem[_3211 + 124 len 4]
                            mem[mem[64] + 4] = _2755
                            mem[mem[64] + 36] = _3103
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2755, _3103, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3379 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3379] == mem[_3379]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3475 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3475] == mem[_3475]
                            require mem[_3475 + 32] == mem[_3475 + 32]
                            require mem[_3475 + 64] == mem[_3475 + 92 len 4]
                            require mem[_3475 + 96] == mem[_3475 + 124 len 4]
                            if mem[_3475] < _3235:
                                revert with 'NH{q', 17
                            if mem[_3475] - _3235 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3691 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3715 = mem[_3691]
                            require mem[_3691] == mem[_3691]
                            if mem[_3691] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3834 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3883 = mem[_3834]
                                require mem[_3834] == mem[_3834]
                                if mem[_3834] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3883
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3883
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4050 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4050] == bool(mem[_4050])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3715
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3715
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3859 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3859] == bool(mem[_3859])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4051 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4099 = mem[_4051]
                                require mem[_4051] == mem[_4051]
                                if mem[_4051] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4099
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4099
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4171 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4171] == bool(mem[_4171])
                else:
                    if ext_call.return_data[12 len 20] != address(arg1):
                        revert with 0, 'bad LP token'
                    if address(ext_call.return_data[0]) != stor2:
                        revert with 0, 'bad LP token'
                    if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                        revert with 'NH{q', 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                        revert with 'NH{q', 17
                    if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                        revert with 'NH{q', 17
                    if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                        revert with 'NH{q', 17
                    if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 17
                    if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                        revert with 'NH{q', 17
                    if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                        revert with 'NH{q', 18
                    require address(arg1)
                    if address(arg1) == stor3:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor6
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor6, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor6)
                        call stor6.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1018 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1036 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1018 + (32 * _1036) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1018 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1036:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1828 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1840 = mem[_1828]
                        require mem[_1828] == mem[_1828]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1936 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1948 = mem[_1936]
                        require mem[_1936] == mem[_1936]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1840
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1840
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2076 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2076] == bool(mem[_2076])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1948
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1948
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2196 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2196] == bool(mem[_2196])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1948
                            mem[mem[64] + 100] = _1840
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1948, _1840, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2412 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2412] == mem[_2412]
                            require mem[_2412 + 32] == mem[_2412 + 32]
                            require mem[_2412 + 64] == mem[_2412 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2688 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2748 = mem[_2688]
                            require mem[_2688] == mem[_2688]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2748
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2748
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2916 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2916] == bool(mem[_2916])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3060 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3096 = mem[_3060]
                            require mem[_3060] == mem[_3060]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3204 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3228 = mem[_3204]
                            require mem[_3204] == mem[_3204]
                            require mem[_3204 + 32] == mem[_3204 + 32]
                            require mem[_3204 + 64] == mem[_3204 + 92 len 4]
                            require mem[_3204 + 96] == mem[_3204 + 124 len 4]
                            mem[mem[64] + 4] = _2748
                            mem[mem[64] + 36] = _3096
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2748, _3096, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3372 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3372] == mem[_3372]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3468 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3468] == mem[_3468]
                            require mem[_3468 + 32] == mem[_3468 + 32]
                            require mem[_3468 + 64] == mem[_3468 + 92 len 4]
                            require mem[_3468 + 96] == mem[_3468 + 124 len 4]
                            if mem[_3468] < _3228:
                                revert with 'NH{q', 17
                            if mem[_3468] - _3228 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3684 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3708 = mem[_3684]
                            require mem[_3684] == mem[_3684]
                            if mem[_3684] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3820 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3876 = mem[_3820]
                                require mem[_3820] == mem[_3820]
                                if mem[_3820] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3876
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3876
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4036 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4036] == bool(mem[_4036])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3708
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3708
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3852 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3852] == bool(mem[_3852])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4037 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4085 = mem[_4037]
                                require mem[_4037] == mem[_4037]
                                if mem[_4037] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4085
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4164 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4164] == bool(mem[_4164])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1840
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1840
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2077 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2077] == bool(mem[_2077])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1948
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1948
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2197 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2197] == bool(mem[_2197])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1948
                            mem[mem[64] + 100] = _1840
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1948, _1840, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2413 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2413] == mem[_2413]
                            require mem[_2413 + 32] == mem[_2413 + 32]
                            require mem[_2413 + 64] == mem[_2413 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2689 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2749 = mem[_2689]
                            require mem[_2689] == mem[_2689]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2749
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2749
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2917 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2917] == bool(mem[_2917])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3061 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3097 = mem[_3061]
                            require mem[_3061] == mem[_3061]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3205 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3229 = mem[_3205]
                            require mem[_3205] == mem[_3205]
                            require mem[_3205 + 32] == mem[_3205 + 32]
                            require mem[_3205 + 64] == mem[_3205 + 92 len 4]
                            require mem[_3205 + 96] == mem[_3205 + 124 len 4]
                            mem[mem[64] + 4] = _2749
                            mem[mem[64] + 36] = _3097
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2749, _3097, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3373 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3373] == mem[_3373]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3469 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3469] == mem[_3469]
                            require mem[_3469 + 32] == mem[_3469 + 32]
                            require mem[_3469 + 64] == mem[_3469 + 92 len 4]
                            require mem[_3469 + 96] == mem[_3469 + 124 len 4]
                            if mem[_3469] < _3229:
                                revert with 'NH{q', 17
                            if mem[_3469] - _3229 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3685 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3709 = mem[_3685]
                            require mem[_3685] == mem[_3685]
                            if mem[_3685] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3822 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3877 = mem[_3822]
                                require mem[_3822] == mem[_3822]
                                if mem[_3822] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3877
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3877
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4038 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4038] == bool(mem[_4038])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3709
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3709
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3853 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3853] == bool(mem[_3853])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4039 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4087 = mem[_4039]
                                require mem[_4039] == mem[_4039]
                                if mem[_4039] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4087
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4087
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4165 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4165] == bool(mem[_4165])
                    else:
                        mem[(10 * ceil32(return_data.size)) + 100] = stor5
                        mem[(10 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        require ext_code.size(stor2)
                        call stor2.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args stor5, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(10 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(11 * ceil32(return_data.size)) + 96] = 2
                        mem[(11 * ceil32(return_data.size)) + 128] = stor2
                        mem[(11 * ceil32(return_data.size)) + 160] = address(arg1)
                        if block.timestamp > -61:
                            revert with 'NH{q', 17
                        mem[(11 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(11 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
                        mem[(11 * ceil32(return_data.size)) + 228] = 0
                        mem[(11 * ceil32(return_data.size)) + 260] = 160
                        mem[(11 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + 128
                        t = (11 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(11 * ceil32(return_data.size)) + 292] = this.address
                        mem[(11 * ceil32(return_data.size)) + 324] = block.timestamp + 60
                        require ext_code.size(stor5)
                        call stor5.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(11 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(11 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (12 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1019 = mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
                        require mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
                        require (11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (11 * ceil32(return_data.size)) + return_data.size + 192
                        _1037 = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        if mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                            revert with 'NH{q', 65
                        if (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = (12 * ceil32(return_data.size)) + floor32(mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
                        mem[(12 * ceil32(return_data.size)) + 192] = mem[(11 * ceil32(return_data.size)) + mem[(11 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
                        require _1019 + (32 * _1037) + 32 <= return_data.size
                        idx = 0
                        s = (11 * ceil32(return_data.size)) + _1019 + 224
                        t = (12 * ceil32(return_data.size)) + 224
                        while idx < _1037:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1829 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1841 = mem[_1829]
                        require mem[_1829] == mem[_1829]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(stor2)
                        staticcall stor2.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1937 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1949 = mem[_1937]
                        require mem[_1937] == mem[_1937]
                        if address(arg1) == stor3:
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1841
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1841
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2078 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2078] == bool(mem[_2078])
                            mem[mem[64] + 4] = stor6
                            mem[mem[64] + 36] = _1949
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor6, _1949
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2198 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2198] == bool(mem[_2198])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1949
                            mem[mem[64] + 100] = _1841
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor6)
                            call stor6.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1949, _1841, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2414 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2414] == mem[_2414]
                            require mem[_2414 + 32] == mem[_2414 + 32]
                            require mem[_2414 + 64] == mem[_2414 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2690 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2750 = mem[_2690]
                            require mem[_2690] == mem[_2690]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2750
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2750
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2918 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2918] == bool(mem[_2918])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3062 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3098 = mem[_3062]
                            require mem[_3062] == mem[_3062]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3206 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3230 = mem[_3206]
                            require mem[_3206] == mem[_3206]
                            require mem[_3206 + 32] == mem[_3206 + 32]
                            require mem[_3206 + 64] == mem[_3206 + 92 len 4]
                            require mem[_3206 + 96] == mem[_3206 + 124 len 4]
                            mem[mem[64] + 4] = _2750
                            mem[mem[64] + 36] = _3098
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2750, _3098, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3374 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3374] == mem[_3374]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3470 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3470] == mem[_3470]
                            require mem[_3470 + 32] == mem[_3470 + 32]
                            require mem[_3470 + 64] == mem[_3470 + 92 len 4]
                            require mem[_3470 + 96] == mem[_3470 + 124 len 4]
                            if mem[_3470] < _3230:
                                revert with 'NH{q', 17
                            if mem[_3470] - _3230 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3686 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3710 = mem[_3686]
                            require mem[_3686] == mem[_3686]
                            if mem[_3686] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3824 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3878 = mem[_3824]
                                require mem[_3824] == mem[_3824]
                                if mem[_3824] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3878
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3878
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4040 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4040] == bool(mem[_4040])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3710
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3710
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3854 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3854] == bool(mem[_3854])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4041 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4089 = mem[_4041]
                                require mem[_4041] == mem[_4041]
                                if mem[_4041] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4089
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4089
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4166 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4166] == bool(mem[_4166])
                        else:
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1841
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1841
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2079 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2079] == bool(mem[_2079])
                            mem[mem[64] + 4] = stor5
                            mem[mem[64] + 36] = _1949
                            require ext_code.size(stor2)
                            call stor2.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor5, _1949
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2199 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2199] == bool(mem[_2199])
                            if block.timestamp > -61:
                                revert with 'NH{q', 17
                            mem[mem[64] + 68] = _1949
                            mem[mem[64] + 100] = _1841
                            mem[mem[64] + 132] = 0
                            mem[mem[64] + 164] = 0
                            mem[mem[64] + 196] = this.address
                            mem[mem[64] + 228] = block.timestamp + 60
                            require ext_code.size(stor5)
                            call stor5.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                                 gas gas_remaining wei
                                args stor2, address(arg1), _1949, _1841, 0, 0, address(this.address), block.timestamp + 60
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2415 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_2415] == mem[_2415]
                            require mem[_2415 + 32] == mem[_2415 + 32]
                            require mem[_2415 + 64] == mem[_2415 + 64]
                            mem[0] = address(arg1)
                            mem[32] = 11
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(stor11[address(arg1)])
                            staticcall stor11[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2691 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2751 = mem[_2691]
                            require mem[_2691] == mem[_2691]
                            mem[0] = stor11[address(arg1)]
                            mem[32] = 13
                            mem[mem[64] + 4] = stor13[stor11[address(arg1)]]
                            mem[mem[64] + 36] = _2751
                            require ext_code.size(stor11[address(arg1)])
                            call stor11[address(arg1)].approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args stor13[stor11[address(arg1)]], _2751
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2919 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2919] == bool(mem[_2919])
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3063 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3099 = mem[_3063]
                            require mem[_3063] == mem[_3063]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3207 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _3231 = mem[_3207]
                            require mem[_3207] == mem[_3207]
                            require mem[_3207 + 32] == mem[_3207 + 32]
                            require mem[_3207 + 64] == mem[_3207 + 92 len 4]
                            require mem[_3207 + 96] == mem[_3207 + 124 len 4]
                            mem[mem[64] + 4] = _2751
                            mem[mem[64] + 36] = _3099
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            call stor13[stor11[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args _2751, _3099, msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3375 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3375] == mem[_3375]
                            require ext_code.size(stor13[stor11[address(arg1)]])
                            staticcall stor13[stor11[address(arg1)]].bondInfo(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3471 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            require mem[_3471] == mem[_3471]
                            require mem[_3471 + 32] == mem[_3471 + 32]
                            require mem[_3471 + 64] == mem[_3471 + 92 len 4]
                            require mem[_3471 + 96] == mem[_3471 + 124 len 4]
                            if mem[_3471] < _3231:
                                revert with 'NH{q', 17
                            if mem[_3471] - _3231 < arg3:
                                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3687 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3711 = mem[_3687]
                            require mem[_3687] == mem[_3687]
                            if mem[_3687] <= 0:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3826 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3879 = mem[_3826]
                                require mem[_3826] == mem[_3826]
                                if mem[_3826] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _3879
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _3879
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4042 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4042] == bool(mem[_4042])
                            else:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = _3711
                                require ext_code.size(address(arg1))
                                call address(arg1).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, _3711
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3855 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3855] == bool(mem[_3855])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(stor2)
                                staticcall stor2.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4043 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4091 = mem[_4043]
                                require mem[_4043] == mem[_4043]
                                if mem[_4043] > 0:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _4091
                                    require ext_code.size(stor2)
                                    call stor2.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, _4091
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4167 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4167] == bool(mem[_4167])
}



}

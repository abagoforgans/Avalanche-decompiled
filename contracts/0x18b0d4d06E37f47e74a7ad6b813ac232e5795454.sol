contract main {




// =====================  Runtime code  =====================


#
#  - sub_183f6295(?)
#  - sub_9896fea0(?)
#
const sub_57ecc147(?) = 4


uint8 stor0;
uint8 stor0; offset 8
address owner; offset 16
uint256 stor0; offset 8
array of struct stor1;
uint256 sub_30ddae48;
address stor4;
address stor5;

function sub_30ddae48(?) {
    return sub_30ddae48
}

function owner() {
    return owner
}

function _fallback() payable {
    revert
}

function setOwner(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    owner = arg1
}

function sub_dc31dd14(?) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    sub_30ddae48 = arg1
}

function getSelector(string arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + arg1.length + 36 <= calldata.size
    return Mask(32, 224, sha3(arg1[all]))
}

function setPriceFeed(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    create contract with 0 wei
                    code: code.data[18472 len 928], address(arg1)
    if not create.new_address:
        revert with ext_call.return_data[0 len return_data.size]
    stor4 = address(create.new_address)
}

function initialize(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if uint8(stor0.field_8):
        if ext_code.size(this.address) > 0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
    else:
        if uint8(stor0.field_0):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
    if not uint8(stor0.field_8):
        Mask(248, 0, stor0.field_8) = 1
        uint8(stor0.field_0) = 1
    owner = arg1
    create contract with 0 wei
                    code: code.data[18472 len 928], address(arg2)
    if not create.new_address:
        revert with ext_call.return_data[0 len return_data.size]
    stor4 = address(create.new_address)
    sub_30ddae48 = arg3
    stor5 = 0x60ae616a2155ee3d9a68541ba4544862310933d4
    if not uint8(stor0.field_8):
        Mask(248, 0, stor0.field_8) = 0
}

function sub_336e5115(?) {
    require calldata.size - 4 >= 192
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    require arg1 + arg1.length + 36 <= calldata.size
    require arg2 == bool(arg2)
    require arg3 == arg3
    require arg4 == address(arg4)
    require arg5 == arg5
    require arg6 == bool(arg6)
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    if ext_code.size(address(arg4)) <= 0:
        revert with 0, 'FOREST: NFT Address is not a contract'
    stor1.length++
    if bool(stor1[stor1.length].field_0):
        if bool(stor1[stor1.length].field_0) == uint255(stor1[stor1.length].field_1) < 32:
            revert with 'NH{q', 34
        if arg1.length:
            stor1[stor1.length][].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor1[stor1.length].field_0 = 0
            idx = 0
            while uint255(stor1[stor1.length].field_1) + 31 / 32 > idx:
                stor1[(6 * stor1.length) + idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor1[stor1.length].field_0) == stor1[stor1.length].field_1 % 128 < 32:
            revert with 'NH{q', 34
        if arg1.length:
            stor1[stor1.length][].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor1[stor1.length].field_0 = 0
            idx = 0
            while stor1[stor1.length].field_1 % 128 + 31 / 32 > idx:
                stor1[(6 * stor1.length) + idx].field_0 = 0
                idx = idx + 1
                continue 
    uint8(stor1[stor1.length].field_256) = uint8(bool(arg2))
    stor1[stor1.length].field_512 = arg3
    address(stor1[stor1.length].field_768) = address(arg4)
    stor1[stor1.length].field_1024 = arg5
    uint8(stor1[stor1.length].field_1280) = uint8(bool(arg6))
}

function NFTs(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < stor1.length
    if bool(stor1[arg1].field_0):
        if bool(stor1[arg1].field_0) == uint255(stor1[arg1].field_1) < 32:
            revert with 'NH{q', 34
        if bool(stor1[arg1].field_0):
            if bool(stor1[arg1].field_0) == uint255(stor1[arg1].field_1) < 32:
                revert with 'NH{q', 34
            if uint255(stor1[arg1].field_1):
                if 31 >= uint255(stor1[arg1].field_1):
                    mem[128] = 256 * Mask(248, 0, stor1[arg1].field_8)
                else:
                    mem[128] = stor1[arg1].field_0
                    idx = 128
                    s = 0
                    while uint255(stor1[arg1].field_1) + 96 > idx:
                        mem[idx + 32] = stor1[(6 * arg1) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor1[arg1].field_0) == stor1[arg1].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if stor1[arg1].field_1 % 128:
                if 31 >= stor1[arg1].field_1 % 128:
                    mem[128] = 256 * Mask(248, 0, stor1[arg1].field_8)
                else:
                    mem[128] = stor1[arg1].field_0
                    idx = 128
                    s = 0
                    while stor1[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor1[(6 * arg1) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        return Array(len=2 * Mask(256, -1, uint255(stor1[arg1].field_1)), data=mem[128 len ceil32(uint255(stor1[arg1].field_1))]), 
               bool(uint8(stor1[arg1].field_256)),
               stor1[arg1].field_512,
               address(stor1[arg1].field_768),
               stor1[arg1].field_1024,
               bool(uint8(stor1[arg1].field_1280))
    if bool(stor1[arg1].field_0) == stor1[arg1].field_1 % 128 < 32:
        revert with 'NH{q', 34
    if bool(stor1[arg1].field_0):
        if bool(stor1[arg1].field_0) == uint255(stor1[arg1].field_1) < 32:
            revert with 'NH{q', 34
        if uint255(stor1[arg1].field_1):
            if 31 >= uint255(stor1[arg1].field_1):
                mem[128] = 256 * Mask(248, 0, stor1[arg1].field_8)
            else:
                mem[128] = stor1[arg1].field_0
                idx = 128
                s = 0
                while uint255(stor1[arg1].field_1) + 96 > idx:
                    mem[idx + 32] = stor1[(6 * arg1) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if bool(stor1[arg1].field_0) == stor1[arg1].field_1 % 128 < 32:
            revert with 'NH{q', 34
        if stor1[arg1].field_1 % 128:
            if 31 >= stor1[arg1].field_1 % 128:
                mem[128] = 256 * Mask(248, 0, stor1[arg1].field_8)
            else:
                mem[128] = stor1[arg1].field_0
                idx = 128
                s = 0
                while stor1[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor1[(6 * arg1) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    return Array(len=stor1[arg1].field_0 % 128, data=mem[128 len ceil32(stor1[arg1].field_1 % 128)]), 
           bool(uint8(stor1[arg1].field_256)),
           stor1[arg1].field_512,
           address(stor1[arg1].field_768),
           stor1[arg1].field_1024,
           bool(uint8(stor1[arg1].field_1280))
}

function sub_6e090a2b(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    idx = 0
    while idx < stor1.length:
        _329 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _331 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _329:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1[idx].field_0):
                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                        revert with 'NH{q', 34
                    _393 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1[idx].field_1):
                            if 31 < uint255(stor1[idx].field_1):
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _393 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1[idx].field_1 % 128:
                            if 31 < stor1[idx].field_1 % 128:
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _393 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                else:
                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    _396 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1[idx].field_1):
                            if 31 < uint255(stor1[idx].field_1):
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _396 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1[idx].field_1 % 128:
                            if 31 < stor1[idx].field_1 % 128:
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _396 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _399 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _399 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _399 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _403 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _403 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _403 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_331 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _331 + uint255(stor1[idx].field_1) - mem[64]]) != _329:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _722 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _722 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _722 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _724 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _724 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _724 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _329:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1[idx].field_0):
                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                        revert with 'NH{q', 34
                    _400 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1[idx].field_1):
                            if 31 < uint255(stor1[idx].field_1):
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _400 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1[idx].field_1 % 128:
                            if 31 < stor1[idx].field_1 % 128:
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _400 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                else:
                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    _404 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1[idx].field_1):
                            if 31 < uint255(stor1[idx].field_1):
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _404 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1[idx].field_1 % 128:
                            if 31 < stor1[idx].field_1 % 128:
                                mem[0] = (6 * idx) + sha3(1)
                                s = mem[64] + 32
                                t = sha3(mem[0])
                                while _404 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _407 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _407 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _407 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _409 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _409 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _409 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_331 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _331 + stor1[idx].field_1 % 128 - mem[64]]) != _329:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _723 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _723 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _723 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _725 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1[idx].field_1):
                                if 31 < uint255(stor1[idx].field_1):
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _725 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1[idx].field_1 % 128:
                                if 31 < stor1[idx].field_1 % 128:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = mem[64] + 32
                                    t = sha3(mem[0])
                                    while _725 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
        return stor1[idx].field_1024
    if 10^18 >= stor1.length:
        revert with 'NH{q', 50
    mem[64] = mem[64] + 192
    if bool(stor1.field_1536 * 10^18):
        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
            revert with 'NH{q', 34
        _334 = mem[64]
        if bool(stor1.field_1536 * 10^18):
            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                revert with 'NH{q', 34
            if uint255(stor1.field_1536000000000000000001):
                if 31 < uint255(stor1.field_1536000000000000000001):
                    idx = mem[64] + 32
                    s = 0
                    while _334 + uint255(stor1.field_1536000000000000000001) > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                revert with 'NH{q', 34
            if stor1.field_1536000000000000000001 % 128:
                if 31 < stor1.field_1536000000000000000001 % 128:
                    idx = mem[64] + 32
                    s = 0
                    while _334 + stor1.field_1536000000000000000001 % 128 > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
    else:
        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
            revert with 'NH{q', 34
        _335 = mem[64]
        if bool(stor1.field_1536 * 10^18):
            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                revert with 'NH{q', 34
            if uint255(stor1.field_1536000000000000000001):
                if 31 < uint255(stor1.field_1536000000000000000001):
                    idx = mem[64] + 32
                    s = 0
                    while _335 + uint255(stor1.field_1536000000000000000001) > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                revert with 'NH{q', 34
            if stor1.field_1536000000000000000001 % 128:
                if 31 < stor1.field_1536000000000000000001 % 128:
                    idx = mem[64] + 32
                    s = 0
                    while _335 + stor1.field_1536000000000000000001 % 128 > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
    return uint256(stor1.field_1536000000000000001024)
}

function sub_f392247f(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    idx = 0
    while idx < stor1.length:
        _341 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _343 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _341:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _691 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _699 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _691:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_699 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _699 + uint255(stor1[idx].field_1) - mem[64]]) != _691:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _691:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_699 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _699 + stor1[idx].field_1 % 128 - mem[64]]) != _691:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    if bool(uint8(stor1[idx].field_256)) != 1:
                        return 0
                    return 1
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _693 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _701 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _693:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_701 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _701 + uint255(stor1[idx].field_1) - mem[64]]) != _693:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _693:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_701 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _701 + stor1[idx].field_1 % 128 - mem[64]]) != _693:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if bool(uint8(stor1[idx].field_256)) != 1:
                            return 0
                        return 1
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_343 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _343 + uint255(stor1[idx].field_1) - mem[64]]) != _341:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _1017 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _1021 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _1017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_1021 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _1021 + uint255(stor1[idx].field_1) - mem[64]]) != _1017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _1017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_1021 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _1021 + stor1[idx].field_1 % 128 - mem[64]]) != _1017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if bool(uint8(stor1[idx].field_256)) != 1:
                            return 0
                        return 1
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _341:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _695 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _703 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _695:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_703 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _703 + uint255(stor1[idx].field_1) - mem[64]]) != _695:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _695:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_703 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _703 + stor1[idx].field_1 % 128 - mem[64]]) != _695:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    if bool(uint8(stor1[idx].field_256)) != 1:
                        return 0
                    return 1
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _697 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _705 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _697:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_705 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _705 + uint255(stor1[idx].field_1) - mem[64]]) != _697:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _697:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_705 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _705 + stor1[idx].field_1 % 128 - mem[64]]) != _697:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if bool(uint8(stor1[idx].field_256)) != 1:
                            return 0
                        return 1
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_343 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _343 + stor1[idx].field_1 % 128 - mem[64]]) != _341:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _1019 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _1023 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _1019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_1023 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _1023 + uint255(stor1[idx].field_1) - mem[64]]) != _1019:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _1019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_1023 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _1023 + stor1[idx].field_1 % 128 - mem[64]]) != _1019:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if bool(uint8(stor1[idx].field_256)) != 1:
                            return 0
                        return 1
        if 10^18 >= stor1.length:
            revert with 'NH{q', 50
        if bool(uint8(stor1.field_1536000000000000000256)) != 1:
            return 0
        return 1
    revert with 0, 'FOREST: Target NFT does not exist'
}

function sub_5bbedabc(?) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    idx = 0
    while idx < stor1.length:
        _175 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _177 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _175:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _357 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _365 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _357:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_365 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _365 + uint255(stor1[idx].field_1) - mem[64]]) != _357:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _357:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_365 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _365 + stor1[idx].field_1 % 128 - mem[64]]) != _357:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    if stor1[idx].field_1024 > -arg2 - 1:
                        revert with 'NH{q', 17
                    stor1[idx].field_1024 += arg2
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _359 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _367 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _359:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_367 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _367 + uint255(stor1[idx].field_1) - mem[64]]) != _359:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _359:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_367 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _367 + stor1[idx].field_1 % 128 - mem[64]]) != _359:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if stor1[idx].field_1024 > -arg2 - 1:
                            revert with 'NH{q', 17
                        stor1[idx].field_1024 += arg2
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_177 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _177 + uint255(stor1[idx].field_1) - mem[64]]) != _175:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _515 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _519 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _515:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _519 + uint255(stor1[idx].field_1) - mem[64]]) != _515:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _515:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _519 + stor1[idx].field_1 % 128 - mem[64]]) != _515:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if stor1[idx].field_1024 > -arg2 - 1:
                            revert with 'NH{q', 17
                        stor1[idx].field_1024 += arg2
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _175:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _361 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _369 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _361:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_369 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _369 + uint255(stor1[idx].field_1) - mem[64]]) != _361:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _361:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_369 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _369 + stor1[idx].field_1 % 128 - mem[64]]) != _361:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    if stor1[idx].field_1024 > -arg2 - 1:
                        revert with 'NH{q', 17
                    stor1[idx].field_1024 += arg2
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _363 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _371 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _363:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_371 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _371 + uint255(stor1[idx].field_1) - mem[64]]) != _363:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _363:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_371 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _371 + stor1[idx].field_1 % 128 - mem[64]]) != _363:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if stor1[idx].field_1024 > -arg2 - 1:
                            revert with 'NH{q', 17
                        stor1[idx].field_1024 += arg2
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_177 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _177 + stor1[idx].field_1 % 128 - mem[64]]) != _175:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _517 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _521 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _517:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_521 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _521 + uint255(stor1[idx].field_1) - mem[64]]) != _517:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _517:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_521 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _521 + stor1[idx].field_1 % 128 - mem[64]]) != _517:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                        if idx >= stor1.length:
                            revert with 'NH{q', 50
                        if stor1[idx].field_1024 > -arg2 - 1:
                            revert with 'NH{q', 17
                        stor1[idx].field_1024 += arg2
        if 10^18 >= stor1.length:
            revert with 'NH{q', 50
        if uint256(stor1.field_1536000000000000001024) > -arg2 - 1:
            revert with 'NH{q', 17
        uint256(stor1.field_1536000000000000001024) += arg2
    revert with 0, 'FOREST: Target NFT does not exist'
}

function sub_5a79b06a(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    idx = 0
    while idx < stor1.length:
        _665 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _667 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _665:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _727 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor1[idx].field_0):
                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                        revert with 'NH{q', 34
                    _746 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                    mem[_746] = uint255(stor1[idx].field_1)
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1[idx].field_1):
                            mem[_727] = _746
                            mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_727 + 64] = stor1[idx].field_512
                            mem[_727 + 96] = address(stor1[idx].field_768)
                            mem[_727 + 128] = stor1[idx].field_1024
                            mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _761 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_761] == mem[_761]
                            if bool(mem[_761] > 0) and mem[_761] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_761] < 0) and mem[_761] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_761]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_761]
                        else:
                            if 31 >= uint255(stor1[idx].field_1):
                                mem[_746 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_727] = _746
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _796 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_796] == mem[_796]
                                if bool(mem[_796] > 0) and mem[_796] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_796] < 0) and mem[_796] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_796]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_796]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_746 + 32] = stor1[idx].field_0
                                s = _746 + 32
                                t = sha3(mem[0])
                                while _746 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_727] = _746
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1370 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1370] == mem[_1370]
                                if bool(mem[_1370] > 0) and mem[_1370] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1370] < 0) and mem[_1370] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1370]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1370]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1[idx].field_1 % 128:
                            mem[_727] = _746
                            mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_727 + 64] = stor1[idx].field_512
                            mem[_727 + 96] = address(stor1[idx].field_768)
                            mem[_727 + 128] = stor1[idx].field_1024
                            mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _775 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_775] == mem[_775]
                            if bool(mem[_775] > 0) and mem[_775] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_775] < 0) and mem[_775] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_775]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_775]
                        else:
                            if 31 >= stor1[idx].field_1 % 128:
                                mem[_746 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_727] = _746
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _828 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_828] == mem[_828]
                                if bool(mem[_828] > 0) and mem[_828] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_828] < 0) and mem[_828] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_828]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_828]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_746 + 32] = stor1[idx].field_0
                                s = _746 + 32
                                t = sha3(mem[0])
                                while _746 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_727] = _746
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1371 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1371] == mem[_1371]
                                if bool(mem[_1371] > 0) and mem[_1371] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1371] < 0) and mem[_1371] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1371]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1371]
                else:
                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    _747 = mem[64]
                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                    mem[_747] = stor1[idx].field_1 % 128
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1[idx].field_1):
                            mem[_727] = _747
                            mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_727 + 64] = stor1[idx].field_512
                            mem[_727 + 96] = address(stor1[idx].field_768)
                            mem[_727 + 128] = stor1[idx].field_1024
                            mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _777 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_777] == mem[_777]
                            if bool(mem[_777] > 0) and mem[_777] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_777] < 0) and mem[_777] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_777]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_777]
                        else:
                            if 31 >= uint255(stor1[idx].field_1):
                                mem[_747 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_727] = _747
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _829 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_829] == mem[_829]
                                if bool(mem[_829] > 0) and mem[_829] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_829] < 0) and mem[_829] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_829]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_829]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_747 + 32] = stor1[idx].field_0
                                s = _747 + 32
                                t = sha3(mem[0])
                                while _747 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_727] = _747
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1372 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1372] == mem[_1372]
                                if bool(mem[_1372] > 0) and mem[_1372] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1372] < 0) and mem[_1372] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1372]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1372]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1[idx].field_1 % 128:
                            mem[_727] = _747
                            mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_727 + 64] = stor1[idx].field_512
                            mem[_727 + 96] = address(stor1[idx].field_768)
                            mem[_727 + 128] = stor1[idx].field_1024
                            mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _801 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_801] == mem[_801]
                            if bool(mem[_801] > 0) and mem[_801] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_801] < 0) and mem[_801] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_801]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_801]
                        else:
                            if 31 >= stor1[idx].field_1 % 128:
                                mem[_747 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_727] = _747
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _861 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_861] == mem[_861]
                                if bool(mem[_861] > 0) and mem[_861] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_861] < 0) and mem[_861] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_861]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_861]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_747 + 32] = stor1[idx].field_0
                                s = _747 + 32
                                t = sha3(mem[0])
                                while _747 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_727] = _747
                                mem[_727 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_727 + 64] = stor1[idx].field_512
                                mem[_727 + 96] = address(stor1[idx].field_768)
                                mem[_727 + 128] = stor1[idx].field_1024
                                mem[_727 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1373 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1373] == mem[_1373]
                                if bool(mem[_1373] > 0) and mem[_1373] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1373] < 0) and mem[_1373] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1373]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1373]
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _734 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _750 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                        mem[_750] = uint255(stor1[idx].field_1)
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_734] = _750
                                mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_734 + 64] = stor1[idx].field_512
                                mem[_734 + 96] = address(stor1[idx].field_768)
                                mem[_734 + 128] = stor1[idx].field_1024
                                mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _781 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_781] == mem[_781]
                                if bool(mem[_781] > 0) and mem[_781] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_781] < 0) and mem[_781] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_781]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_781]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_750 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_734] = _750
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _832 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_832] == mem[_832]
                                    if bool(mem[_832] > 0) and mem[_832] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_832] < 0) and mem[_832] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_832]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_832]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_750 + 32] = stor1[idx].field_0
                                    s = _750 + 32
                                    t = sha3(mem[0])
                                    while _750 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_734] = _750
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1374 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1374] == mem[_1374]
                                    if bool(mem[_1374] > 0) and mem[_1374] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1374] < 0) and mem[_1374] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1374]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1374]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_734] = _750
                                mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_734 + 64] = stor1[idx].field_512
                                mem[_734 + 96] = address(stor1[idx].field_768)
                                mem[_734 + 128] = stor1[idx].field_1024
                                mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _805 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_805] == mem[_805]
                                if bool(mem[_805] > 0) and mem[_805] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_805] < 0) and mem[_805] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_805]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_805]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_750 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_734] = _750
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _867 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_867] == mem[_867]
                                    if bool(mem[_867] > 0) and mem[_867] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_867] < 0) and mem[_867] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_867]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_867]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_750 + 32] = stor1[idx].field_0
                                    s = _750 + 32
                                    t = sha3(mem[0])
                                    while _750 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_734] = _750
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1375 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1375] == mem[_1375]
                                    if bool(mem[_1375] > 0) and mem[_1375] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1375] < 0) and mem[_1375] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1375]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1375]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _752 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                        mem[_752] = stor1[idx].field_1 % 128
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_734] = _752
                                mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_734 + 64] = stor1[idx].field_512
                                mem[_734 + 96] = address(stor1[idx].field_768)
                                mem[_734 + 128] = stor1[idx].field_1024
                                mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _807 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_807] == mem[_807]
                                if bool(mem[_807] > 0) and mem[_807] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_807] < 0) and mem[_807] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_807]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_807]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_752 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_734] = _752
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _868 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_868] == mem[_868]
                                    if bool(mem[_868] > 0) and mem[_868] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_868] < 0) and mem[_868] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_868]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_868]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_752 + 32] = stor1[idx].field_0
                                    s = _752 + 32
                                    t = sha3(mem[0])
                                    while _752 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_734] = _752
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1376 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1376] == mem[_1376]
                                    if bool(mem[_1376] > 0) and mem[_1376] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1376] < 0) and mem[_1376] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1376]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1376]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_734] = _752
                                mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_734 + 64] = stor1[idx].field_512
                                mem[_734 + 96] = address(stor1[idx].field_768)
                                mem[_734 + 128] = stor1[idx].field_1024
                                mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _837 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_837] == mem[_837]
                                if bool(mem[_837] > 0) and mem[_837] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_837] < 0) and mem[_837] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_837]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_837]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_752 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_734] = _752
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_905] == mem[_905]
                                    if bool(mem[_905] > 0) and mem[_905] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_905] < 0) and mem[_905] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_905]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_905]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_752 + 32] = stor1[idx].field_0
                                    s = _752 + 32
                                    t = sha3(mem[0])
                                    while _752 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_734] = _752
                                    mem[_734 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_734 + 64] = stor1[idx].field_512
                                    mem[_734 + 96] = address(stor1[idx].field_768)
                                    mem[_734 + 128] = stor1[idx].field_1024
                                    mem[_734 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1377 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1377] == mem[_1377]
                                    if bool(mem[_1377] > 0) and mem[_1377] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1377] < 0) and mem[_1377] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1377]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1377]
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_667 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _667 + uint255(stor1[idx].field_1) - mem[64]]) != _665:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _1411 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _1414 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                        mem[_1414] = uint255(stor1[idx].field_1)
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_1411] = _1414
                                mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1411 + 64] = stor1[idx].field_512
                                mem[_1411 + 96] = address(stor1[idx].field_768)
                                mem[_1411 + 128] = stor1[idx].field_1024
                                mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1422 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1422] == mem[_1422]
                                if bool(mem[_1422] > 0) and mem[_1422] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1422] < 0) and mem[_1422] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1422]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1422]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_1414 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1411] = _1414
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1450 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1450] == mem[_1450]
                                    if bool(mem[_1450] > 0) and mem[_1450] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1450] < 0) and mem[_1450] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1450]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1450]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1414 + 32] = stor1[idx].field_0
                                    s = _1414 + 32
                                    t = sha3(mem[0])
                                    while _1414 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1411] = _1414
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1670 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1670] == mem[_1670]
                                    if bool(mem[_1670] > 0) and mem[_1670] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1670] < 0) and mem[_1670] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1670]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1670]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_1411] = _1414
                                mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1411 + 64] = stor1[idx].field_512
                                mem[_1411 + 96] = address(stor1[idx].field_768)
                                mem[_1411 + 128] = stor1[idx].field_1024
                                mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1436 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1436] == mem[_1436]
                                if bool(mem[_1436] > 0) and mem[_1436] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1436] < 0) and mem[_1436] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1436]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1436]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_1414 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1411] = _1414
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1467 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1467] == mem[_1467]
                                    if bool(mem[_1467] > 0) and mem[_1467] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1467] < 0) and mem[_1467] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1467]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1467]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1414 + 32] = stor1[idx].field_0
                                    s = _1414 + 32
                                    t = sha3(mem[0])
                                    while _1414 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1411] = _1414
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1671 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1671] == mem[_1671]
                                    if bool(mem[_1671] > 0) and mem[_1671] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1671] < 0) and mem[_1671] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1671]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1671]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _1416 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                        mem[_1416] = stor1[idx].field_1 % 128
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_1411] = _1416
                                mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1411 + 64] = stor1[idx].field_512
                                mem[_1411 + 96] = address(stor1[idx].field_768)
                                mem[_1411 + 128] = stor1[idx].field_1024
                                mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1438 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1438] == mem[_1438]
                                if bool(mem[_1438] > 0) and mem[_1438] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1438] < 0) and mem[_1438] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1438]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1438]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_1416 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1411] = _1416
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1468 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1468] == mem[_1468]
                                    if bool(mem[_1468] > 0) and mem[_1468] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1468] < 0) and mem[_1468] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1468]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1468]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1416 + 32] = stor1[idx].field_0
                                    s = _1416 + 32
                                    t = sha3(mem[0])
                                    while _1416 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1411] = _1416
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1672 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1672] == mem[_1672]
                                    if bool(mem[_1672] > 0) and mem[_1672] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1672] < 0) and mem[_1672] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1672]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1672]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_1411] = _1416
                                mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1411 + 64] = stor1[idx].field_512
                                mem[_1411 + 96] = address(stor1[idx].field_768)
                                mem[_1411 + 128] = stor1[idx].field_1024
                                mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1455 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1455] == mem[_1455]
                                if bool(mem[_1455] > 0) and mem[_1455] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1455] < 0) and mem[_1455] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1455]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1455]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_1416 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1411] = _1416
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1485 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1485] == mem[_1485]
                                    if bool(mem[_1485] > 0) and mem[_1485] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1485] < 0) and mem[_1485] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1485]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1485]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1416 + 32] = stor1[idx].field_0
                                    s = _1416 + 32
                                    t = sha3(mem[0])
                                    while _1416 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1411] = _1416
                                    mem[_1411 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1411 + 64] = stor1[idx].field_512
                                    mem[_1411 + 96] = address(stor1[idx].field_768)
                                    mem[_1411 + 128] = stor1[idx].field_1024
                                    mem[_1411 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1673 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1673] == mem[_1673]
                                    if bool(mem[_1673] > 0) and mem[_1673] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1673] < 0) and mem[_1673] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1673]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1673]
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _665:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _736 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor1[idx].field_0):
                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                        revert with 'NH{q', 34
                    _751 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                    mem[_751] = uint255(stor1[idx].field_1)
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1[idx].field_1):
                            mem[_736] = _751
                            mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_736 + 64] = stor1[idx].field_512
                            mem[_736 + 96] = address(stor1[idx].field_768)
                            mem[_736 + 128] = stor1[idx].field_1024
                            mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _787 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_787] == mem[_787]
                            if bool(mem[_787] > 0) and mem[_787] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_787] < 0) and mem[_787] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_787]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_787]
                        else:
                            if 31 >= uint255(stor1[idx].field_1):
                                mem[_751 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_736] = _751
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _839 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_839] == mem[_839]
                                if bool(mem[_839] > 0) and mem[_839] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_839] < 0) and mem[_839] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_839]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_839]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_751 + 32] = stor1[idx].field_0
                                s = _751 + 32
                                t = sha3(mem[0])
                                while _751 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_736] = _751
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1378 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1378] == mem[_1378]
                                if bool(mem[_1378] > 0) and mem[_1378] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1378] < 0) and mem[_1378] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1378]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1378]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1[idx].field_1 % 128:
                            mem[_736] = _751
                            mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_736 + 64] = stor1[idx].field_512
                            mem[_736 + 96] = address(stor1[idx].field_768)
                            mem[_736 + 128] = stor1[idx].field_1024
                            mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _813 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_813] == mem[_813]
                            if bool(mem[_813] > 0) and mem[_813] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_813] < 0) and mem[_813] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_813]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_813]
                        else:
                            if 31 >= stor1[idx].field_1 % 128:
                                mem[_751 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_736] = _751
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _874 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_874] == mem[_874]
                                if bool(mem[_874] > 0) and mem[_874] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_874] < 0) and mem[_874] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_874]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_874]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_751 + 32] = stor1[idx].field_0
                                s = _751 + 32
                                t = sha3(mem[0])
                                while _751 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_736] = _751
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1379 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1379] == mem[_1379]
                                if bool(mem[_1379] > 0) and mem[_1379] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1379] < 0) and mem[_1379] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1379]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1379]
                else:
                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    _753 = mem[64]
                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                    mem[_753] = stor1[idx].field_1 % 128
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1[idx].field_1):
                            mem[_736] = _753
                            mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_736 + 64] = stor1[idx].field_512
                            mem[_736 + 96] = address(stor1[idx].field_768)
                            mem[_736 + 128] = stor1[idx].field_1024
                            mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _815 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_815] == mem[_815]
                            if bool(mem[_815] > 0) and mem[_815] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_815] < 0) and mem[_815] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_815]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_815]
                        else:
                            if 31 >= uint255(stor1[idx].field_1):
                                mem[_753 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_736] = _753
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _875 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_875] == mem[_875]
                                if bool(mem[_875] > 0) and mem[_875] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_875] < 0) and mem[_875] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_875]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_875]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_753 + 32] = stor1[idx].field_0
                                s = _753 + 32
                                t = sha3(mem[0])
                                while _753 + uint255(stor1[idx].field_1) > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_736] = _753
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1380 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1380] == mem[_1380]
                                if bool(mem[_1380] > 0) and mem[_1380] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1380] < 0) and mem[_1380] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1380]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1380]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1[idx].field_1 % 128:
                            mem[_736] = _753
                            mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                            mem[_736 + 64] = stor1[idx].field_512
                            mem[_736 + 96] = address(stor1[idx].field_768)
                            mem[_736 + 128] = stor1[idx].field_1024
                            mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                            staticcall stor4.getLatestPrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _844 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_844] == mem[_844]
                            if bool(mem[_844] > 0) and mem[_844] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                revert with 'NH{q', 17
                            if bool(mem[_844] < 0) and mem[_844] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                revert with 'NH{q', 17
                            if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                revert with 'NH{q', 17
                            if not 10^10 * mem[_844]:
                                revert with 'NH{q', 18
                            mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_844]
                        else:
                            if 31 >= stor1[idx].field_1 % 128:
                                mem[_753 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                mem[_736] = _753
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _913 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_913] == mem[_913]
                                if bool(mem[_913] > 0) and mem[_913] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_913] < 0) and mem[_913] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_913]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_913]
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                mem[_753 + 32] = stor1[idx].field_0
                                s = _753 + 32
                                t = sha3(mem[0])
                                while _753 + stor1[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t].field_0
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_736] = _753
                                mem[_736 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_736 + 64] = stor1[idx].field_512
                                mem[_736 + 96] = address(stor1[idx].field_768)
                                mem[_736 + 128] = stor1[idx].field_1024
                                mem[_736 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1381 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1381] == mem[_1381]
                                if bool(mem[_1381] > 0) and mem[_1381] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1381] < 0) and mem[_1381] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1381]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1381]
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _742 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _756 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                        mem[_756] = uint255(stor1[idx].field_1)
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_742] = _756
                                mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_742 + 64] = stor1[idx].field_512
                                mem[_742 + 96] = address(stor1[idx].field_768)
                                mem[_742 + 128] = stor1[idx].field_1024
                                mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _819 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_819] == mem[_819]
                                if bool(mem[_819] > 0) and mem[_819] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_819] < 0) and mem[_819] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_819]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_819]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_756 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_742] = _756
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _878 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_878] == mem[_878]
                                    if bool(mem[_878] > 0) and mem[_878] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_878] < 0) and mem[_878] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_878]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_878]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_756 + 32] = stor1[idx].field_0
                                    s = _756 + 32
                                    t = sha3(mem[0])
                                    while _756 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_742] = _756
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1382 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1382] == mem[_1382]
                                    if bool(mem[_1382] > 0) and mem[_1382] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1382] < 0) and mem[_1382] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1382]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1382]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_742] = _756
                                mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_742 + 64] = stor1[idx].field_512
                                mem[_742 + 96] = address(stor1[idx].field_768)
                                mem[_742 + 128] = stor1[idx].field_1024
                                mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _848 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_848] == mem[_848]
                                if bool(mem[_848] > 0) and mem[_848] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_848] < 0) and mem[_848] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_848]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_848]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_756 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_742] = _756
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _919 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_919] == mem[_919]
                                    if bool(mem[_919] > 0) and mem[_919] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_919] < 0) and mem[_919] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_919]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_919]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_756 + 32] = stor1[idx].field_0
                                    s = _756 + 32
                                    t = sha3(mem[0])
                                    while _756 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_742] = _756
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1383 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1383] == mem[_1383]
                                    if bool(mem[_1383] > 0) and mem[_1383] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1383] < 0) and mem[_1383] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1383]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1383]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _757 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                        mem[_757] = stor1[idx].field_1 % 128
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_742] = _757
                                mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_742 + 64] = stor1[idx].field_512
                                mem[_742 + 96] = address(stor1[idx].field_768)
                                mem[_742 + 128] = stor1[idx].field_1024
                                mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _850 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_850] == mem[_850]
                                if bool(mem[_850] > 0) and mem[_850] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_850] < 0) and mem[_850] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_850]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_850]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_757 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_742] = _757
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _920 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_920] == mem[_920]
                                    if bool(mem[_920] > 0) and mem[_920] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_920] < 0) and mem[_920] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_920]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_920]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_757 + 32] = stor1[idx].field_0
                                    s = _757 + 32
                                    t = sha3(mem[0])
                                    while _757 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_742] = _757
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1384 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1384] == mem[_1384]
                                    if bool(mem[_1384] > 0) and mem[_1384] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1384] < 0) and mem[_1384] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1384]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1384]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_742] = _757
                                mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_742 + 64] = stor1[idx].field_512
                                mem[_742 + 96] = address(stor1[idx].field_768)
                                mem[_742 + 128] = stor1[idx].field_1024
                                mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _883 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_883] == mem[_883]
                                if bool(mem[_883] > 0) and mem[_883] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_883] < 0) and mem[_883] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_883]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_883]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_757 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_742] = _757
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _961 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_961] == mem[_961]
                                    if bool(mem[_961] > 0) and mem[_961] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_961] < 0) and mem[_961] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_961]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_961]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_757 + 32] = stor1[idx].field_0
                                    s = _757 + 32
                                    t = sha3(mem[0])
                                    while _757 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_742] = _757
                                    mem[_742 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_742 + 64] = stor1[idx].field_512
                                    mem[_742 + 96] = address(stor1[idx].field_768)
                                    mem[_742 + 128] = stor1[idx].field_1024
                                    mem[_742 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1385 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1385] == mem[_1385]
                                    if bool(mem[_1385] > 0) and mem[_1385] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1385] < 0) and mem[_1385] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1385]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1385]
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_667 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _667 + stor1[idx].field_1 % 128 - mem[64]]) != _665:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _1413 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        _1415 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                        mem[_1415] = uint255(stor1[idx].field_1)
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_1413] = _1415
                                mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1413 + 64] = stor1[idx].field_512
                                mem[_1413 + 96] = address(stor1[idx].field_768)
                                mem[_1413 + 128] = stor1[idx].field_1024
                                mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1428 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1428] == mem[_1428]
                                if bool(mem[_1428] > 0) and mem[_1428] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1428] < 0) and mem[_1428] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1428]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1428]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_1415 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1413] = _1415
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1457 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1457] == mem[_1457]
                                    if bool(mem[_1457] > 0) and mem[_1457] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1457] < 0) and mem[_1457] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1457]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1457]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1415 + 32] = stor1[idx].field_0
                                    s = _1415 + 32
                                    t = sha3(mem[0])
                                    while _1415 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1413] = _1415
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1674 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1674] == mem[_1674]
                                    if bool(mem[_1674] > 0) and mem[_1674] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1674] < 0) and mem[_1674] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1674]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1674]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_1413] = _1415
                                mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1413 + 64] = stor1[idx].field_512
                                mem[_1413 + 96] = address(stor1[idx].field_768)
                                mem[_1413 + 128] = stor1[idx].field_1024
                                mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1444 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1444] == mem[_1444]
                                if bool(mem[_1444] > 0) and mem[_1444] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1444] < 0) and mem[_1444] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1444]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1444]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_1415 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1413] = _1415
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1474 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1474] == mem[_1474]
                                    if bool(mem[_1474] > 0) and mem[_1474] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1474] < 0) and mem[_1474] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1474]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1474]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1415 + 32] = stor1[idx].field_0
                                    s = _1415 + 32
                                    t = sha3(mem[0])
                                    while _1415 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1413] = _1415
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1675 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1675] == mem[_1675]
                                    if bool(mem[_1675] > 0) and mem[_1675] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1675] < 0) and mem[_1675] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1675]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1675]
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        _1417 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                        mem[_1417] = stor1[idx].field_1 % 128
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1[idx].field_1):
                                mem[_1413] = _1417
                                mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1413 + 64] = stor1[idx].field_512
                                mem[_1413 + 96] = address(stor1[idx].field_768)
                                mem[_1413 + 128] = stor1[idx].field_1024
                                mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1446 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1446] == mem[_1446]
                                if bool(mem[_1446] > 0) and mem[_1446] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1446] < 0) and mem[_1446] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1446]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1446]
                            else:
                                if 31 >= uint255(stor1[idx].field_1):
                                    mem[_1417 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1413] = _1417
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1475 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1475] == mem[_1475]
                                    if bool(mem[_1475] > 0) and mem[_1475] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1475] < 0) and mem[_1475] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1475]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1475]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1417 + 32] = stor1[idx].field_0
                                    s = _1417 + 32
                                    t = sha3(mem[0])
                                    while _1417 + uint255(stor1[idx].field_1) > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1413] = _1417
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1676 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1676] == mem[_1676]
                                    if bool(mem[_1676] > 0) and mem[_1676] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1676] < 0) and mem[_1676] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1676]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1676]
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1[idx].field_1 % 128:
                                mem[_1413] = _1417
                                mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                mem[_1413 + 64] = stor1[idx].field_512
                                mem[_1413 + 96] = address(stor1[idx].field_768)
                                mem[_1413 + 128] = stor1[idx].field_1024
                                mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                staticcall stor4.getLatestPrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1462 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1462] == mem[_1462]
                                if bool(mem[_1462] > 0) and mem[_1462] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                    revert with 'NH{q', 17
                                if bool(mem[_1462] < 0) and mem[_1462] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                    revert with 'NH{q', 17
                                if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                    revert with 'NH{q', 17
                                if not 10^10 * mem[_1462]:
                                    revert with 'NH{q', 18
                                mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1462]
                            else:
                                if 31 >= stor1[idx].field_1 % 128:
                                    mem[_1417 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                    mem[_1413] = _1417
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1493 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1493] == mem[_1493]
                                    if bool(mem[_1493] > 0) and mem[_1493] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1493] < 0) and mem[_1493] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1493]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1493]
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    mem[_1417 + 32] = stor1[idx].field_0
                                    s = _1417 + 32
                                    t = sha3(mem[0])
                                    while _1417 + stor1[idx].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t].field_0
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    mem[_1413] = _1417
                                    mem[_1413 + 32] = bool(uint8(stor1[idx].field_256))
                                    mem[_1413 + 64] = stor1[idx].field_512
                                    mem[_1413 + 96] = address(stor1[idx].field_768)
                                    mem[_1413 + 128] = stor1[idx].field_1024
                                    mem[_1413 + 160] = bool(uint8(stor1[idx].field_1280))
                                    staticcall stor4.getLatestPrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1677 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_1677] == mem[_1677]
                                    if bool(mem[_1677] > 0) and mem[_1677] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                                        revert with 'NH{q', 17
                                    if bool(mem[_1677] < 0) and mem[_1677] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                                        revert with 'NH{q', 17
                                    if stor1[idx].field_512 and 1000000000000000000 * 10^18 > -1 / stor1[idx].field_512:
                                        revert with 'NH{q', 17
                                    if not 10^10 * mem[_1677]:
                                        revert with 'NH{q', 18
                                    mem[mem[64]] = 1000000000000000000 * 10^18 * stor1[idx].field_512 / 10^10 * mem[_1677]
        return memory
          from mem[64]
           len 32
    if 10^18 >= stor1.length:
        revert with 'NH{q', 50
    mem[0] = 1
    _669 = mem[64]
    mem[64] = mem[64] + 192
    if bool(stor1.field_1536 * 10^18):
        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
            revert with 'NH{q', 34
        _670 = mem[64]
        mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
        mem[_670] = uint255(stor1.field_1536000000000000000001)
        if bool(stor1.field_1536 * 10^18):
            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                revert with 'NH{q', 34
            if not uint255(stor1.field_1536000000000000000001):
                mem[_669] = _670
                mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                staticcall stor4.getLatestPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _674 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_674] == mem[_674]
                if bool(mem[_674] > 0) and mem[_674] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                    revert with 'NH{q', 17
                if bool(mem[_674] < 0) and mem[_674] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                    revert with 'NH{q', 17
                if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                    revert with 'NH{q', 17
                if not 10^10 * mem[_674]:
                    revert with 'NH{q', 18
                mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_674]
            else:
                if 31 >= uint255(stor1.field_1536000000000000000001):
                    mem[_670 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                    mem[_669] = _670
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _692 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_692] == mem[_692]
                    if bool(mem[_692] > 0) and mem[_692] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_692] < 0) and mem[_692] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_692]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_692]
                else:
                    mem[0] = sha3(1) + 6 * 10^18
                    mem[_670 + 32] = stor1[6 * 10^18].field_0
                    idx = _670 + 32
                    s = 0
                    while _670 + uint255(stor1.field_1536000000000000000001) > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_669] = _670
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1366] == mem[_1366]
                    if bool(mem[_1366] > 0) and mem[_1366] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_1366] < 0) and mem[_1366] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_1366]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_1366]
        else:
            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                revert with 'NH{q', 34
            if not stor1.field_1536000000000000000001 % 128:
                mem[_669] = _670
                mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                staticcall stor4.getLatestPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _683 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_683] == mem[_683]
                if bool(mem[_683] > 0) and mem[_683] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                    revert with 'NH{q', 17
                if bool(mem[_683] < 0) and mem[_683] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                    revert with 'NH{q', 17
                if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                    revert with 'NH{q', 17
                if not 10^10 * mem[_683]:
                    revert with 'NH{q', 18
                mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_683]
            else:
                if 31 >= stor1.field_1536000000000000000001 % 128:
                    mem[_670 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                    mem[_669] = _670
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _706 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_706] == mem[_706]
                    if bool(mem[_706] > 0) and mem[_706] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_706] < 0) and mem[_706] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_706]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_706]
                else:
                    mem[0] = sha3(1) + 6 * 10^18
                    mem[_670 + 32] = stor1[6 * 10^18].field_0
                    idx = _670 + 32
                    s = 0
                    while _670 + stor1.field_1536000000000000000001 % 128 > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_669] = _670
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1367] == mem[_1367]
                    if bool(mem[_1367] > 0) and mem[_1367] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_1367] < 0) and mem[_1367] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_1367]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_1367]
    else:
        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
            revert with 'NH{q', 34
        _671 = mem[64]
        mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
        mem[_671] = stor1.field_1536000000000000000001 % 128
        if bool(stor1.field_1536 * 10^18):
            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                revert with 'NH{q', 34
            if not uint255(stor1.field_1536000000000000000001):
                mem[_669] = _671
                mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                staticcall stor4.getLatestPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _685 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_685] == mem[_685]
                if bool(mem[_685] > 0) and mem[_685] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                    revert with 'NH{q', 17
                if bool(mem[_685] < 0) and mem[_685] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                    revert with 'NH{q', 17
                if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                    revert with 'NH{q', 17
                if not 10^10 * mem[_685]:
                    revert with 'NH{q', 18
                mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_685]
            else:
                if 31 >= uint255(stor1.field_1536000000000000000001):
                    mem[_671 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                    mem[_669] = _671
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _707 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_707] == mem[_707]
                    if bool(mem[_707] > 0) and mem[_707] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_707] < 0) and mem[_707] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_707]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_707]
                else:
                    mem[0] = sha3(1) + 6 * 10^18
                    mem[_671 + 32] = stor1[6 * 10^18].field_0
                    idx = _671 + 32
                    s = 0
                    while _671 + uint255(stor1.field_1536000000000000000001) > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_669] = _671
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1368 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1368] == mem[_1368]
                    if bool(mem[_1368] > 0) and mem[_1368] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_1368] < 0) and mem[_1368] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_1368]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_1368]
        else:
            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                revert with 'NH{q', 34
            if not stor1.field_1536000000000000000001 % 128:
                mem[_669] = _671
                mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                staticcall stor4.getLatestPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _697 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_697] == mem[_697]
                if bool(mem[_697] > 0) and mem[_697] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                    revert with 'NH{q', 17
                if bool(mem[_697] < 0) and mem[_697] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                    revert with 'NH{q', 17
                if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                    revert with 'NH{q', 17
                if not 10^10 * mem[_697]:
                    revert with 'NH{q', 18
                mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_697]
            else:
                if 31 >= stor1.field_1536000000000000000001 % 128:
                    mem[_671 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                    mem[_669] = _671
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _719 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_719] == mem[_719]
                    if bool(mem[_719] > 0) and mem[_719] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_719] < 0) and mem[_719] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_719]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_719]
                else:
                    mem[0] = sha3(1) + 6 * 10^18
                    mem[_671 + 32] = stor1[6 * 10^18].field_0
                    idx = _671 + 32
                    s = 0
                    while _671 + stor1.field_1536000000000000000001 % 128 > idx:
                        mem[idx + 32] = stor1[s + 6 * 10^18].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_669] = _671
                    mem[_669 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                    mem[_669 + 64] = uint256(stor1.field_1536000000000000000512)
                    mem[_669 + 96] = address(stor1.field_1536000000000000000768)
                    mem[_669 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_669 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                    staticcall stor4.getLatestPrice() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1369 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1369] == mem[_1369]
                    if bool(mem[_1369] > 0) and mem[_1369] > 0x36f9bfb3af7b756fad5cd10396a21346cbefc1bf33a44ab72e36108b:
                        revert with 'NH{q', 17
                    if bool(mem[_1369] < 0) and mem[_1369] < 0xffffffffc906404c50848a9052a32efc695decb934103e40cc5bb548d1c9ef75:
                        revert with 'NH{q', 17
                    if uint256(stor1.field_1536000000000000000512) and 1000000000000000000 * 10^18 > -1 / uint256(stor1.field_1536000000000000000512):
                        revert with 'NH{q', 17
                    if not 10^10 * mem[_1369]:
                        revert with 'NH{q', 18
                    mem[mem[64]] = 1000000000000000000 * 10^18 * uint256(stor1.field_1536000000000000000512) / 10^10 * mem[_1369]
    return memory
      from mem[64]
       len 32
}

function sub_76f5e08f(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    idx = 0
    while idx < stor1.length:
        _3503 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _3505 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _3503:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if owner != msg.sender:
                    revert with 0, 'FOREST: Caller is not the owner'
                idx = 0
                while idx < stor1.length:
                    _7015 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _7023 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7015:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7424 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7424 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7424 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7436 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7436 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7436 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7439 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7439 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7439 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7464 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7464 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7464 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_7023 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7023 + uint255(stor1[idx].field_1) - mem[64]]) != _7015:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11022 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11022 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11022 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11032 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11032 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11032 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7015:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7440 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7440 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7440 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7465 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7465 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7465 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7468 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7468 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7468 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7492 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7492 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7492 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_7023 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7023 + stor1[idx].field_1 % 128 - mem[64]]) != _7015:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11023 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11023 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11023 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11033 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11033 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11033 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    if not address(stor1[idx].field_768):
                        revert with 0, 'FOREST: No NFT address is set'
                    require ext_code.size(address(stor1[idx].field_768))
                    call address(stor1[idx].field_768).0x8456cb59 with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _7042 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7042 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7042 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _7046 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7046 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7046 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _7017 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _7025 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7427 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7427 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7427 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7443 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7443 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7443 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7446 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7446 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7446 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7471 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7471 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7471 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_7025 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7025 + uint255(stor1[idx].field_1) - mem[64]]) != _7017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11025 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11025 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11025 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11042 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11042 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11042 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7447 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7447 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7447 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7472 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7472 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7472 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7475 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7475 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7475 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7496 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7496 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7496 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_7025 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7025 + stor1[idx].field_1 % 128 - mem[64]]) != _7017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11026 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11026 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11026 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11043 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11043 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11043 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x8456cb59 with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _7043 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7043 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7043 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _7048 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7048 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7048 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_3505 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _3505 + uint255(stor1[idx].field_1) - mem[64]]) != _3503:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _10495 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _10519 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _10495:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11562 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11562 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11562 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11646 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11646 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11646 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11649 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11649 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11649 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11722 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11722 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11722 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_10519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10519 + uint255(stor1[idx].field_1) - mem[64]]) != _10495:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13234 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13234 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13234 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13238 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13238 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13238 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _10495:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11650 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11650 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11650 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11723 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11723 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11723 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11726 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11726 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11726 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11760 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11760 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11760 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_10519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10519 + stor1[idx].field_1 % 128 - mem[64]]) != _10495:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13235 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13235 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13235 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13239 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13239 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13239 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x8456cb59 with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _10922 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10922 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10922 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _10928 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10928 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10928 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _3503:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if owner != msg.sender:
                    revert with 0, 'FOREST: Caller is not the owner'
                idx = 0
                while idx < stor1.length:
                    _7019 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _7027 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7019:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7430 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7430 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7430 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7450 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7450 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7450 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7453 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7453 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7453 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7478 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7478 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7478 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_7027 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7027 + uint255(stor1[idx].field_1) - mem[64]]) != _7019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11027 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11027 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11027 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11044 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11044 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11044 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7019:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7454 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7454 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7454 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7479 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7479 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7479 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7482 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7482 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7482 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7499 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7499 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7499 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_7027 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7027 + stor1[idx].field_1 % 128 - mem[64]]) != _7019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11028 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11028 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11028 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11045 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11045 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11045 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    if not address(stor1[idx].field_768):
                        revert with 0, 'FOREST: No NFT address is set'
                    require ext_code.size(address(stor1[idx].field_768))
                    call address(stor1[idx].field_768).0x8456cb59 with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _7044 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7044 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7044 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _7049 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7049 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7049 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _7021 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _7029 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7021:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7433 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7433 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7433 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7457 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7457 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7457 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7460 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7460 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7460 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7485 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7485 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7485 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_7029 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7029 + uint255(stor1[idx].field_1) - mem[64]]) != _7021:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11030 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11030 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11030 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11054 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11054 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11054 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7021:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7461 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7461 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7461 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7486 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7486 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7486 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7489 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7489 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7489 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7503 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7503 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7503 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_7029 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7029 + stor1[idx].field_1 % 128 - mem[64]]) != _7021:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11031 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11031 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11031 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11055 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11055 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11055 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x8456cb59 with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _7045 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7045 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7045 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _7051 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7051 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7051 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_3505 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _3505 + stor1[idx].field_1 % 128 - mem[64]]) != _3503:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _10497 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _10561 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _10497:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11605 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11605 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11605 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11689 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11689 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11689 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11692 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11692 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11692 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11745 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11745 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11745 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_10561 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10561 + uint255(stor1[idx].field_1) - mem[64]]) != _10497:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13236 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13236 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13236 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13240 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13240 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13240 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _10497:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11693 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11693 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11693 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11746 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11746 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11746 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11749 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11749 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11749 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11763 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11763 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11763 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_10561 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10561 + stor1[idx].field_1 % 128 - mem[64]]) != _10497:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13237 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13237 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13237 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13241 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13241 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13241 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x8456cb59 with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _10923 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10923 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10923 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _10937 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10937 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10937 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        if not address(stor1.field_1536000000000000000768):
            revert with 0, 'FOREST: No NFT address is set'
        require ext_code.size(address(stor1.field_1536000000000000000768))
        call address(stor1.field_1536000000000000000768).0x8456cb59 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'FOREST: Target NFT does not exist'
}

function sub_a55ac907(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    idx = 0
    while idx < stor1.length:
        _3503 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _3505 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _3503:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if owner != msg.sender:
                    revert with 0, 'FOREST: Caller is not the owner'
                idx = 0
                while idx < stor1.length:
                    _7015 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _7023 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7015:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7424 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7424 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7424 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7436 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7436 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7436 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7439 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7439 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7439 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7464 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7464 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7464 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_7023 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7023 + uint255(stor1[idx].field_1) - mem[64]]) != _7015:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11022 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11022 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11022 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11032 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11032 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11032 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7015:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7440 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7440 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7440 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7465 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7465 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7465 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7468 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7468 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7468 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7492 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7492 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7492 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_7023 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7023 + stor1[idx].field_1 % 128 - mem[64]]) != _7015:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11023 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11023 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11023 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11033 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11033 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11033 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    if not address(stor1[idx].field_768):
                        revert with 0, 'FOREST: No NFT address is set'
                    require ext_code.size(address(stor1[idx].field_768))
                    call address(stor1[idx].field_768).0x3f4ba83a with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _7042 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7042 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7042 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _7046 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7046 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7046 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _7017 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _7025 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7427 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7427 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7427 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7443 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7443 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7443 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7446 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7446 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7446 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7471 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7471 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7471 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_7025 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7025 + uint255(stor1[idx].field_1) - mem[64]]) != _7017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11025 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11025 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11025 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11042 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11042 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11042 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7017:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7447 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7447 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7447 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7472 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7472 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7472 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7475 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7475 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7475 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7496 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7496 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7496 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_7025 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7025 + stor1[idx].field_1 % 128 - mem[64]]) != _7017:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11026 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11026 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11026 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11043 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11043 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11043 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x3f4ba83a with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _7043 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7043 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7043 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _7048 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7048 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7048 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_3505 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _3505 + uint255(stor1[idx].field_1) - mem[64]]) != _3503:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _10495 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _10519 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _10495:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11562 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11562 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11562 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11646 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11646 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11646 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11649 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11649 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11649 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11722 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11722 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11722 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_10519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10519 + uint255(stor1[idx].field_1) - mem[64]]) != _10495:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13234 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13234 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13234 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13238 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13238 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13238 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _10495:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11650 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11650 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11650 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11723 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11723 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11723 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11726 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11726 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11726 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11760 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11760 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11760 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_10519 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10519 + stor1[idx].field_1 % 128 - mem[64]]) != _10495:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13235 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13235 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13235 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13239 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13239 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13239 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x3f4ba83a with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _10922 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10922 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10922 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _10928 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10928 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10928 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _3503:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if owner != msg.sender:
                    revert with 0, 'FOREST: Caller is not the owner'
                idx = 0
                while idx < stor1.length:
                    _7019 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _7027 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7019:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7430 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7430 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7430 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7450 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7450 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7450 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7453 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7453 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7453 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7478 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7478 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7478 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_7027 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7027 + uint255(stor1[idx].field_1) - mem[64]]) != _7019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11027 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11027 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11027 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11044 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11044 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11044 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7019:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _7454 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7454 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7454 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _7479 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if uint255(stor1[idx].field_1):
                                        if 31 < uint255(stor1[idx].field_1):
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7479 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if stor1[idx].field_1 % 128:
                                        if 31 < stor1[idx].field_1 % 128:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = mem[64] + 32
                                            t = sha3(mem[0])
                                            while _7479 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7482 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7482 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7482 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7499 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7499 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7499 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_7027 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _7027 + stor1[idx].field_1 % 128 - mem[64]]) != _7019:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11028 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11028 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11028 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11045 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11045 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11045 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                    if not address(stor1[idx].field_768):
                        revert with 0, 'FOREST: No NFT address is set'
                    require ext_code.size(address(stor1[idx].field_768))
                    call address(stor1[idx].field_768).0x3f4ba83a with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _7044 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7044 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7044 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _7049 = mem[64]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if uint255(stor1.field_1536000000000000000001):
                            if 31 < uint255(stor1.field_1536000000000000000001):
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7049 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if stor1.field_1536000000000000000001 % 128:
                            if 31 < stor1.field_1536000000000000000001 % 128:
                                idx = mem[64] + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _7049 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _7021 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _7029 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _7021:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7433 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7433 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7433 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7457 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7457 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7457 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7460 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7460 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7460 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7485 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7485 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7485 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_7029 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7029 + uint255(stor1[idx].field_1) - mem[64]]) != _7021:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11030 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11030 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11030 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11054 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11054 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11054 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _7021:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _7461 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7461 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7461 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _7486 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7486 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _7486 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _7489 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7489 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7489 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _7503 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7503 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _7503 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_7029 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _7029 + stor1[idx].field_1 % 128 - mem[64]]) != _7021:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11031 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11031 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11031 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11055 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11055 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11055 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x3f4ba83a with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _7045 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7045 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7045 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _7051 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7051 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _7051 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_3505 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _3505 + stor1[idx].field_1 % 128 - mem[64]]) != _3503:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if owner != msg.sender:
                        revert with 0, 'FOREST: Caller is not the owner'
                    idx = 0
                    while idx < stor1.length:
                        _10497 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _10561 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _10497:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11605 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11605 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11605 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11689 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11689 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11689 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11692 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11692 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11692 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11745 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11745 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11745 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_10561 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10561 + uint255(stor1[idx].field_1) - mem[64]]) != _10497:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13236 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13236 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13236 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13240 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13240 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13240 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _10497:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _11693 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11693 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11693 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _11746 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if uint255(stor1[idx].field_1):
                                            if 31 < uint255(stor1[idx].field_1):
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11746 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if stor1[idx].field_1 % 128:
                                            if 31 < stor1[idx].field_1 % 128:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = mem[64] + 32
                                                t = sha3(mem[0])
                                                while _11746 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _11749 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11749 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11749 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _11763 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11763 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _11763 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_10561 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _10561 + stor1[idx].field_1 % 128 - mem[64]]) != _10497:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _13237 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13237 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13237 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _13241 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if uint255(stor1[idx].field_1):
                                                if 31 < uint255(stor1[idx].field_1):
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13241 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if stor1[idx].field_1 % 128:
                                                if 31 < stor1[idx].field_1 % 128:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = mem[64] + 32
                                                    t = sha3(mem[0])
                                                    while _13241 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                        if not address(stor1[idx].field_768):
                            revert with 0, 'FOREST: No NFT address is set'
                        require ext_code.size(address(stor1[idx].field_768))
                        call address(stor1[idx].field_768).0x3f4ba83a with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _10923 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10923 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10923 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _10937 = mem[64]
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if uint255(stor1.field_1536000000000000000001):
                                if 31 < uint255(stor1.field_1536000000000000000001):
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10937 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if stor1.field_1536000000000000000001 % 128:
                                if 31 < stor1.field_1536000000000000000001 % 128:
                                    idx = mem[64] + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _10937 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        if not address(stor1.field_1536000000000000000768):
            revert with 0, 'FOREST: No NFT address is set'
        require ext_code.size(address(stor1.field_1536000000000000000768))
        call address(stor1.field_1536000000000000000768).0x3f4ba83a with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'FOREST: Target NFT does not exist'
}

function sub_a85a75e6(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + 97 > test266151307() or floor32(('cd', 4).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + ceil32(ceil32(('cd', 36).length)) + 98 > test266151307() or ceil32(ceil32(('cd', 36).length)) + 98 < 97:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 4).length) + ceil32(ceil32(('cd', 36).length)) + 98
    mem[floor32(('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + ('cd', 36).length + 36 <= calldata.size
    mem[floor32(('cd', 4).length) + 129 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
    mem[floor32(('cd', 4).length) + ('cd', 36).length + 129] = 0
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    idx = 0
    while idx < stor1.length:
        _13033 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
        mem[0] = 1
        _13035 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _13033:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _19557 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                    mem[0] = 1
                    _19565 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _19557:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _19825 = mem[64]
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _20087 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                mem[_20087] = uint255(stor1[idx].field_1)
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19825] = _20087
                                        mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19825 + 64] = stor1[idx].field_512
                                        mem[_19825 + 96] = address(stor1[idx].field_768)
                                        mem[_19825 + 128] = stor1[idx].field_1024
                                        mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26064 = mem[96]
                                        idx = 0
                                        while idx < _26064:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26392 = mem[(32 * idx) + 128]
                                            if not mem[_19825 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26896 = mem[_19825 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26392)
                                            require ext_code.size(address(_26896))
                                            call address(_26896).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26392)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26064 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20087 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19825] = _20087
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26065 = mem[96]
                                            idx = 0
                                            while idx < _26065:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26394 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26900 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26394)
                                                require ext_code.size(address(_26900))
                                                call address(_26900).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26394)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26065 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20087 + 32] = stor1[idx].field_0
                                            s = _20087 + 32
                                            t = sha3(mem[0])
                                            while _20087 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19825] = _20087
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31856 = mem[96]
                                            idx = 0
                                            while idx < _31856:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32304 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32904 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32304)
                                                require ext_code.size(address(_32904))
                                                call address(_32904).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32304)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31856 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19825] = _20087
                                        mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19825 + 64] = stor1[idx].field_512
                                        mem[_19825 + 96] = address(stor1[idx].field_768)
                                        mem[_19825 + 128] = stor1[idx].field_1024
                                        mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26066 = mem[96]
                                        idx = 0
                                        while idx < _26066:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26395 = mem[(32 * idx) + 128]
                                            if not mem[_19825 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26903 = mem[_19825 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26395)
                                            require ext_code.size(address(_26903))
                                            call address(_26903).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26395)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26066 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20087 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19825] = _20087
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26067 = mem[96]
                                            idx = 0
                                            while idx < _26067:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26397 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26907 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26397)
                                                require ext_code.size(address(_26907))
                                                call address(_26907).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26397)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26067 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20087 + 32] = stor1[idx].field_0
                                            s = _20087 + 32
                                            t = sha3(mem[0])
                                            while _20087 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19825] = _20087
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31857 = mem[96]
                                            idx = 0
                                            while idx < _31857:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32305 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32907 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32305)
                                                require ext_code.size(address(_32907))
                                                call address(_32907).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32305)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31857 = mem[96]
                                                idx = idx + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _20135 = mem[64]
                                mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                mem[_20135] = stor1[idx].field_1 % 128
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19825] = _20135
                                        mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19825 + 64] = stor1[idx].field_512
                                        mem[_19825 + 96] = address(stor1[idx].field_768)
                                        mem[_19825 + 128] = stor1[idx].field_1024
                                        mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26068 = mem[96]
                                        idx = 0
                                        while idx < _26068:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26398 = mem[(32 * idx) + 128]
                                            if not mem[_19825 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26910 = mem[_19825 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26398)
                                            require ext_code.size(address(_26910))
                                            call address(_26910).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26398)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26068 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20135 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19825] = _20135
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26069 = mem[96]
                                            idx = 0
                                            while idx < _26069:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26400 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26914 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26400)
                                                require ext_code.size(address(_26914))
                                                call address(_26914).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26400)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26069 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20135 + 32] = stor1[idx].field_0
                                            s = _20135 + 32
                                            t = sha3(mem[0])
                                            while _20135 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19825] = _20135
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31858 = mem[96]
                                            idx = 0
                                            while idx < _31858:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32306 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32910 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32306)
                                                require ext_code.size(address(_32910))
                                                call address(_32910).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32306)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31858 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19825] = _20135
                                        mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19825 + 64] = stor1[idx].field_512
                                        mem[_19825 + 96] = address(stor1[idx].field_768)
                                        mem[_19825 + 128] = stor1[idx].field_1024
                                        mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26070 = mem[96]
                                        idx = 0
                                        while idx < _26070:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26401 = mem[(32 * idx) + 128]
                                            if not mem[_19825 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26917 = mem[_19825 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26401)
                                            require ext_code.size(address(_26917))
                                            call address(_26917).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26401)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26070 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20135 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19825] = _20135
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26071 = mem[96]
                                            idx = 0
                                            while idx < _26071:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26403 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26921 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26403)
                                                require ext_code.size(address(_26921))
                                                call address(_26921).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26403)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26071 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20135 + 32] = stor1[idx].field_0
                                            s = _20135 + 32
                                            t = sha3(mem[0])
                                            while _20135 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19825] = _20135
                                            mem[_19825 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19825 + 64] = stor1[idx].field_512
                                            mem[_19825 + 96] = address(stor1[idx].field_768)
                                            mem[_19825 + 128] = stor1[idx].field_1024
                                            mem[_19825 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31859 = mem[96]
                                            idx = 0
                                            while idx < _31859:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32307 = mem[(32 * idx) + 128]
                                                if not mem[_19825 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32913 = mem[_19825 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32307)
                                                require ext_code.size(address(_32913))
                                                call address(_32913).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32307)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31859 = mem[96]
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19894 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20138 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20138] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19894] = _20138
                                            mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19894 + 64] = stor1[idx].field_512
                                            mem[_19894 + 96] = address(stor1[idx].field_768)
                                            mem[_19894 + 128] = stor1[idx].field_1024
                                            mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26072 = mem[96]
                                            idx = 0
                                            while idx < _26072:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26404 = mem[(32 * idx) + 128]
                                                if not mem[_19894 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26926 = mem[_19894 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26404)
                                                require ext_code.size(address(_26926))
                                                call address(_26926).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26404)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26072 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20138 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19894] = _20138
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26073 = mem[96]
                                                idx = 0
                                                while idx < _26073:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26406 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26930 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26406)
                                                    require ext_code.size(address(_26930))
                                                    call address(_26930).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26406)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26073 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20138 + 32] = stor1[idx].field_0
                                                s = _20138 + 32
                                                t = sha3(mem[0])
                                                while _20138 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19894] = _20138
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31868 = mem[96]
                                                idx = 0
                                                while idx < _31868:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32320 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32944 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32320)
                                                    require ext_code.size(address(_32944))
                                                    call address(_32944).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32320)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31868 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19894] = _20138
                                            mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19894 + 64] = stor1[idx].field_512
                                            mem[_19894 + 96] = address(stor1[idx].field_768)
                                            mem[_19894 + 128] = stor1[idx].field_1024
                                            mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26074 = mem[96]
                                            idx = 0
                                            while idx < _26074:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26407 = mem[(32 * idx) + 128]
                                                if not mem[_19894 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26933 = mem[_19894 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26407)
                                                require ext_code.size(address(_26933))
                                                call address(_26933).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26407)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26074 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20138 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19894] = _20138
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26075 = mem[96]
                                                idx = 0
                                                while idx < _26075:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26409 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26937 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26409)
                                                    require ext_code.size(address(_26937))
                                                    call address(_26937).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26409)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26075 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20138 + 32] = stor1[idx].field_0
                                                s = _20138 + 32
                                                t = sha3(mem[0])
                                                while _20138 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19894] = _20138
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31869 = mem[96]
                                                idx = 0
                                                while idx < _31869:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32321 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32947 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32321)
                                                    require ext_code.size(address(_32947))
                                                    call address(_32947).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32321)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31869 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20197 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20197] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19894] = _20197
                                            mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19894 + 64] = stor1[idx].field_512
                                            mem[_19894 + 96] = address(stor1[idx].field_768)
                                            mem[_19894 + 128] = stor1[idx].field_1024
                                            mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26076 = mem[96]
                                            idx = 0
                                            while idx < _26076:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26410 = mem[(32 * idx) + 128]
                                                if not mem[_19894 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26940 = mem[_19894 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26410)
                                                require ext_code.size(address(_26940))
                                                call address(_26940).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26410)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26076 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20197 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19894] = _20197
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26077 = mem[96]
                                                idx = 0
                                                while idx < _26077:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26412 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26944 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26412)
                                                    require ext_code.size(address(_26944))
                                                    call address(_26944).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26412)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26077 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20197 + 32] = stor1[idx].field_0
                                                s = _20197 + 32
                                                t = sha3(mem[0])
                                                while _20197 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19894] = _20197
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31870 = mem[96]
                                                idx = 0
                                                while idx < _31870:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32322 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32950 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32322)
                                                    require ext_code.size(address(_32950))
                                                    call address(_32950).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32322)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31870 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19894] = _20197
                                            mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19894 + 64] = stor1[idx].field_512
                                            mem[_19894 + 96] = address(stor1[idx].field_768)
                                            mem[_19894 + 128] = stor1[idx].field_1024
                                            mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26078 = mem[96]
                                            idx = 0
                                            while idx < _26078:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26413 = mem[(32 * idx) + 128]
                                                if not mem[_19894 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26947 = mem[_19894 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26413)
                                                require ext_code.size(address(_26947))
                                                call address(_26947).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26413)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26078 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20197 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19894] = _20197
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26079 = mem[96]
                                                idx = 0
                                                while idx < _26079:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26415 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26951 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26415)
                                                    require ext_code.size(address(_26951))
                                                    call address(_26951).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26415)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26079 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20197 + 32] = stor1[idx].field_0
                                                s = _20197 + 32
                                                t = sha3(mem[0])
                                                while _20197 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19894] = _20197
                                                mem[_19894 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19894 + 64] = stor1[idx].field_512
                                                mem[_19894 + 96] = address(stor1[idx].field_768)
                                                mem[_19894 + 128] = stor1[idx].field_1024
                                                mem[_19894 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31871 = mem[96]
                                                idx = 0
                                                while idx < _31871:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32323 = mem[(32 * idx) + 128]
                                                    if not mem[_19894 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32953 = mem[_19894 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32323)
                                                    require ext_code.size(address(_32953))
                                                    call address(_32953).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32323)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31871 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_19565 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _19565 + uint255(stor1[idx].field_1) - mem[64]]) != _19557:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _27711 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _28056 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_28056] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27711] = _28056
                                            mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27711 + 64] = stor1[idx].field_512
                                            mem[_27711 + 96] = address(stor1[idx].field_768)
                                            mem[_27711 + 128] = stor1[idx].field_1024
                                            mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31860 = mem[96]
                                            idx = 0
                                            while idx < _31860:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32308 = mem[(32 * idx) + 128]
                                                if not mem[_27711 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32916 = mem[_27711 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32308)
                                                require ext_code.size(address(_32916))
                                                call address(_32916).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32308)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31860 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28056 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27711] = _28056
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31861 = mem[96]
                                                idx = 0
                                                while idx < _31861:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32310 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32920 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32310)
                                                    require ext_code.size(address(_32920))
                                                    call address(_32920).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32310)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31861 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28056 + 32] = stor1[idx].field_0
                                                s = _28056 + 32
                                                t = sha3(mem[0])
                                                while _28056 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27711] = _28056
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35348 = mem[96]
                                                idx = 0
                                                while idx < _35348:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35556 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35796 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35556)
                                                    require ext_code.size(address(_35796))
                                                    call address(_35796).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35556)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35348 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27711] = _28056
                                            mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27711 + 64] = stor1[idx].field_512
                                            mem[_27711 + 96] = address(stor1[idx].field_768)
                                            mem[_27711 + 128] = stor1[idx].field_1024
                                            mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31862 = mem[96]
                                            idx = 0
                                            while idx < _31862:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32311 = mem[(32 * idx) + 128]
                                                if not mem[_27711 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32923 = mem[_27711 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32311)
                                                require ext_code.size(address(_32923))
                                                call address(_32923).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32311)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31862 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28056 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27711] = _28056
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31863 = mem[96]
                                                idx = 0
                                                while idx < _31863:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32313 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32927 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32313)
                                                    require ext_code.size(address(_32927))
                                                    call address(_32927).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32313)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31863 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28056 + 32] = stor1[idx].field_0
                                                s = _28056 + 32
                                                t = sha3(mem[0])
                                                while _28056 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27711] = _28056
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35349 = mem[96]
                                                idx = 0
                                                while idx < _35349:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35557 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35799 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35557)
                                                    require ext_code.size(address(_35799))
                                                    call address(_35799).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35557)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35349 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _28354 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_28354] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27711] = _28354
                                            mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27711 + 64] = stor1[idx].field_512
                                            mem[_27711 + 96] = address(stor1[idx].field_768)
                                            mem[_27711 + 128] = stor1[idx].field_1024
                                            mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31864 = mem[96]
                                            idx = 0
                                            while idx < _31864:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32314 = mem[(32 * idx) + 128]
                                                if not mem[_27711 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32930 = mem[_27711 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32314)
                                                require ext_code.size(address(_32930))
                                                call address(_32930).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32314)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31864 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28354 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27711] = _28354
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31865 = mem[96]
                                                idx = 0
                                                while idx < _31865:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32316 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32934 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32316)
                                                    require ext_code.size(address(_32934))
                                                    call address(_32934).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32316)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31865 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28354 + 32] = stor1[idx].field_0
                                                s = _28354 + 32
                                                t = sha3(mem[0])
                                                while _28354 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27711] = _28354
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35350 = mem[96]
                                                idx = 0
                                                while idx < _35350:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35558 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35802 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35558)
                                                    require ext_code.size(address(_35802))
                                                    call address(_35802).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35558)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35350 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27711] = _28354
                                            mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27711 + 64] = stor1[idx].field_512
                                            mem[_27711 + 96] = address(stor1[idx].field_768)
                                            mem[_27711 + 128] = stor1[idx].field_1024
                                            mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31866 = mem[96]
                                            idx = 0
                                            while idx < _31866:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32317 = mem[(32 * idx) + 128]
                                                if not mem[_27711 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32937 = mem[_27711 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32317)
                                                require ext_code.size(address(_32937))
                                                call address(_32937).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32317)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31866 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28354 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27711] = _28354
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31867 = mem[96]
                                                idx = 0
                                                while idx < _31867:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32319 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32941 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32319)
                                                    require ext_code.size(address(_32941))
                                                    call address(_32941).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32319)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31867 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28354 + 32] = stor1[idx].field_0
                                                s = _28354 + 32
                                                t = sha3(mem[0])
                                                while _28354 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27711] = _28354
                                                mem[_27711 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27711 + 64] = stor1[idx].field_512
                                                mem[_27711 + 96] = address(stor1[idx].field_768)
                                                mem[_27711 + 128] = stor1[idx].field_1024
                                                mem[_27711 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35351 = mem[96]
                                                idx = 0
                                                while idx < _35351:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35559 = mem[(32 * idx) + 128]
                                                    if not mem[_27711 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35805 = mem[_27711 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35559)
                                                    require ext_code.size(address(_35805))
                                                    call address(_35805).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35559)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35351 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _19557:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _19896 = mem[64]
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _20139 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                mem[_20139] = uint255(stor1[idx].field_1)
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19896] = _20139
                                        mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19896 + 64] = stor1[idx].field_512
                                        mem[_19896 + 96] = address(stor1[idx].field_768)
                                        mem[_19896 + 128] = stor1[idx].field_1024
                                        mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26080 = mem[96]
                                        idx = 0
                                        while idx < _26080:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26416 = mem[(32 * idx) + 128]
                                            if not mem[_19896 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26954 = mem[_19896 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26416)
                                            require ext_code.size(address(_26954))
                                            call address(_26954).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26416)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26080 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20139 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19896] = _20139
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26081 = mem[96]
                                            idx = 0
                                            while idx < _26081:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26418 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26958 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26418)
                                                require ext_code.size(address(_26958))
                                                call address(_26958).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26418)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26081 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20139 + 32] = stor1[idx].field_0
                                            s = _20139 + 32
                                            t = sha3(mem[0])
                                            while _20139 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19896] = _20139
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31872 = mem[96]
                                            idx = 0
                                            while idx < _31872:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32324 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32956 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32324)
                                                require ext_code.size(address(_32956))
                                                call address(_32956).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32324)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31872 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19896] = _20139
                                        mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19896 + 64] = stor1[idx].field_512
                                        mem[_19896 + 96] = address(stor1[idx].field_768)
                                        mem[_19896 + 128] = stor1[idx].field_1024
                                        mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26082 = mem[96]
                                        idx = 0
                                        while idx < _26082:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26419 = mem[(32 * idx) + 128]
                                            if not mem[_19896 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26961 = mem[_19896 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26419)
                                            require ext_code.size(address(_26961))
                                            call address(_26961).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26419)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26082 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20139 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19896] = _20139
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26083 = mem[96]
                                            idx = 0
                                            while idx < _26083:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26421 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26965 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26421)
                                                require ext_code.size(address(_26965))
                                                call address(_26965).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26421)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26083 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20139 + 32] = stor1[idx].field_0
                                            s = _20139 + 32
                                            t = sha3(mem[0])
                                            while _20139 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19896] = _20139
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31873 = mem[96]
                                            idx = 0
                                            while idx < _31873:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32325 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32959 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32325)
                                                require ext_code.size(address(_32959))
                                                call address(_32959).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32325)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31873 = mem[96]
                                                idx = idx + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _20198 = mem[64]
                                mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                mem[_20198] = stor1[idx].field_1 % 128
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19896] = _20198
                                        mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19896 + 64] = stor1[idx].field_512
                                        mem[_19896 + 96] = address(stor1[idx].field_768)
                                        mem[_19896 + 128] = stor1[idx].field_1024
                                        mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26084 = mem[96]
                                        idx = 0
                                        while idx < _26084:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26422 = mem[(32 * idx) + 128]
                                            if not mem[_19896 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26968 = mem[_19896 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26422)
                                            require ext_code.size(address(_26968))
                                            call address(_26968).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26422)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26084 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20198 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19896] = _20198
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26085 = mem[96]
                                            idx = 0
                                            while idx < _26085:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26424 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26972 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26424)
                                                require ext_code.size(address(_26972))
                                                call address(_26972).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26424)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26085 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20198 + 32] = stor1[idx].field_0
                                            s = _20198 + 32
                                            t = sha3(mem[0])
                                            while _20198 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19896] = _20198
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31874 = mem[96]
                                            idx = 0
                                            while idx < _31874:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32326 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32962 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32326)
                                                require ext_code.size(address(_32962))
                                                call address(_32962).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32326)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31874 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19896] = _20198
                                        mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19896 + 64] = stor1[idx].field_512
                                        mem[_19896 + 96] = address(stor1[idx].field_768)
                                        mem[_19896 + 128] = stor1[idx].field_1024
                                        mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26086 = mem[96]
                                        idx = 0
                                        while idx < _26086:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26425 = mem[(32 * idx) + 128]
                                            if not mem[_19896 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26975 = mem[_19896 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26425)
                                            require ext_code.size(address(_26975))
                                            call address(_26975).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26425)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26086 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20198 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19896] = _20198
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26087 = mem[96]
                                            idx = 0
                                            while idx < _26087:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26427 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26979 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26427)
                                                require ext_code.size(address(_26979))
                                                call address(_26979).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26427)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26087 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20198 + 32] = stor1[idx].field_0
                                            s = _20198 + 32
                                            t = sha3(mem[0])
                                            while _20198 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19896] = _20198
                                            mem[_19896 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19896 + 64] = stor1[idx].field_512
                                            mem[_19896 + 96] = address(stor1[idx].field_768)
                                            mem[_19896 + 128] = stor1[idx].field_1024
                                            mem[_19896 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31875 = mem[96]
                                            idx = 0
                                            while idx < _31875:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32327 = mem[(32 * idx) + 128]
                                                if not mem[_19896 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32965 = mem[_19896 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32327)
                                                require ext_code.size(address(_32965))
                                                call address(_32965).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32327)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31875 = mem[96]
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19976 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20201 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20201] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19976] = _20201
                                            mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19976 + 64] = stor1[idx].field_512
                                            mem[_19976 + 96] = address(stor1[idx].field_768)
                                            mem[_19976 + 128] = stor1[idx].field_1024
                                            mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26088 = mem[96]
                                            idx = 0
                                            while idx < _26088:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26428 = mem[(32 * idx) + 128]
                                                if not mem[_19976 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26984 = mem[_19976 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26428)
                                                require ext_code.size(address(_26984))
                                                call address(_26984).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26428)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26088 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20201 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19976] = _20201
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26089 = mem[96]
                                                idx = 0
                                                while idx < _26089:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26430 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26988 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26430)
                                                    require ext_code.size(address(_26988))
                                                    call address(_26988).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26430)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26089 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20201 + 32] = stor1[idx].field_0
                                                s = _20201 + 32
                                                t = sha3(mem[0])
                                                while _20201 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19976] = _20201
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31884 = mem[96]
                                                idx = 0
                                                while idx < _31884:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32340 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32996 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32340)
                                                    require ext_code.size(address(_32996))
                                                    call address(_32996).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32340)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31884 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19976] = _20201
                                            mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19976 + 64] = stor1[idx].field_512
                                            mem[_19976 + 96] = address(stor1[idx].field_768)
                                            mem[_19976 + 128] = stor1[idx].field_1024
                                            mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26090 = mem[96]
                                            idx = 0
                                            while idx < _26090:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26431 = mem[(32 * idx) + 128]
                                                if not mem[_19976 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26991 = mem[_19976 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26431)
                                                require ext_code.size(address(_26991))
                                                call address(_26991).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26431)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26090 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20201 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19976] = _20201
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26091 = mem[96]
                                                idx = 0
                                                while idx < _26091:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26433 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26995 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26433)
                                                    require ext_code.size(address(_26995))
                                                    call address(_26995).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26433)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26091 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20201 + 32] = stor1[idx].field_0
                                                s = _20201 + 32
                                                t = sha3(mem[0])
                                                while _20201 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19976] = _20201
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31885 = mem[96]
                                                idx = 0
                                                while idx < _31885:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32341 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32999 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32341)
                                                    require ext_code.size(address(_32999))
                                                    call address(_32999).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32341)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31885 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20254 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20254] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19976] = _20254
                                            mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19976 + 64] = stor1[idx].field_512
                                            mem[_19976 + 96] = address(stor1[idx].field_768)
                                            mem[_19976 + 128] = stor1[idx].field_1024
                                            mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26092 = mem[96]
                                            idx = 0
                                            while idx < _26092:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26434 = mem[(32 * idx) + 128]
                                                if not mem[_19976 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26998 = mem[_19976 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26434)
                                                require ext_code.size(address(_26998))
                                                call address(_26998).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26434)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26092 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20254 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19976] = _20254
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26093 = mem[96]
                                                idx = 0
                                                while idx < _26093:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26436 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27002 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26436)
                                                    require ext_code.size(address(_27002))
                                                    call address(_27002).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26436)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26093 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20254 + 32] = stor1[idx].field_0
                                                s = _20254 + 32
                                                t = sha3(mem[0])
                                                while _20254 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19976] = _20254
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31886 = mem[96]
                                                idx = 0
                                                while idx < _31886:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32342 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33002 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32342)
                                                    require ext_code.size(address(_33002))
                                                    call address(_33002).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32342)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31886 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19976] = _20254
                                            mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19976 + 64] = stor1[idx].field_512
                                            mem[_19976 + 96] = address(stor1[idx].field_768)
                                            mem[_19976 + 128] = stor1[idx].field_1024
                                            mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26094 = mem[96]
                                            idx = 0
                                            while idx < _26094:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26437 = mem[(32 * idx) + 128]
                                                if not mem[_19976 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27005 = mem[_19976 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26437)
                                                require ext_code.size(address(_27005))
                                                call address(_27005).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26437)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26094 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20254 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19976] = _20254
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26095 = mem[96]
                                                idx = 0
                                                while idx < _26095:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26439 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27009 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26439)
                                                    require ext_code.size(address(_27009))
                                                    call address(_27009).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26439)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26095 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20254 + 32] = stor1[idx].field_0
                                                s = _20254 + 32
                                                t = sha3(mem[0])
                                                while _20254 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19976] = _20254
                                                mem[_19976 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19976 + 64] = stor1[idx].field_512
                                                mem[_19976 + 96] = address(stor1[idx].field_768)
                                                mem[_19976 + 128] = stor1[idx].field_1024
                                                mem[_19976 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31887 = mem[96]
                                                idx = 0
                                                while idx < _31887:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32343 = mem[(32 * idx) + 128]
                                                    if not mem[_19976 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33005 = mem[_19976 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32343)
                                                    require ext_code.size(address(_33005))
                                                    call address(_33005).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32343)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31887 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_19565 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _19565 + stor1[idx].field_1 % 128 - mem[64]]) != _19557:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _27737 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _28089 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_28089] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27737] = _28089
                                            mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27737 + 64] = stor1[idx].field_512
                                            mem[_27737 + 96] = address(stor1[idx].field_768)
                                            mem[_27737 + 128] = stor1[idx].field_1024
                                            mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31876 = mem[96]
                                            idx = 0
                                            while idx < _31876:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32328 = mem[(32 * idx) + 128]
                                                if not mem[_27737 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32968 = mem[_27737 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32328)
                                                require ext_code.size(address(_32968))
                                                call address(_32968).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32328)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31876 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28089 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27737] = _28089
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31877 = mem[96]
                                                idx = 0
                                                while idx < _31877:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32330 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32972 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32330)
                                                    require ext_code.size(address(_32972))
                                                    call address(_32972).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32330)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31877 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28089 + 32] = stor1[idx].field_0
                                                s = _28089 + 32
                                                t = sha3(mem[0])
                                                while _28089 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27737] = _28089
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35352 = mem[96]
                                                idx = 0
                                                while idx < _35352:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35560 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35808 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35560)
                                                    require ext_code.size(address(_35808))
                                                    call address(_35808).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35560)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35352 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27737] = _28089
                                            mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27737 + 64] = stor1[idx].field_512
                                            mem[_27737 + 96] = address(stor1[idx].field_768)
                                            mem[_27737 + 128] = stor1[idx].field_1024
                                            mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31878 = mem[96]
                                            idx = 0
                                            while idx < _31878:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32331 = mem[(32 * idx) + 128]
                                                if not mem[_27737 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32975 = mem[_27737 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32331)
                                                require ext_code.size(address(_32975))
                                                call address(_32975).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32331)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31878 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28089 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27737] = _28089
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31879 = mem[96]
                                                idx = 0
                                                while idx < _31879:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32333 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32979 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32333)
                                                    require ext_code.size(address(_32979))
                                                    call address(_32979).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32333)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31879 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28089 + 32] = stor1[idx].field_0
                                                s = _28089 + 32
                                                t = sha3(mem[0])
                                                while _28089 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27737] = _28089
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35353 = mem[96]
                                                idx = 0
                                                while idx < _35353:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35561 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35811 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35561)
                                                    require ext_code.size(address(_35811))
                                                    call address(_35811).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35561)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35353 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _28355 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_28355] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27737] = _28355
                                            mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27737 + 64] = stor1[idx].field_512
                                            mem[_27737 + 96] = address(stor1[idx].field_768)
                                            mem[_27737 + 128] = stor1[idx].field_1024
                                            mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31880 = mem[96]
                                            idx = 0
                                            while idx < _31880:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32334 = mem[(32 * idx) + 128]
                                                if not mem[_27737 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32982 = mem[_27737 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32334)
                                                require ext_code.size(address(_32982))
                                                call address(_32982).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32334)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31880 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28355 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27737] = _28355
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31881 = mem[96]
                                                idx = 0
                                                while idx < _31881:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32336 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32986 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32336)
                                                    require ext_code.size(address(_32986))
                                                    call address(_32986).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32336)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31881 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28355 + 32] = stor1[idx].field_0
                                                s = _28355 + 32
                                                t = sha3(mem[0])
                                                while _28355 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27737] = _28355
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35354 = mem[96]
                                                idx = 0
                                                while idx < _35354:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35562 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35814 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35562)
                                                    require ext_code.size(address(_35814))
                                                    call address(_35814).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35562)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35354 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27737] = _28355
                                            mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27737 + 64] = stor1[idx].field_512
                                            mem[_27737 + 96] = address(stor1[idx].field_768)
                                            mem[_27737 + 128] = stor1[idx].field_1024
                                            mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31882 = mem[96]
                                            idx = 0
                                            while idx < _31882:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32337 = mem[(32 * idx) + 128]
                                                if not mem[_27737 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32989 = mem[_27737 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32337)
                                                require ext_code.size(address(_32989))
                                                call address(_32989).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32337)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31882 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28355 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27737] = _28355
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31883 = mem[96]
                                                idx = 0
                                                while idx < _31883:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32339 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32993 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32339)
                                                    require ext_code.size(address(_32993))
                                                    call address(_32993).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32339)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31883 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28355 + 32] = stor1[idx].field_0
                                                s = _28355 + 32
                                                t = sha3(mem[0])
                                                while _28355 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27737] = _28355
                                                mem[_27737 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27737 + 64] = stor1[idx].field_512
                                                mem[_27737 + 96] = address(stor1[idx].field_768)
                                                mem[_27737 + 128] = stor1[idx].field_1024
                                                mem[_27737 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35355 = mem[96]
                                                idx = 0
                                                while idx < _35355:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35563 = mem[(32 * idx) + 128]
                                                    if not mem[_27737 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35817 = mem[_27737 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35563)
                                                    require ext_code.size(address(_35817))
                                                    call address(_35817).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35563)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35355 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _19573 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _19584 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                    mem[_19584] = uint255(stor1.field_1536000000000000000001)
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1.field_1536000000000000000001):
                            mem[_19573] = _19584
                            mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26056 = mem[96]
                            idx = 0
                            while idx < _26056:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26380 = mem[(32 * idx) + 128]
                                if not mem[_19573 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26868 = mem[_19573 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26380)
                                require ext_code.size(address(_26868))
                                call address(_26868).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26380)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26056 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(stor1.field_1536000000000000000001):
                                mem[_19584 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19573] = _19584
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26057 = mem[96]
                                idx = 0
                                while idx < _26057:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26382 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26872 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26382)
                                    require ext_code.size(address(_26872))
                                    call address(_26872).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26382)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26057 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19584 + 32] = stor1[6 * 10^18].field_0
                                idx = _19584 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19584 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19573] = _19584
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31852 = mem[96]
                                idx = 0
                                while idx < _31852:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32300 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32892 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32300)
                                    require ext_code.size(address(_32892))
                                    call address(_32892).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32300)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31852 = mem[96]
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1.field_1536000000000000000001 % 128:
                            mem[_19573] = _19584
                            mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26058 = mem[96]
                            idx = 0
                            while idx < _26058:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26383 = mem[(32 * idx) + 128]
                                if not mem[_19573 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26875 = mem[_19573 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26383)
                                require ext_code.size(address(_26875))
                                call address(_26875).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26383)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26058 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= stor1.field_1536000000000000000001 % 128:
                                mem[_19584 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19573] = _19584
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26059 = mem[96]
                                idx = 0
                                while idx < _26059:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26385 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26879 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26385)
                                    require ext_code.size(address(_26879))
                                    call address(_26879).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26385)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26059 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19584 + 32] = stor1[6 * 10^18].field_0
                                idx = _19584 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19584 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19573] = _19584
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31853 = mem[96]
                                idx = 0
                                while idx < _31853:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32301 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32895 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32301)
                                    require ext_code.size(address(_32895))
                                    call address(_32895).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32301)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31853 = mem[96]
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _19588 = mem[64]
                    mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                    mem[_19588] = stor1.field_1536000000000000000001 % 128
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1.field_1536000000000000000001):
                            mem[_19573] = _19588
                            mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26060 = mem[96]
                            idx = 0
                            while idx < _26060:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26386 = mem[(32 * idx) + 128]
                                if not mem[_19573 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26882 = mem[_19573 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26386)
                                require ext_code.size(address(_26882))
                                call address(_26882).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26386)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26060 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(stor1.field_1536000000000000000001):
                                mem[_19588 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19573] = _19588
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26061 = mem[96]
                                idx = 0
                                while idx < _26061:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26388 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26886 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26388)
                                    require ext_code.size(address(_26886))
                                    call address(_26886).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26388)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26061 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19588 + 32] = stor1[6 * 10^18].field_0
                                idx = _19588 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19588 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19573] = _19588
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31854 = mem[96]
                                idx = 0
                                while idx < _31854:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32302 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32898 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32302)
                                    require ext_code.size(address(_32898))
                                    call address(_32898).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32302)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31854 = mem[96]
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1.field_1536000000000000000001 % 128:
                            mem[_19573] = _19588
                            mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26062 = mem[96]
                            idx = 0
                            while idx < _26062:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26389 = mem[(32 * idx) + 128]
                                if not mem[_19573 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26889 = mem[_19573 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26389)
                                require ext_code.size(address(_26889))
                                call address(_26889).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26389)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26062 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= stor1.field_1536000000000000000001 % 128:
                                mem[_19588 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19573] = _19588
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26063 = mem[96]
                                idx = 0
                                while idx < _26063:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26391 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26893 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26391)
                                    require ext_code.size(address(_26893))
                                    call address(_26893).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26391)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26063 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19588 + 32] = stor1[6 * 10^18].field_0
                                idx = _19588 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19588 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19573] = _19588
                                mem[_19573 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19573 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19573 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19573 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19573 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31855 = mem[96]
                                idx = 0
                                while idx < _31855:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32303 = mem[(32 * idx) + 128]
                                    if not mem[_19573 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32901 = mem[_19573 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32303)
                                    require ext_code.size(address(_32901))
                                    call address(_32901).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32303)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31855 = mem[96]
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _19559 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                        mem[0] = 1
                        _19567 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _19559:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19842 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20100 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20100] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19842] = _20100
                                            mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19842 + 64] = stor1[idx].field_512
                                            mem[_19842 + 96] = address(stor1[idx].field_768)
                                            mem[_19842 + 128] = stor1[idx].field_1024
                                            mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26104 = mem[96]
                                            idx = 0
                                            while idx < _26104:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26454 = mem[(32 * idx) + 128]
                                                if not mem[_19842 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27040 = mem[_19842 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26454)
                                                require ext_code.size(address(_27040))
                                                call address(_27040).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26454)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26104 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20100 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19842] = _20100
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26105 = mem[96]
                                                idx = 0
                                                while idx < _26105:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26456 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27044 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26456)
                                                    require ext_code.size(address(_27044))
                                                    call address(_27044).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26456)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26105 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20100 + 32] = stor1[idx].field_0
                                                s = _20100 + 32
                                                t = sha3(mem[0])
                                                while _20100 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19842] = _20100
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31932 = mem[96]
                                                idx = 0
                                                while idx < _31932:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32408 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33164 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32408)
                                                    require ext_code.size(address(_33164))
                                                    call address(_33164).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32408)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31932 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19842] = _20100
                                            mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19842 + 64] = stor1[idx].field_512
                                            mem[_19842 + 96] = address(stor1[idx].field_768)
                                            mem[_19842 + 128] = stor1[idx].field_1024
                                            mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26106 = mem[96]
                                            idx = 0
                                            while idx < _26106:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26457 = mem[(32 * idx) + 128]
                                                if not mem[_19842 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27047 = mem[_19842 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26457)
                                                require ext_code.size(address(_27047))
                                                call address(_27047).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26457)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26106 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20100 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19842] = _20100
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26107 = mem[96]
                                                idx = 0
                                                while idx < _26107:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26459 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27051 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26459)
                                                    require ext_code.size(address(_27051))
                                                    call address(_27051).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26459)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26107 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20100 + 32] = stor1[idx].field_0
                                                s = _20100 + 32
                                                t = sha3(mem[0])
                                                while _20100 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19842] = _20100
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31933 = mem[96]
                                                idx = 0
                                                while idx < _31933:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32409 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33167 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32409)
                                                    require ext_code.size(address(_33167))
                                                    call address(_33167).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32409)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31933 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20154 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20154] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19842] = _20154
                                            mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19842 + 64] = stor1[idx].field_512
                                            mem[_19842 + 96] = address(stor1[idx].field_768)
                                            mem[_19842 + 128] = stor1[idx].field_1024
                                            mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26108 = mem[96]
                                            idx = 0
                                            while idx < _26108:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26460 = mem[(32 * idx) + 128]
                                                if not mem[_19842 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27054 = mem[_19842 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26460)
                                                require ext_code.size(address(_27054))
                                                call address(_27054).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26460)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26108 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20154 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19842] = _20154
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26109 = mem[96]
                                                idx = 0
                                                while idx < _26109:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26462 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27058 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26462)
                                                    require ext_code.size(address(_27058))
                                                    call address(_27058).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26462)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26109 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20154 + 32] = stor1[idx].field_0
                                                s = _20154 + 32
                                                t = sha3(mem[0])
                                                while _20154 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19842] = _20154
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31934 = mem[96]
                                                idx = 0
                                                while idx < _31934:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32410 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33170 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32410)
                                                    require ext_code.size(address(_33170))
                                                    call address(_33170).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32410)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31934 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19842] = _20154
                                            mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19842 + 64] = stor1[idx].field_512
                                            mem[_19842 + 96] = address(stor1[idx].field_768)
                                            mem[_19842 + 128] = stor1[idx].field_1024
                                            mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26110 = mem[96]
                                            idx = 0
                                            while idx < _26110:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26463 = mem[(32 * idx) + 128]
                                                if not mem[_19842 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27061 = mem[_19842 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26463)
                                                require ext_code.size(address(_27061))
                                                call address(_27061).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26463)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26110 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20154 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19842] = _20154
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26111 = mem[96]
                                                idx = 0
                                                while idx < _26111:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26465 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27065 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26465)
                                                    require ext_code.size(address(_27065))
                                                    call address(_27065).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26465)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26111 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20154 + 32] = stor1[idx].field_0
                                                s = _20154 + 32
                                                t = sha3(mem[0])
                                                while _20154 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19842] = _20154
                                                mem[_19842 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19842 + 64] = stor1[idx].field_512
                                                mem[_19842 + 96] = address(stor1[idx].field_768)
                                                mem[_19842 + 128] = stor1[idx].field_1024
                                                mem[_19842 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31935 = mem[96]
                                                idx = 0
                                                while idx < _31935:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32411 = mem[(32 * idx) + 128]
                                                    if not mem[_19842 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33173 = mem[_19842 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32411)
                                                    require ext_code.size(address(_33173))
                                                    call address(_33173).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32411)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31935 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _19915 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _20157 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_20157] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19915] = _20157
                                                mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19915 + 64] = stor1[idx].field_512
                                                mem[_19915 + 96] = address(stor1[idx].field_768)
                                                mem[_19915 + 128] = stor1[idx].field_1024
                                                mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26112 = mem[96]
                                                idx = 0
                                                while idx < _26112:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26466 = mem[(32 * idx) + 128]
                                                    if not mem[_19915 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27070 = mem[_19915 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26466)
                                                    require ext_code.size(address(_27070))
                                                    call address(_27070).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26466)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26112 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20157 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19915] = _20157
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26113 = mem[96]
                                                    idx = 0
                                                    while idx < _26113:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26468 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27074 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26468)
                                                        require ext_code.size(address(_27074))
                                                        call address(_27074).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26468)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26113 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20157 + 32] = stor1[idx].field_0
                                                    s = _20157 + 32
                                                    t = sha3(mem[0])
                                                    while _20157 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19915] = _20157
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31944 = mem[96]
                                                    idx = 0
                                                    while idx < _31944:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32424 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33204 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32424)
                                                        require ext_code.size(address(_33204))
                                                        call address(_33204).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32424)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31944 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19915] = _20157
                                                mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19915 + 64] = stor1[idx].field_512
                                                mem[_19915 + 96] = address(stor1[idx].field_768)
                                                mem[_19915 + 128] = stor1[idx].field_1024
                                                mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26114 = mem[96]
                                                idx = 0
                                                while idx < _26114:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26469 = mem[(32 * idx) + 128]
                                                    if not mem[_19915 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27077 = mem[_19915 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26469)
                                                    require ext_code.size(address(_27077))
                                                    call address(_27077).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26469)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26114 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20157 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19915] = _20157
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26115 = mem[96]
                                                    idx = 0
                                                    while idx < _26115:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26471 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27081 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26471)
                                                        require ext_code.size(address(_27081))
                                                        call address(_27081).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26471)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26115 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20157 + 32] = stor1[idx].field_0
                                                    s = _20157 + 32
                                                    t = sha3(mem[0])
                                                    while _20157 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19915] = _20157
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31945 = mem[96]
                                                    idx = 0
                                                    while idx < _31945:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32425 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33207 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32425)
                                                        require ext_code.size(address(_33207))
                                                        call address(_33207).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32425)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31945 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _20217 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_20217] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19915] = _20217
                                                mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19915 + 64] = stor1[idx].field_512
                                                mem[_19915 + 96] = address(stor1[idx].field_768)
                                                mem[_19915 + 128] = stor1[idx].field_1024
                                                mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26116 = mem[96]
                                                idx = 0
                                                while idx < _26116:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26472 = mem[(32 * idx) + 128]
                                                    if not mem[_19915 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27084 = mem[_19915 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26472)
                                                    require ext_code.size(address(_27084))
                                                    call address(_27084).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26472)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26116 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20217 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19915] = _20217
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26117 = mem[96]
                                                    idx = 0
                                                    while idx < _26117:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26474 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27088 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26474)
                                                        require ext_code.size(address(_27088))
                                                        call address(_27088).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26474)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26117 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20217 + 32] = stor1[idx].field_0
                                                    s = _20217 + 32
                                                    t = sha3(mem[0])
                                                    while _20217 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19915] = _20217
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31946 = mem[96]
                                                    idx = 0
                                                    while idx < _31946:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32426 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33210 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32426)
                                                        require ext_code.size(address(_33210))
                                                        call address(_33210).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32426)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31946 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19915] = _20217
                                                mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19915 + 64] = stor1[idx].field_512
                                                mem[_19915 + 96] = address(stor1[idx].field_768)
                                                mem[_19915 + 128] = stor1[idx].field_1024
                                                mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26118 = mem[96]
                                                idx = 0
                                                while idx < _26118:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26475 = mem[(32 * idx) + 128]
                                                    if not mem[_19915 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27091 = mem[_19915 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26475)
                                                    require ext_code.size(address(_27091))
                                                    call address(_27091).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26475)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26118 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20217 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19915] = _20217
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26119 = mem[96]
                                                    idx = 0
                                                    while idx < _26119:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26477 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27095 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26477)
                                                        require ext_code.size(address(_27095))
                                                        call address(_27095).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26477)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26119 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20217 + 32] = stor1[idx].field_0
                                                    s = _20217 + 32
                                                    t = sha3(mem[0])
                                                    while _20217 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19915] = _20217
                                                    mem[_19915 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19915 + 64] = stor1[idx].field_512
                                                    mem[_19915 + 96] = address(stor1[idx].field_768)
                                                    mem[_19915 + 128] = stor1[idx].field_1024
                                                    mem[_19915 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31947 = mem[96]
                                                    idx = 0
                                                    while idx < _31947:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32427 = mem[(32 * idx) + 128]
                                                        if not mem[_19915 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33213 = mem[_19915 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32427)
                                                        require ext_code.size(address(_33213))
                                                        call address(_33213).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32427)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31947 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_19567 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _19567 + uint255(stor1[idx].field_1) - mem[64]]) != _19559:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _27776 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _28139 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_28139] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27776] = _28139
                                                mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27776 + 64] = stor1[idx].field_512
                                                mem[_27776 + 96] = address(stor1[idx].field_768)
                                                mem[_27776 + 128] = stor1[idx].field_1024
                                                mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31936 = mem[96]
                                                idx = 0
                                                while idx < _31936:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32412 = mem[(32 * idx) + 128]
                                                    if not mem[_27776 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33176 = mem[_27776 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32412)
                                                    require ext_code.size(address(_33176))
                                                    call address(_33176).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32412)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31936 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28139 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27776] = _28139
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31937 = mem[96]
                                                    idx = 0
                                                    while idx < _31937:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32414 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33180 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32414)
                                                        require ext_code.size(address(_33180))
                                                        call address(_33180).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32414)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31937 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28139 + 32] = stor1[idx].field_0
                                                    s = _28139 + 32
                                                    t = sha3(mem[0])
                                                    while _28139 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27776] = _28139
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35392 = mem[96]
                                                    idx = 0
                                                    while idx < _35392:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35608 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35936 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35608)
                                                        require ext_code.size(address(_35936))
                                                        call address(_35936).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35608)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35392 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27776] = _28139
                                                mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27776 + 64] = stor1[idx].field_512
                                                mem[_27776 + 96] = address(stor1[idx].field_768)
                                                mem[_27776 + 128] = stor1[idx].field_1024
                                                mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31938 = mem[96]
                                                idx = 0
                                                while idx < _31938:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32415 = mem[(32 * idx) + 128]
                                                    if not mem[_27776 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33183 = mem[_27776 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32415)
                                                    require ext_code.size(address(_33183))
                                                    call address(_33183).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32415)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31938 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28139 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27776] = _28139
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31939 = mem[96]
                                                    idx = 0
                                                    while idx < _31939:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32417 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33187 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32417)
                                                        require ext_code.size(address(_33187))
                                                        call address(_33187).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32417)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31939 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28139 + 32] = stor1[idx].field_0
                                                    s = _28139 + 32
                                                    t = sha3(mem[0])
                                                    while _28139 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27776] = _28139
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35393 = mem[96]
                                                    idx = 0
                                                    while idx < _35393:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35609 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35939 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35609)
                                                        require ext_code.size(address(_35939))
                                                        call address(_35939).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35609)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35393 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _28361 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_28361] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27776] = _28361
                                                mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27776 + 64] = stor1[idx].field_512
                                                mem[_27776 + 96] = address(stor1[idx].field_768)
                                                mem[_27776 + 128] = stor1[idx].field_1024
                                                mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31940 = mem[96]
                                                idx = 0
                                                while idx < _31940:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32418 = mem[(32 * idx) + 128]
                                                    if not mem[_27776 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33190 = mem[_27776 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32418)
                                                    require ext_code.size(address(_33190))
                                                    call address(_33190).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32418)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31940 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28361 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27776] = _28361
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31941 = mem[96]
                                                    idx = 0
                                                    while idx < _31941:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32420 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33194 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32420)
                                                        require ext_code.size(address(_33194))
                                                        call address(_33194).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32420)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31941 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28361 + 32] = stor1[idx].field_0
                                                    s = _28361 + 32
                                                    t = sha3(mem[0])
                                                    while _28361 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27776] = _28361
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35394 = mem[96]
                                                    idx = 0
                                                    while idx < _35394:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35610 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35942 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35610)
                                                        require ext_code.size(address(_35942))
                                                        call address(_35942).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35610)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35394 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27776] = _28361
                                                mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27776 + 64] = stor1[idx].field_512
                                                mem[_27776 + 96] = address(stor1[idx].field_768)
                                                mem[_27776 + 128] = stor1[idx].field_1024
                                                mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31942 = mem[96]
                                                idx = 0
                                                while idx < _31942:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32421 = mem[(32 * idx) + 128]
                                                    if not mem[_27776 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33197 = mem[_27776 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32421)
                                                    require ext_code.size(address(_33197))
                                                    call address(_33197).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32421)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31942 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28361 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27776] = _28361
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31943 = mem[96]
                                                    idx = 0
                                                    while idx < _31943:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32423 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33201 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32423)
                                                        require ext_code.size(address(_33201))
                                                        call address(_33201).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32423)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31943 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28361 + 32] = stor1[idx].field_0
                                                    s = _28361 + 32
                                                    t = sha3(mem[0])
                                                    while _28361 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27776] = _28361
                                                    mem[_27776 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27776 + 64] = stor1[idx].field_512
                                                    mem[_27776 + 96] = address(stor1[idx].field_768)
                                                    mem[_27776 + 128] = stor1[idx].field_1024
                                                    mem[_27776 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35395 = mem[96]
                                                    idx = 0
                                                    while idx < _35395:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35611 = mem[(32 * idx) + 128]
                                                        if not mem[_27776 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35945 = mem[_27776 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35611)
                                                        require ext_code.size(address(_35945))
                                                        call address(_35945).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35611)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35395 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _19559:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19917 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20158 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20158] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19917] = _20158
                                            mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19917 + 64] = stor1[idx].field_512
                                            mem[_19917 + 96] = address(stor1[idx].field_768)
                                            mem[_19917 + 128] = stor1[idx].field_1024
                                            mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26120 = mem[96]
                                            idx = 0
                                            while idx < _26120:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26478 = mem[(32 * idx) + 128]
                                                if not mem[_19917 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27098 = mem[_19917 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26478)
                                                require ext_code.size(address(_27098))
                                                call address(_27098).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26478)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26120 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20158 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19917] = _20158
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26121 = mem[96]
                                                idx = 0
                                                while idx < _26121:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26480 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27102 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26480)
                                                    require ext_code.size(address(_27102))
                                                    call address(_27102).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26480)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26121 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20158 + 32] = stor1[idx].field_0
                                                s = _20158 + 32
                                                t = sha3(mem[0])
                                                while _20158 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19917] = _20158
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31948 = mem[96]
                                                idx = 0
                                                while idx < _31948:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32428 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33216 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32428)
                                                    require ext_code.size(address(_33216))
                                                    call address(_33216).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32428)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31948 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19917] = _20158
                                            mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19917 + 64] = stor1[idx].field_512
                                            mem[_19917 + 96] = address(stor1[idx].field_768)
                                            mem[_19917 + 128] = stor1[idx].field_1024
                                            mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26122 = mem[96]
                                            idx = 0
                                            while idx < _26122:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26481 = mem[(32 * idx) + 128]
                                                if not mem[_19917 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27105 = mem[_19917 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26481)
                                                require ext_code.size(address(_27105))
                                                call address(_27105).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26481)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26122 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20158 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19917] = _20158
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26123 = mem[96]
                                                idx = 0
                                                while idx < _26123:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26483 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27109 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26483)
                                                    require ext_code.size(address(_27109))
                                                    call address(_27109).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26483)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26123 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20158 + 32] = stor1[idx].field_0
                                                s = _20158 + 32
                                                t = sha3(mem[0])
                                                while _20158 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19917] = _20158
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31949 = mem[96]
                                                idx = 0
                                                while idx < _31949:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32429 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33219 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32429)
                                                    require ext_code.size(address(_33219))
                                                    call address(_33219).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32429)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31949 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20218 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20218] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19917] = _20218
                                            mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19917 + 64] = stor1[idx].field_512
                                            mem[_19917 + 96] = address(stor1[idx].field_768)
                                            mem[_19917 + 128] = stor1[idx].field_1024
                                            mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26124 = mem[96]
                                            idx = 0
                                            while idx < _26124:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26484 = mem[(32 * idx) + 128]
                                                if not mem[_19917 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27112 = mem[_19917 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26484)
                                                require ext_code.size(address(_27112))
                                                call address(_27112).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26484)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26124 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20218 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19917] = _20218
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26125 = mem[96]
                                                idx = 0
                                                while idx < _26125:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26486 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27116 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26486)
                                                    require ext_code.size(address(_27116))
                                                    call address(_27116).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26486)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26125 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20218 + 32] = stor1[idx].field_0
                                                s = _20218 + 32
                                                t = sha3(mem[0])
                                                while _20218 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19917] = _20218
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31950 = mem[96]
                                                idx = 0
                                                while idx < _31950:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32430 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33222 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32430)
                                                    require ext_code.size(address(_33222))
                                                    call address(_33222).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32430)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31950 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19917] = _20218
                                            mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19917 + 64] = stor1[idx].field_512
                                            mem[_19917 + 96] = address(stor1[idx].field_768)
                                            mem[_19917 + 128] = stor1[idx].field_1024
                                            mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26126 = mem[96]
                                            idx = 0
                                            while idx < _26126:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26487 = mem[(32 * idx) + 128]
                                                if not mem[_19917 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27119 = mem[_19917 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26487)
                                                require ext_code.size(address(_27119))
                                                call address(_27119).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26487)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26126 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20218 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19917] = _20218
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26127 = mem[96]
                                                idx = 0
                                                while idx < _26127:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26489 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27123 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26489)
                                                    require ext_code.size(address(_27123))
                                                    call address(_27123).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26489)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26127 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20218 + 32] = stor1[idx].field_0
                                                s = _20218 + 32
                                                t = sha3(mem[0])
                                                while _20218 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19917] = _20218
                                                mem[_19917 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19917 + 64] = stor1[idx].field_512
                                                mem[_19917 + 96] = address(stor1[idx].field_768)
                                                mem[_19917 + 128] = stor1[idx].field_1024
                                                mem[_19917 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31951 = mem[96]
                                                idx = 0
                                                while idx < _31951:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32431 = mem[(32 * idx) + 128]
                                                    if not mem[_19917 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33225 = mem[_19917 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32431)
                                                    require ext_code.size(address(_33225))
                                                    call address(_33225).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32431)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31951 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _19993 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _20221 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_20221] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19993] = _20221
                                                mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19993 + 64] = stor1[idx].field_512
                                                mem[_19993 + 96] = address(stor1[idx].field_768)
                                                mem[_19993 + 128] = stor1[idx].field_1024
                                                mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26128 = mem[96]
                                                idx = 0
                                                while idx < _26128:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26490 = mem[(32 * idx) + 128]
                                                    if not mem[_19993 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27128 = mem[_19993 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26490)
                                                    require ext_code.size(address(_27128))
                                                    call address(_27128).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26490)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26128 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20221 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19993] = _20221
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26129 = mem[96]
                                                    idx = 0
                                                    while idx < _26129:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26492 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27132 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26492)
                                                        require ext_code.size(address(_27132))
                                                        call address(_27132).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26492)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26129 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20221 + 32] = stor1[idx].field_0
                                                    s = _20221 + 32
                                                    t = sha3(mem[0])
                                                    while _20221 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19993] = _20221
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31960 = mem[96]
                                                    idx = 0
                                                    while idx < _31960:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32444 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33256 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32444)
                                                        require ext_code.size(address(_33256))
                                                        call address(_33256).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32444)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31960 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19993] = _20221
                                                mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19993 + 64] = stor1[idx].field_512
                                                mem[_19993 + 96] = address(stor1[idx].field_768)
                                                mem[_19993 + 128] = stor1[idx].field_1024
                                                mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26130 = mem[96]
                                                idx = 0
                                                while idx < _26130:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26493 = mem[(32 * idx) + 128]
                                                    if not mem[_19993 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27135 = mem[_19993 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26493)
                                                    require ext_code.size(address(_27135))
                                                    call address(_27135).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26493)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26130 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20221 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19993] = _20221
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26131 = mem[96]
                                                    idx = 0
                                                    while idx < _26131:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26495 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27139 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26495)
                                                        require ext_code.size(address(_27139))
                                                        call address(_27139).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26495)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26131 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20221 + 32] = stor1[idx].field_0
                                                    s = _20221 + 32
                                                    t = sha3(mem[0])
                                                    while _20221 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19993] = _20221
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31961 = mem[96]
                                                    idx = 0
                                                    while idx < _31961:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32445 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33259 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32445)
                                                        require ext_code.size(address(_33259))
                                                        call address(_33259).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32445)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31961 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _20269 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_20269] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19993] = _20269
                                                mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19993 + 64] = stor1[idx].field_512
                                                mem[_19993 + 96] = address(stor1[idx].field_768)
                                                mem[_19993 + 128] = stor1[idx].field_1024
                                                mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26132 = mem[96]
                                                idx = 0
                                                while idx < _26132:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26496 = mem[(32 * idx) + 128]
                                                    if not mem[_19993 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27142 = mem[_19993 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26496)
                                                    require ext_code.size(address(_27142))
                                                    call address(_27142).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26496)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26132 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20269 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19993] = _20269
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26133 = mem[96]
                                                    idx = 0
                                                    while idx < _26133:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26498 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27146 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26498)
                                                        require ext_code.size(address(_27146))
                                                        call address(_27146).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26498)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26133 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20269 + 32] = stor1[idx].field_0
                                                    s = _20269 + 32
                                                    t = sha3(mem[0])
                                                    while _20269 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19993] = _20269
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31962 = mem[96]
                                                    idx = 0
                                                    while idx < _31962:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32446 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33262 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32446)
                                                        require ext_code.size(address(_33262))
                                                        call address(_33262).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32446)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31962 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19993] = _20269
                                                mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19993 + 64] = stor1[idx].field_512
                                                mem[_19993 + 96] = address(stor1[idx].field_768)
                                                mem[_19993 + 128] = stor1[idx].field_1024
                                                mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26134 = mem[96]
                                                idx = 0
                                                while idx < _26134:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26499 = mem[(32 * idx) + 128]
                                                    if not mem[_19993 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27149 = mem[_19993 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26499)
                                                    require ext_code.size(address(_27149))
                                                    call address(_27149).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26499)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26134 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20269 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19993] = _20269
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26135 = mem[96]
                                                    idx = 0
                                                    while idx < _26135:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26501 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27153 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26501)
                                                        require ext_code.size(address(_27153))
                                                        call address(_27153).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26501)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26135 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20269 + 32] = stor1[idx].field_0
                                                    s = _20269 + 32
                                                    t = sha3(mem[0])
                                                    while _20269 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19993] = _20269
                                                    mem[_19993 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19993 + 64] = stor1[idx].field_512
                                                    mem[_19993 + 96] = address(stor1[idx].field_768)
                                                    mem[_19993 + 128] = stor1[idx].field_1024
                                                    mem[_19993 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31963 = mem[96]
                                                    idx = 0
                                                    while idx < _31963:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32447 = mem[(32 * idx) + 128]
                                                        if not mem[_19993 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33265 = mem[_19993 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32447)
                                                        require ext_code.size(address(_33265))
                                                        call address(_33265).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32447)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31963 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_19567 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _19567 + stor1[idx].field_1 % 128 - mem[64]]) != _19559:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _27802 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _28172 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_28172] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27802] = _28172
                                                mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27802 + 64] = stor1[idx].field_512
                                                mem[_27802 + 96] = address(stor1[idx].field_768)
                                                mem[_27802 + 128] = stor1[idx].field_1024
                                                mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31952 = mem[96]
                                                idx = 0
                                                while idx < _31952:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32432 = mem[(32 * idx) + 128]
                                                    if not mem[_27802 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33228 = mem[_27802 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32432)
                                                    require ext_code.size(address(_33228))
                                                    call address(_33228).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32432)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31952 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28172 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27802] = _28172
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31953 = mem[96]
                                                    idx = 0
                                                    while idx < _31953:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32434 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33232 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32434)
                                                        require ext_code.size(address(_33232))
                                                        call address(_33232).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32434)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31953 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28172 + 32] = stor1[idx].field_0
                                                    s = _28172 + 32
                                                    t = sha3(mem[0])
                                                    while _28172 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27802] = _28172
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35396 = mem[96]
                                                    idx = 0
                                                    while idx < _35396:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35612 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35948 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35612)
                                                        require ext_code.size(address(_35948))
                                                        call address(_35948).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35612)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35396 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27802] = _28172
                                                mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27802 + 64] = stor1[idx].field_512
                                                mem[_27802 + 96] = address(stor1[idx].field_768)
                                                mem[_27802 + 128] = stor1[idx].field_1024
                                                mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31954 = mem[96]
                                                idx = 0
                                                while idx < _31954:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32435 = mem[(32 * idx) + 128]
                                                    if not mem[_27802 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33235 = mem[_27802 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32435)
                                                    require ext_code.size(address(_33235))
                                                    call address(_33235).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32435)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31954 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28172 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27802] = _28172
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31955 = mem[96]
                                                    idx = 0
                                                    while idx < _31955:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32437 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33239 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32437)
                                                        require ext_code.size(address(_33239))
                                                        call address(_33239).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32437)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31955 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28172 + 32] = stor1[idx].field_0
                                                    s = _28172 + 32
                                                    t = sha3(mem[0])
                                                    while _28172 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27802] = _28172
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35397 = mem[96]
                                                    idx = 0
                                                    while idx < _35397:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35613 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35951 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35613)
                                                        require ext_code.size(address(_35951))
                                                        call address(_35951).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35613)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35397 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _28362 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_28362] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27802] = _28362
                                                mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27802 + 64] = stor1[idx].field_512
                                                mem[_27802 + 96] = address(stor1[idx].field_768)
                                                mem[_27802 + 128] = stor1[idx].field_1024
                                                mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31956 = mem[96]
                                                idx = 0
                                                while idx < _31956:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32438 = mem[(32 * idx) + 128]
                                                    if not mem[_27802 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33242 = mem[_27802 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32438)
                                                    require ext_code.size(address(_33242))
                                                    call address(_33242).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32438)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31956 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28362 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27802] = _28362
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31957 = mem[96]
                                                    idx = 0
                                                    while idx < _31957:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32440 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33246 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32440)
                                                        require ext_code.size(address(_33246))
                                                        call address(_33246).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32440)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31957 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28362 + 32] = stor1[idx].field_0
                                                    s = _28362 + 32
                                                    t = sha3(mem[0])
                                                    while _28362 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27802] = _28362
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35398 = mem[96]
                                                    idx = 0
                                                    while idx < _35398:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35614 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35954 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35614)
                                                        require ext_code.size(address(_35954))
                                                        call address(_35954).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35614)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35398 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27802] = _28362
                                                mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27802 + 64] = stor1[idx].field_512
                                                mem[_27802 + 96] = address(stor1[idx].field_768)
                                                mem[_27802 + 128] = stor1[idx].field_1024
                                                mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31958 = mem[96]
                                                idx = 0
                                                while idx < _31958:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32441 = mem[(32 * idx) + 128]
                                                    if not mem[_27802 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33249 = mem[_27802 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32441)
                                                    require ext_code.size(address(_33249))
                                                    call address(_33249).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32441)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31958 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28362 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27802] = _28362
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31959 = mem[96]
                                                    idx = 0
                                                    while idx < _31959:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32443 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33253 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32443)
                                                        require ext_code.size(address(_33253))
                                                        call address(_33253).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32443)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31959 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28362 + 32] = stor1[idx].field_0
                                                    s = _28362 + 32
                                                    t = sha3(mem[0])
                                                    while _28362 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27802] = _28362
                                                    mem[_27802 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27802 + 64] = stor1[idx].field_512
                                                    mem[_27802 + 96] = address(stor1[idx].field_768)
                                                    mem[_27802 + 128] = stor1[idx].field_1024
                                                    mem[_27802 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35399 = mem[96]
                                                    idx = 0
                                                    while idx < _35399:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35615 = mem[(32 * idx) + 128]
                                                        if not mem[_27802 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35957 = mem[_27802 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35615)
                                                        require ext_code.size(address(_35957))
                                                        call address(_35957).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35615)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35399 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _19575 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _19585 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                        mem[_19585] = uint255(stor1.field_1536000000000000000001)
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_19575] = _19585
                                mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26096 = mem[96]
                                idx = 0
                                while idx < _26096:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26442 = mem[(32 * idx) + 128]
                                    if not mem[_19575 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27012 = mem[_19575 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26442)
                                    require ext_code.size(address(_27012))
                                    call address(_27012).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26442)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26096 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_19585 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19575] = _19585
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26097 = mem[96]
                                    idx = 0
                                    while idx < _26097:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26444 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27016 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26444)
                                        require ext_code.size(address(_27016))
                                        call address(_27016).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26444)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26097 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19585 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19585 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19585 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19575] = _19585
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31928 = mem[96]
                                    idx = 0
                                    while idx < _31928:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32404 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33152 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32404)
                                        require ext_code.size(address(_33152))
                                        call address(_33152).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32404)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31928 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_19575] = _19585
                                mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26098 = mem[96]
                                idx = 0
                                while idx < _26098:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26445 = mem[(32 * idx) + 128]
                                    if not mem[_19575 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27019 = mem[_19575 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26445)
                                    require ext_code.size(address(_27019))
                                    call address(_27019).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26445)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26098 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_19585 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19575] = _19585
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26099 = mem[96]
                                    idx = 0
                                    while idx < _26099:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26447 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27023 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26447)
                                        require ext_code.size(address(_27023))
                                        call address(_27023).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26447)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26099 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19585 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19585 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19585 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19575] = _19585
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31929 = mem[96]
                                    idx = 0
                                    while idx < _31929:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32405 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33155 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32405)
                                        require ext_code.size(address(_33155))
                                        call address(_33155).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32405)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31929 = mem[96]
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _19590 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                        mem[_19590] = stor1.field_1536000000000000000001 % 128
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_19575] = _19590
                                mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26100 = mem[96]
                                idx = 0
                                while idx < _26100:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26448 = mem[(32 * idx) + 128]
                                    if not mem[_19575 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27026 = mem[_19575 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26448)
                                    require ext_code.size(address(_27026))
                                    call address(_27026).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26448)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26100 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_19590 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19575] = _19590
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26101 = mem[96]
                                    idx = 0
                                    while idx < _26101:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26450 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27030 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26450)
                                        require ext_code.size(address(_27030))
                                        call address(_27030).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26450)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26101 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19590 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19590 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19590 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19575] = _19590
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31930 = mem[96]
                                    idx = 0
                                    while idx < _31930:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32406 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33158 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32406)
                                        require ext_code.size(address(_33158))
                                        call address(_33158).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32406)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31930 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_19575] = _19590
                                mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26102 = mem[96]
                                idx = 0
                                while idx < _26102:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26451 = mem[(32 * idx) + 128]
                                    if not mem[_19575 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27033 = mem[_19575 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26451)
                                    require ext_code.size(address(_27033))
                                    call address(_27033).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26451)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26102 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_19590 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19575] = _19590
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26103 = mem[96]
                                    idx = 0
                                    while idx < _26103:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26453 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27037 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26453)
                                        require ext_code.size(address(_27037))
                                        call address(_27037).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26453)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26103 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19590 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19590 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19590 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19575] = _19590
                                    mem[_19575 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19575 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19575 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19575 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19575 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31931 = mem[96]
                                    idx = 0
                                    while idx < _31931:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32407 = mem[(32 * idx) + 128]
                                        if not mem[_19575 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33161 = mem[_19575 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32407)
                                        require ext_code.size(address(_33161))
                                        call address(_33161).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32407)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31931 = mem[96]
                                        idx = idx + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_13035 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _13035 + uint255(stor1[idx].field_1) - mem[64]]) != _13033:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _26257 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                        mem[0] = 1
                        _26441 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _26257:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _28651 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _29017 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_29017] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28651] = _29017
                                            mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28651 + 64] = stor1[idx].field_512
                                            mem[_28651 + 96] = address(stor1[idx].field_768)
                                            mem[_28651 + 128] = stor1[idx].field_1024
                                            mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31896 = mem[96]
                                            idx = 0
                                            while idx < _31896:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32356 = mem[(32 * idx) + 128]
                                                if not mem[_28651 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33036 = mem[_28651 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32356)
                                                require ext_code.size(address(_33036))
                                                call address(_33036).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32356)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31896 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29017 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28651] = _29017
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31897 = mem[96]
                                                idx = 0
                                                while idx < _31897:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32358 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33040 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32358)
                                                    require ext_code.size(address(_33040))
                                                    call address(_33040).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32358)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31897 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29017 + 32] = stor1[idx].field_0
                                                s = _29017 + 32
                                                t = sha3(mem[0])
                                                while _29017 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28651] = _29017
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35360 = mem[96]
                                                idx = 0
                                                while idx < _35360:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35568 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35832 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35568)
                                                    require ext_code.size(address(_35832))
                                                    call address(_35832).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35568)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35360 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28651] = _29017
                                            mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28651 + 64] = stor1[idx].field_512
                                            mem[_28651 + 96] = address(stor1[idx].field_768)
                                            mem[_28651 + 128] = stor1[idx].field_1024
                                            mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31898 = mem[96]
                                            idx = 0
                                            while idx < _31898:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32359 = mem[(32 * idx) + 128]
                                                if not mem[_28651 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33043 = mem[_28651 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32359)
                                                require ext_code.size(address(_33043))
                                                call address(_33043).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32359)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31898 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29017 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28651] = _29017
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31899 = mem[96]
                                                idx = 0
                                                while idx < _31899:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32361 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33047 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32361)
                                                    require ext_code.size(address(_33047))
                                                    call address(_33047).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32361)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31899 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29017 + 32] = stor1[idx].field_0
                                                s = _29017 + 32
                                                t = sha3(mem[0])
                                                while _29017 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28651] = _29017
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35361 = mem[96]
                                                idx = 0
                                                while idx < _35361:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35569 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35835 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35569)
                                                    require ext_code.size(address(_35835))
                                                    call address(_35835).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35569)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35361 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _29133 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_29133] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28651] = _29133
                                            mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28651 + 64] = stor1[idx].field_512
                                            mem[_28651 + 96] = address(stor1[idx].field_768)
                                            mem[_28651 + 128] = stor1[idx].field_1024
                                            mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31900 = mem[96]
                                            idx = 0
                                            while idx < _31900:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32362 = mem[(32 * idx) + 128]
                                                if not mem[_28651 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33050 = mem[_28651 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32362)
                                                require ext_code.size(address(_33050))
                                                call address(_33050).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32362)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31900 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29133 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28651] = _29133
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31901 = mem[96]
                                                idx = 0
                                                while idx < _31901:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32364 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33054 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32364)
                                                    require ext_code.size(address(_33054))
                                                    call address(_33054).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32364)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31901 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29133 + 32] = stor1[idx].field_0
                                                s = _29133 + 32
                                                t = sha3(mem[0])
                                                while _29133 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28651] = _29133
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35362 = mem[96]
                                                idx = 0
                                                while idx < _35362:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35570 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35838 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35570)
                                                    require ext_code.size(address(_35838))
                                                    call address(_35838).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35570)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35362 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28651] = _29133
                                            mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28651 + 64] = stor1[idx].field_512
                                            mem[_28651 + 96] = address(stor1[idx].field_768)
                                            mem[_28651 + 128] = stor1[idx].field_1024
                                            mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31902 = mem[96]
                                            idx = 0
                                            while idx < _31902:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32365 = mem[(32 * idx) + 128]
                                                if not mem[_28651 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33057 = mem[_28651 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32365)
                                                require ext_code.size(address(_33057))
                                                call address(_33057).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32365)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31902 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29133 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28651] = _29133
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31903 = mem[96]
                                                idx = 0
                                                while idx < _31903:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32367 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33061 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32367)
                                                    require ext_code.size(address(_33061))
                                                    call address(_33061).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32367)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31903 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29133 + 32] = stor1[idx].field_0
                                                s = _29133 + 32
                                                t = sha3(mem[0])
                                                while _29133 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28651] = _29133
                                                mem[_28651 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28651 + 64] = stor1[idx].field_512
                                                mem[_28651 + 96] = address(stor1[idx].field_768)
                                                mem[_28651 + 128] = stor1[idx].field_1024
                                                mem[_28651 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35363 = mem[96]
                                                idx = 0
                                                while idx < _35363:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35571 = mem[(32 * idx) + 128]
                                                    if not mem[_28651 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35841 = mem[_28651 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35571)
                                                    require ext_code.size(address(_35841))
                                                    call address(_35841).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35571)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35363 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _28724 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _29136 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_29136] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28724] = _29136
                                                mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28724 + 64] = stor1[idx].field_512
                                                mem[_28724 + 96] = address(stor1[idx].field_768)
                                                mem[_28724 + 128] = stor1[idx].field_1024
                                                mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31904 = mem[96]
                                                idx = 0
                                                while idx < _31904:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32368 = mem[(32 * idx) + 128]
                                                    if not mem[_28724 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33066 = mem[_28724 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32368)
                                                    require ext_code.size(address(_33066))
                                                    call address(_33066).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32368)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31904 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29136 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28724] = _29136
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31905 = mem[96]
                                                    idx = 0
                                                    while idx < _31905:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32370 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33070 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32370)
                                                        require ext_code.size(address(_33070))
                                                        call address(_33070).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32370)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31905 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29136 + 32] = stor1[idx].field_0
                                                    s = _29136 + 32
                                                    t = sha3(mem[0])
                                                    while _29136 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28724] = _29136
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35372 = mem[96]
                                                    idx = 0
                                                    while idx < _35372:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35584 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35872 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35584)
                                                        require ext_code.size(address(_35872))
                                                        call address(_35872).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35584)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35372 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28724] = _29136
                                                mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28724 + 64] = stor1[idx].field_512
                                                mem[_28724 + 96] = address(stor1[idx].field_768)
                                                mem[_28724 + 128] = stor1[idx].field_1024
                                                mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31906 = mem[96]
                                                idx = 0
                                                while idx < _31906:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32371 = mem[(32 * idx) + 128]
                                                    if not mem[_28724 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33073 = mem[_28724 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32371)
                                                    require ext_code.size(address(_33073))
                                                    call address(_33073).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32371)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31906 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29136 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28724] = _29136
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31907 = mem[96]
                                                    idx = 0
                                                    while idx < _31907:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32373 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33077 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32373)
                                                        require ext_code.size(address(_33077))
                                                        call address(_33077).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32373)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31907 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29136 + 32] = stor1[idx].field_0
                                                    s = _29136 + 32
                                                    t = sha3(mem[0])
                                                    while _29136 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28724] = _29136
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35373 = mem[96]
                                                    idx = 0
                                                    while idx < _35373:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35585 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35875 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35585)
                                                        require ext_code.size(address(_35875))
                                                        call address(_35875).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35585)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35373 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _29271 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_29271] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28724] = _29271
                                                mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28724 + 64] = stor1[idx].field_512
                                                mem[_28724 + 96] = address(stor1[idx].field_768)
                                                mem[_28724 + 128] = stor1[idx].field_1024
                                                mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31908 = mem[96]
                                                idx = 0
                                                while idx < _31908:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32374 = mem[(32 * idx) + 128]
                                                    if not mem[_28724 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33080 = mem[_28724 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32374)
                                                    require ext_code.size(address(_33080))
                                                    call address(_33080).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32374)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31908 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29271 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28724] = _29271
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31909 = mem[96]
                                                    idx = 0
                                                    while idx < _31909:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32376 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33084 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32376)
                                                        require ext_code.size(address(_33084))
                                                        call address(_33084).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32376)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31909 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29271 + 32] = stor1[idx].field_0
                                                    s = _29271 + 32
                                                    t = sha3(mem[0])
                                                    while _29271 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28724] = _29271
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35374 = mem[96]
                                                    idx = 0
                                                    while idx < _35374:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35586 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35878 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35586)
                                                        require ext_code.size(address(_35878))
                                                        call address(_35878).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35586)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35374 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28724] = _29271
                                                mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28724 + 64] = stor1[idx].field_512
                                                mem[_28724 + 96] = address(stor1[idx].field_768)
                                                mem[_28724 + 128] = stor1[idx].field_1024
                                                mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31910 = mem[96]
                                                idx = 0
                                                while idx < _31910:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32377 = mem[(32 * idx) + 128]
                                                    if not mem[_28724 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33087 = mem[_28724 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32377)
                                                    require ext_code.size(address(_33087))
                                                    call address(_33087).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32377)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31910 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29271 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28724] = _29271
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31911 = mem[96]
                                                    idx = 0
                                                    while idx < _31911:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32379 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33091 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32379)
                                                        require ext_code.size(address(_33091))
                                                        call address(_33091).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32379)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31911 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29271 + 32] = stor1[idx].field_0
                                                    s = _29271 + 32
                                                    t = sha3(mem[0])
                                                    while _29271 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28724] = _29271
                                                    mem[_28724 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28724 + 64] = stor1[idx].field_512
                                                    mem[_28724 + 96] = address(stor1[idx].field_768)
                                                    mem[_28724 + 128] = stor1[idx].field_1024
                                                    mem[_28724 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35375 = mem[96]
                                                    idx = 0
                                                    while idx < _35375:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35587 = mem[(32 * idx) + 128]
                                                        if not mem[_28724 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35881 = mem[_28724 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35587)
                                                        require ext_code.size(address(_35881))
                                                        call address(_35881).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35587)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35375 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_26441 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _26441 + uint255(stor1[idx].field_1) - mem[64]]) != _26257:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _33909 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _34260 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_34260] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_33909] = _34260
                                                mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33909 + 64] = stor1[idx].field_512
                                                mem[_33909 + 96] = address(stor1[idx].field_768)
                                                mem[_33909 + 128] = stor1[idx].field_1024
                                                mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35364 = mem[96]
                                                idx = 0
                                                while idx < _35364:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35572 = mem[(32 * idx) + 128]
                                                    if not mem[_33909 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35844 = mem[_33909 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35572)
                                                    require ext_code.size(address(_35844))
                                                    call address(_35844).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35572)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35364 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34260 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33909] = _34260
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35365 = mem[96]
                                                    idx = 0
                                                    while idx < _35365:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35574 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35848 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35574)
                                                        require ext_code.size(address(_35848))
                                                        call address(_35848).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35574)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35365 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34260 + 32] = stor1[idx].field_0
                                                    s = _34260 + 32
                                                    t = sha3(mem[0])
                                                    while _34260 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33909] = _34260
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36476 = mem[96]
                                                    idx = 0
                                                    while idx < _36476:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36508 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36540 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36508)
                                                        require ext_code.size(address(_36540))
                                                        call address(_36540).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36508)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36476 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_33909] = _34260
                                                mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33909 + 64] = stor1[idx].field_512
                                                mem[_33909 + 96] = address(stor1[idx].field_768)
                                                mem[_33909 + 128] = stor1[idx].field_1024
                                                mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35366 = mem[96]
                                                idx = 0
                                                while idx < _35366:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35575 = mem[(32 * idx) + 128]
                                                    if not mem[_33909 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35851 = mem[_33909 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35575)
                                                    require ext_code.size(address(_35851))
                                                    call address(_35851).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35575)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35366 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34260 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33909] = _34260
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35367 = mem[96]
                                                    idx = 0
                                                    while idx < _35367:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35577 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35855 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35577)
                                                        require ext_code.size(address(_35855))
                                                        call address(_35855).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35577)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35367 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34260 + 32] = stor1[idx].field_0
                                                    s = _34260 + 32
                                                    t = sha3(mem[0])
                                                    while _34260 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33909] = _34260
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36477 = mem[96]
                                                    idx = 0
                                                    while idx < _36477:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36509 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36543 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36509)
                                                        require ext_code.size(address(_36543))
                                                        call address(_36543).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36509)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36477 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _34608 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_34608] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_33909] = _34608
                                                mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33909 + 64] = stor1[idx].field_512
                                                mem[_33909 + 96] = address(stor1[idx].field_768)
                                                mem[_33909 + 128] = stor1[idx].field_1024
                                                mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35368 = mem[96]
                                                idx = 0
                                                while idx < _35368:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35578 = mem[(32 * idx) + 128]
                                                    if not mem[_33909 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35858 = mem[_33909 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35578)
                                                    require ext_code.size(address(_35858))
                                                    call address(_35858).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35578)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35368 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34608 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33909] = _34608
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35369 = mem[96]
                                                    idx = 0
                                                    while idx < _35369:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35580 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35862 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35580)
                                                        require ext_code.size(address(_35862))
                                                        call address(_35862).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35580)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35369 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34608 + 32] = stor1[idx].field_0
                                                    s = _34608 + 32
                                                    t = sha3(mem[0])
                                                    while _34608 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33909] = _34608
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36478 = mem[96]
                                                    idx = 0
                                                    while idx < _36478:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36510 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36546 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36510)
                                                        require ext_code.size(address(_36546))
                                                        call address(_36546).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36510)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36478 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_33909] = _34608
                                                mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33909 + 64] = stor1[idx].field_512
                                                mem[_33909 + 96] = address(stor1[idx].field_768)
                                                mem[_33909 + 128] = stor1[idx].field_1024
                                                mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35370 = mem[96]
                                                idx = 0
                                                while idx < _35370:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35581 = mem[(32 * idx) + 128]
                                                    if not mem[_33909 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35865 = mem[_33909 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35581)
                                                    require ext_code.size(address(_35865))
                                                    call address(_35865).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35581)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35370 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34608 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33909] = _34608
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35371 = mem[96]
                                                    idx = 0
                                                    while idx < _35371:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35583 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35869 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35583)
                                                        require ext_code.size(address(_35869))
                                                        call address(_35869).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35583)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35371 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34608 + 32] = stor1[idx].field_0
                                                    s = _34608 + 32
                                                    t = sha3(mem[0])
                                                    while _34608 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33909] = _34608
                                                    mem[_33909 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33909 + 64] = stor1[idx].field_512
                                                    mem[_33909 + 96] = address(stor1[idx].field_768)
                                                    mem[_33909 + 128] = stor1[idx].field_1024
                                                    mem[_33909 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36479 = mem[96]
                                                    idx = 0
                                                    while idx < _36479:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36511 = mem[(32 * idx) + 128]
                                                        if not mem[_33909 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36549 = mem[_33909 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36511)
                                                        require ext_code.size(address(_36549))
                                                        call address(_36549).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36511)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36479 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _26257:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _28726 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _29137 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_29137] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28726] = _29137
                                            mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28726 + 64] = stor1[idx].field_512
                                            mem[_28726 + 96] = address(stor1[idx].field_768)
                                            mem[_28726 + 128] = stor1[idx].field_1024
                                            mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31912 = mem[96]
                                            idx = 0
                                            while idx < _31912:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32380 = mem[(32 * idx) + 128]
                                                if not mem[_28726 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33094 = mem[_28726 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32380)
                                                require ext_code.size(address(_33094))
                                                call address(_33094).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32380)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31912 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29137 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28726] = _29137
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31913 = mem[96]
                                                idx = 0
                                                while idx < _31913:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32382 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33098 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32382)
                                                    require ext_code.size(address(_33098))
                                                    call address(_33098).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32382)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31913 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29137 + 32] = stor1[idx].field_0
                                                s = _29137 + 32
                                                t = sha3(mem[0])
                                                while _29137 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28726] = _29137
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35376 = mem[96]
                                                idx = 0
                                                while idx < _35376:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35588 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35884 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35588)
                                                    require ext_code.size(address(_35884))
                                                    call address(_35884).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35588)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35376 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28726] = _29137
                                            mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28726 + 64] = stor1[idx].field_512
                                            mem[_28726 + 96] = address(stor1[idx].field_768)
                                            mem[_28726 + 128] = stor1[idx].field_1024
                                            mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31914 = mem[96]
                                            idx = 0
                                            while idx < _31914:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32383 = mem[(32 * idx) + 128]
                                                if not mem[_28726 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33101 = mem[_28726 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32383)
                                                require ext_code.size(address(_33101))
                                                call address(_33101).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32383)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31914 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29137 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28726] = _29137
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31915 = mem[96]
                                                idx = 0
                                                while idx < _31915:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32385 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33105 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32385)
                                                    require ext_code.size(address(_33105))
                                                    call address(_33105).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32385)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31915 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29137 + 32] = stor1[idx].field_0
                                                s = _29137 + 32
                                                t = sha3(mem[0])
                                                while _29137 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28726] = _29137
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35377 = mem[96]
                                                idx = 0
                                                while idx < _35377:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35589 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35887 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35589)
                                                    require ext_code.size(address(_35887))
                                                    call address(_35887).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35589)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35377 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _29272 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_29272] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28726] = _29272
                                            mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28726 + 64] = stor1[idx].field_512
                                            mem[_28726 + 96] = address(stor1[idx].field_768)
                                            mem[_28726 + 128] = stor1[idx].field_1024
                                            mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31916 = mem[96]
                                            idx = 0
                                            while idx < _31916:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32386 = mem[(32 * idx) + 128]
                                                if not mem[_28726 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33108 = mem[_28726 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32386)
                                                require ext_code.size(address(_33108))
                                                call address(_33108).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32386)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31916 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29272 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28726] = _29272
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31917 = mem[96]
                                                idx = 0
                                                while idx < _31917:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32388 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33112 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32388)
                                                    require ext_code.size(address(_33112))
                                                    call address(_33112).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32388)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31917 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29272 + 32] = stor1[idx].field_0
                                                s = _29272 + 32
                                                t = sha3(mem[0])
                                                while _29272 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28726] = _29272
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35378 = mem[96]
                                                idx = 0
                                                while idx < _35378:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35590 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35890 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35590)
                                                    require ext_code.size(address(_35890))
                                                    call address(_35890).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35590)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35378 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28726] = _29272
                                            mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28726 + 64] = stor1[idx].field_512
                                            mem[_28726 + 96] = address(stor1[idx].field_768)
                                            mem[_28726 + 128] = stor1[idx].field_1024
                                            mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31918 = mem[96]
                                            idx = 0
                                            while idx < _31918:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32389 = mem[(32 * idx) + 128]
                                                if not mem[_28726 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33115 = mem[_28726 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32389)
                                                require ext_code.size(address(_33115))
                                                call address(_33115).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32389)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31918 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29272 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28726] = _29272
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31919 = mem[96]
                                                idx = 0
                                                while idx < _31919:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32391 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33119 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32391)
                                                    require ext_code.size(address(_33119))
                                                    call address(_33119).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32391)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31919 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29272 + 32] = stor1[idx].field_0
                                                s = _29272 + 32
                                                t = sha3(mem[0])
                                                while _29272 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28726] = _29272
                                                mem[_28726 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28726 + 64] = stor1[idx].field_512
                                                mem[_28726 + 96] = address(stor1[idx].field_768)
                                                mem[_28726 + 128] = stor1[idx].field_1024
                                                mem[_28726 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35379 = mem[96]
                                                idx = 0
                                                while idx < _35379:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35591 = mem[(32 * idx) + 128]
                                                    if not mem[_28726 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35893 = mem[_28726 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35591)
                                                    require ext_code.size(address(_35893))
                                                    call address(_35893).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35591)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35379 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _28822 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _29275 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_29275] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28822] = _29275
                                                mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28822 + 64] = stor1[idx].field_512
                                                mem[_28822 + 96] = address(stor1[idx].field_768)
                                                mem[_28822 + 128] = stor1[idx].field_1024
                                                mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31920 = mem[96]
                                                idx = 0
                                                while idx < _31920:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32392 = mem[(32 * idx) + 128]
                                                    if not mem[_28822 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33124 = mem[_28822 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32392)
                                                    require ext_code.size(address(_33124))
                                                    call address(_33124).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32392)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31920 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29275 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28822] = _29275
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31921 = mem[96]
                                                    idx = 0
                                                    while idx < _31921:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32394 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33128 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32394)
                                                        require ext_code.size(address(_33128))
                                                        call address(_33128).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32394)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31921 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29275 + 32] = stor1[idx].field_0
                                                    s = _29275 + 32
                                                    t = sha3(mem[0])
                                                    while _29275 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28822] = _29275
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35388 = mem[96]
                                                    idx = 0
                                                    while idx < _35388:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35604 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35924 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35604)
                                                        require ext_code.size(address(_35924))
                                                        call address(_35924).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35604)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35388 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28822] = _29275
                                                mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28822 + 64] = stor1[idx].field_512
                                                mem[_28822 + 96] = address(stor1[idx].field_768)
                                                mem[_28822 + 128] = stor1[idx].field_1024
                                                mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31922 = mem[96]
                                                idx = 0
                                                while idx < _31922:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32395 = mem[(32 * idx) + 128]
                                                    if not mem[_28822 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33131 = mem[_28822 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32395)
                                                    require ext_code.size(address(_33131))
                                                    call address(_33131).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32395)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31922 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29275 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28822] = _29275
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31923 = mem[96]
                                                    idx = 0
                                                    while idx < _31923:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32397 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33135 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32397)
                                                        require ext_code.size(address(_33135))
                                                        call address(_33135).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32397)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31923 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29275 + 32] = stor1[idx].field_0
                                                    s = _29275 + 32
                                                    t = sha3(mem[0])
                                                    while _29275 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28822] = _29275
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35389 = mem[96]
                                                    idx = 0
                                                    while idx < _35389:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35605 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35927 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35605)
                                                        require ext_code.size(address(_35927))
                                                        call address(_35927).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35605)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35389 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _29404 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_29404] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28822] = _29404
                                                mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28822 + 64] = stor1[idx].field_512
                                                mem[_28822 + 96] = address(stor1[idx].field_768)
                                                mem[_28822 + 128] = stor1[idx].field_1024
                                                mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31924 = mem[96]
                                                idx = 0
                                                while idx < _31924:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32398 = mem[(32 * idx) + 128]
                                                    if not mem[_28822 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33138 = mem[_28822 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32398)
                                                    require ext_code.size(address(_33138))
                                                    call address(_33138).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32398)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31924 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29404 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28822] = _29404
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31925 = mem[96]
                                                    idx = 0
                                                    while idx < _31925:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32400 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33142 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32400)
                                                        require ext_code.size(address(_33142))
                                                        call address(_33142).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32400)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31925 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29404 + 32] = stor1[idx].field_0
                                                    s = _29404 + 32
                                                    t = sha3(mem[0])
                                                    while _29404 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28822] = _29404
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35390 = mem[96]
                                                    idx = 0
                                                    while idx < _35390:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35606 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35930 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35606)
                                                        require ext_code.size(address(_35930))
                                                        call address(_35930).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35606)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35390 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28822] = _29404
                                                mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28822 + 64] = stor1[idx].field_512
                                                mem[_28822 + 96] = address(stor1[idx].field_768)
                                                mem[_28822 + 128] = stor1[idx].field_1024
                                                mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31926 = mem[96]
                                                idx = 0
                                                while idx < _31926:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32401 = mem[(32 * idx) + 128]
                                                    if not mem[_28822 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33145 = mem[_28822 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32401)
                                                    require ext_code.size(address(_33145))
                                                    call address(_33145).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32401)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31926 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29404 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28822] = _29404
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _31927 = mem[96]
                                                    idx = 0
                                                    while idx < _31927:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32403 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33149 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32403)
                                                        require ext_code.size(address(_33149))
                                                        call address(_33149).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32403)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _31927 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29404 + 32] = stor1[idx].field_0
                                                    s = _29404 + 32
                                                    t = sha3(mem[0])
                                                    while _29404 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28822] = _29404
                                                    mem[_28822 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28822 + 64] = stor1[idx].field_512
                                                    mem[_28822 + 96] = address(stor1[idx].field_768)
                                                    mem[_28822 + 128] = stor1[idx].field_1024
                                                    mem[_28822 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35391 = mem[96]
                                                    idx = 0
                                                    while idx < _35391:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35607 = mem[(32 * idx) + 128]
                                                        if not mem[_28822 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35933 = mem[_28822 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35607)
                                                        require ext_code.size(address(_35933))
                                                        call address(_35933).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35607)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35391 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_26441 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _26441 + stor1[idx].field_1 % 128 - mem[64]]) != _26257:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _33935 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _34293 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_34293] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_33935] = _34293
                                                mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33935 + 64] = stor1[idx].field_512
                                                mem[_33935 + 96] = address(stor1[idx].field_768)
                                                mem[_33935 + 128] = stor1[idx].field_1024
                                                mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35380 = mem[96]
                                                idx = 0
                                                while idx < _35380:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35592 = mem[(32 * idx) + 128]
                                                    if not mem[_33935 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35896 = mem[_33935 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35592)
                                                    require ext_code.size(address(_35896))
                                                    call address(_35896).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35592)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35380 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34293 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33935] = _34293
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35381 = mem[96]
                                                    idx = 0
                                                    while idx < _35381:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35594 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35900 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35594)
                                                        require ext_code.size(address(_35900))
                                                        call address(_35900).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35594)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35381 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34293 + 32] = stor1[idx].field_0
                                                    s = _34293 + 32
                                                    t = sha3(mem[0])
                                                    while _34293 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33935] = _34293
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36480 = mem[96]
                                                    idx = 0
                                                    while idx < _36480:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36512 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36552 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36512)
                                                        require ext_code.size(address(_36552))
                                                        call address(_36552).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36512)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36480 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_33935] = _34293
                                                mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33935 + 64] = stor1[idx].field_512
                                                mem[_33935 + 96] = address(stor1[idx].field_768)
                                                mem[_33935 + 128] = stor1[idx].field_1024
                                                mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35382 = mem[96]
                                                idx = 0
                                                while idx < _35382:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35595 = mem[(32 * idx) + 128]
                                                    if not mem[_33935 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35903 = mem[_33935 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35595)
                                                    require ext_code.size(address(_35903))
                                                    call address(_35903).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35595)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35382 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34293 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33935] = _34293
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35383 = mem[96]
                                                    idx = 0
                                                    while idx < _35383:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35597 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35907 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35597)
                                                        require ext_code.size(address(_35907))
                                                        call address(_35907).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35597)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35383 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34293 + 32] = stor1[idx].field_0
                                                    s = _34293 + 32
                                                    t = sha3(mem[0])
                                                    while _34293 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33935] = _34293
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36481 = mem[96]
                                                    idx = 0
                                                    while idx < _36481:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36513 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36555 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36513)
                                                        require ext_code.size(address(_36555))
                                                        call address(_36555).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36513)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36481 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _34609 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_34609] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_33935] = _34609
                                                mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33935 + 64] = stor1[idx].field_512
                                                mem[_33935 + 96] = address(stor1[idx].field_768)
                                                mem[_33935 + 128] = stor1[idx].field_1024
                                                mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35384 = mem[96]
                                                idx = 0
                                                while idx < _35384:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35598 = mem[(32 * idx) + 128]
                                                    if not mem[_33935 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35910 = mem[_33935 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35598)
                                                    require ext_code.size(address(_35910))
                                                    call address(_35910).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35598)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35384 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34609 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33935] = _34609
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35385 = mem[96]
                                                    idx = 0
                                                    while idx < _35385:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35600 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35914 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35600)
                                                        require ext_code.size(address(_35914))
                                                        call address(_35914).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35600)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35385 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34609 + 32] = stor1[idx].field_0
                                                    s = _34609 + 32
                                                    t = sha3(mem[0])
                                                    while _34609 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33935] = _34609
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36482 = mem[96]
                                                    idx = 0
                                                    while idx < _36482:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36514 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36558 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36514)
                                                        require ext_code.size(address(_36558))
                                                        call address(_36558).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36514)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36482 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_33935] = _34609
                                                mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_33935 + 64] = stor1[idx].field_512
                                                mem[_33935 + 96] = address(stor1[idx].field_768)
                                                mem[_33935 + 128] = stor1[idx].field_1024
                                                mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35386 = mem[96]
                                                idx = 0
                                                while idx < _35386:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35601 = mem[(32 * idx) + 128]
                                                    if not mem[_33935 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35917 = mem[_33935 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35601)
                                                    require ext_code.size(address(_35917))
                                                    call address(_35917).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35601)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35386 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34609 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_33935] = _34609
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35387 = mem[96]
                                                    idx = 0
                                                    while idx < _35387:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35603 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _35921 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35603)
                                                        require ext_code.size(address(_35921))
                                                        call address(_35921).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35603)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35387 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34609 + 32] = stor1[idx].field_0
                                                    s = _34609 + 32
                                                    t = sha3(mem[0])
                                                    while _34609 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_33935] = _34609
                                                    mem[_33935 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_33935 + 64] = stor1[idx].field_512
                                                    mem[_33935 + 96] = address(stor1[idx].field_768)
                                                    mem[_33935 + 128] = stor1[idx].field_1024
                                                    mem[_33935 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36483 = mem[96]
                                                    idx = 0
                                                    while idx < _36483:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36515 = mem[(32 * idx) + 128]
                                                        if not mem[_33935 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36561 = mem[_33935 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36515)
                                                        require ext_code.size(address(_36561))
                                                        call address(_36561).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36515)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36483 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _26685 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _27624 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                        mem[_27624] = uint255(stor1.field_1536000000000000000001)
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_26685] = _27624
                                mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31888 = mem[96]
                                idx = 0
                                while idx < _31888:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32344 = mem[(32 * idx) + 128]
                                    if not mem[_26685 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33008 = mem[_26685 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32344)
                                    require ext_code.size(address(_33008))
                                    call address(_33008).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32344)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31888 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_27624 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26685] = _27624
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31889 = mem[96]
                                    idx = 0
                                    while idx < _31889:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32346 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33012 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32346)
                                        require ext_code.size(address(_33012))
                                        call address(_33012).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32346)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31889 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27624 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27624 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27624 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26685] = _27624
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35356 = mem[96]
                                    idx = 0
                                    while idx < _35356:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35564 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35820 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35564)
                                        require ext_code.size(address(_35820))
                                        call address(_35820).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35564)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35356 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_26685] = _27624
                                mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31890 = mem[96]
                                idx = 0
                                while idx < _31890:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32347 = mem[(32 * idx) + 128]
                                    if not mem[_26685 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33015 = mem[_26685 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32347)
                                    require ext_code.size(address(_33015))
                                    call address(_33015).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32347)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31890 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_27624 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26685] = _27624
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31891 = mem[96]
                                    idx = 0
                                    while idx < _31891:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32349 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33019 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32349)
                                        require ext_code.size(address(_33019))
                                        call address(_33019).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32349)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31891 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27624 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27624 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27624 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26685] = _27624
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35357 = mem[96]
                                    idx = 0
                                    while idx < _35357:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35565 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35823 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35565)
                                        require ext_code.size(address(_35823))
                                        call address(_35823).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35565)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35357 = mem[96]
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _27750 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                        mem[_27750] = stor1.field_1536000000000000000001 % 128
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_26685] = _27750
                                mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31892 = mem[96]
                                idx = 0
                                while idx < _31892:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32350 = mem[(32 * idx) + 128]
                                    if not mem[_26685 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33022 = mem[_26685 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32350)
                                    require ext_code.size(address(_33022))
                                    call address(_33022).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32350)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31892 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_27750 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26685] = _27750
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31893 = mem[96]
                                    idx = 0
                                    while idx < _31893:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32352 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33026 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32352)
                                        require ext_code.size(address(_33026))
                                        call address(_33026).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32352)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31893 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27750 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27750 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27750 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26685] = _27750
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35358 = mem[96]
                                    idx = 0
                                    while idx < _35358:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35566 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35826 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35566)
                                        require ext_code.size(address(_35826))
                                        call address(_35826).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35566)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35358 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_26685] = _27750
                                mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31894 = mem[96]
                                idx = 0
                                while idx < _31894:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32353 = mem[(32 * idx) + 128]
                                    if not mem[_26685 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33029 = mem[_26685 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32353)
                                    require ext_code.size(address(_33029))
                                    call address(_33029).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32353)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31894 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_27750 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26685] = _27750
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _31895 = mem[96]
                                    idx = 0
                                    while idx < _31895:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32355 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33033 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32355)
                                        require ext_code.size(address(_33033))
                                        call address(_33033).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32355)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _31895 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27750 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27750 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27750 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26685] = _27750
                                    mem[_26685 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26685 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26685 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26685 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26685 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35359 = mem[96]
                                    idx = 0
                                    while idx < _35359:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35567 = mem[(32 * idx) + 128]
                                        if not mem[_26685 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35829 = mem[_26685 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35567)
                                        require ext_code.size(address(_35829))
                                        call address(_35829).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35567)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35359 = mem[96]
                                        idx = idx + 1
                                        continue 
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _13033:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                idx = 0
                while idx < stor1.length:
                    _19561 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                    mem[0] = 1
                    _19569 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _19561:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _19858 = mem[64]
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _20112 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                mem[_20112] = uint255(stor1[idx].field_1)
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19858] = _20112
                                        mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19858 + 64] = stor1[idx].field_512
                                        mem[_19858 + 96] = address(stor1[idx].field_768)
                                        mem[_19858 + 128] = stor1[idx].field_1024
                                        mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26144 = mem[96]
                                        idx = 0
                                        while idx < _26144:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26514 = mem[(32 * idx) + 128]
                                            if not mem[_19858 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27184 = mem[_19858 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26514)
                                            require ext_code.size(address(_27184))
                                            call address(_27184).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26514)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26144 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20112 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19858] = _20112
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26145 = mem[96]
                                            idx = 0
                                            while idx < _26145:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26516 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27188 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26516)
                                                require ext_code.size(address(_27188))
                                                call address(_27188).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26516)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26145 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20112 + 32] = stor1[idx].field_0
                                            s = _20112 + 32
                                            t = sha3(mem[0])
                                            while _20112 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19858] = _20112
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31968 = mem[96]
                                            idx = 0
                                            while idx < _31968:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32452 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33280 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32452)
                                                require ext_code.size(address(_33280))
                                                call address(_33280).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32452)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31968 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19858] = _20112
                                        mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19858 + 64] = stor1[idx].field_512
                                        mem[_19858 + 96] = address(stor1[idx].field_768)
                                        mem[_19858 + 128] = stor1[idx].field_1024
                                        mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26146 = mem[96]
                                        idx = 0
                                        while idx < _26146:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26517 = mem[(32 * idx) + 128]
                                            if not mem[_19858 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27191 = mem[_19858 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26517)
                                            require ext_code.size(address(_27191))
                                            call address(_27191).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26517)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26146 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20112 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19858] = _20112
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26147 = mem[96]
                                            idx = 0
                                            while idx < _26147:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26519 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27195 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26519)
                                                require ext_code.size(address(_27195))
                                                call address(_27195).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26519)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26147 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20112 + 32] = stor1[idx].field_0
                                            s = _20112 + 32
                                            t = sha3(mem[0])
                                            while _20112 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19858] = _20112
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31969 = mem[96]
                                            idx = 0
                                            while idx < _31969:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32453 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33283 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32453)
                                                require ext_code.size(address(_33283))
                                                call address(_33283).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32453)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31969 = mem[96]
                                                idx = idx + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _20168 = mem[64]
                                mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                mem[_20168] = stor1[idx].field_1 % 128
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19858] = _20168
                                        mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19858 + 64] = stor1[idx].field_512
                                        mem[_19858 + 96] = address(stor1[idx].field_768)
                                        mem[_19858 + 128] = stor1[idx].field_1024
                                        mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26148 = mem[96]
                                        idx = 0
                                        while idx < _26148:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26520 = mem[(32 * idx) + 128]
                                            if not mem[_19858 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27198 = mem[_19858 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26520)
                                            require ext_code.size(address(_27198))
                                            call address(_27198).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26520)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26148 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20168 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19858] = _20168
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26149 = mem[96]
                                            idx = 0
                                            while idx < _26149:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26522 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27202 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26522)
                                                require ext_code.size(address(_27202))
                                                call address(_27202).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26522)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26149 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20168 + 32] = stor1[idx].field_0
                                            s = _20168 + 32
                                            t = sha3(mem[0])
                                            while _20168 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19858] = _20168
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31970 = mem[96]
                                            idx = 0
                                            while idx < _31970:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32454 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33286 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32454)
                                                require ext_code.size(address(_33286))
                                                call address(_33286).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32454)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31970 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19858] = _20168
                                        mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19858 + 64] = stor1[idx].field_512
                                        mem[_19858 + 96] = address(stor1[idx].field_768)
                                        mem[_19858 + 128] = stor1[idx].field_1024
                                        mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26150 = mem[96]
                                        idx = 0
                                        while idx < _26150:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26523 = mem[(32 * idx) + 128]
                                            if not mem[_19858 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27205 = mem[_19858 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26523)
                                            require ext_code.size(address(_27205))
                                            call address(_27205).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26523)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26150 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20168 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19858] = _20168
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26151 = mem[96]
                                            idx = 0
                                            while idx < _26151:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26525 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27209 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26525)
                                                require ext_code.size(address(_27209))
                                                call address(_27209).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26525)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26151 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20168 + 32] = stor1[idx].field_0
                                            s = _20168 + 32
                                            t = sha3(mem[0])
                                            while _20168 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19858] = _20168
                                            mem[_19858 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19858 + 64] = stor1[idx].field_512
                                            mem[_19858 + 96] = address(stor1[idx].field_768)
                                            mem[_19858 + 128] = stor1[idx].field_1024
                                            mem[_19858 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31971 = mem[96]
                                            idx = 0
                                            while idx < _31971:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32455 = mem[(32 * idx) + 128]
                                                if not mem[_19858 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33289 = mem[_19858 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32455)
                                                require ext_code.size(address(_33289))
                                                call address(_33289).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32455)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31971 = mem[96]
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19936 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20171 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20171] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19936] = _20171
                                            mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19936 + 64] = stor1[idx].field_512
                                            mem[_19936 + 96] = address(stor1[idx].field_768)
                                            mem[_19936 + 128] = stor1[idx].field_1024
                                            mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26152 = mem[96]
                                            idx = 0
                                            while idx < _26152:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26526 = mem[(32 * idx) + 128]
                                                if not mem[_19936 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27214 = mem[_19936 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26526)
                                                require ext_code.size(address(_27214))
                                                call address(_27214).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26526)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26152 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20171 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19936] = _20171
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26153 = mem[96]
                                                idx = 0
                                                while idx < _26153:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26528 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27218 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26528)
                                                    require ext_code.size(address(_27218))
                                                    call address(_27218).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26528)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26153 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20171 + 32] = stor1[idx].field_0
                                                s = _20171 + 32
                                                t = sha3(mem[0])
                                                while _20171 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19936] = _20171
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31980 = mem[96]
                                                idx = 0
                                                while idx < _31980:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32468 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33320 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32468)
                                                    require ext_code.size(address(_33320))
                                                    call address(_33320).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32468)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31980 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19936] = _20171
                                            mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19936 + 64] = stor1[idx].field_512
                                            mem[_19936 + 96] = address(stor1[idx].field_768)
                                            mem[_19936 + 128] = stor1[idx].field_1024
                                            mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26154 = mem[96]
                                            idx = 0
                                            while idx < _26154:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26529 = mem[(32 * idx) + 128]
                                                if not mem[_19936 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27221 = mem[_19936 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26529)
                                                require ext_code.size(address(_27221))
                                                call address(_27221).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26529)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26154 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20171 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19936] = _20171
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26155 = mem[96]
                                                idx = 0
                                                while idx < _26155:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26531 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27225 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26531)
                                                    require ext_code.size(address(_27225))
                                                    call address(_27225).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26531)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26155 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20171 + 32] = stor1[idx].field_0
                                                s = _20171 + 32
                                                t = sha3(mem[0])
                                                while _20171 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19936] = _20171
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31981 = mem[96]
                                                idx = 0
                                                while idx < _31981:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32469 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33323 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32469)
                                                    require ext_code.size(address(_33323))
                                                    call address(_33323).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32469)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31981 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20227 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20227] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19936] = _20227
                                            mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19936 + 64] = stor1[idx].field_512
                                            mem[_19936 + 96] = address(stor1[idx].field_768)
                                            mem[_19936 + 128] = stor1[idx].field_1024
                                            mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26156 = mem[96]
                                            idx = 0
                                            while idx < _26156:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26532 = mem[(32 * idx) + 128]
                                                if not mem[_19936 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27228 = mem[_19936 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26532)
                                                require ext_code.size(address(_27228))
                                                call address(_27228).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26532)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26156 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20227 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19936] = _20227
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26157 = mem[96]
                                                idx = 0
                                                while idx < _26157:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26534 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27232 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26534)
                                                    require ext_code.size(address(_27232))
                                                    call address(_27232).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26534)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26157 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20227 + 32] = stor1[idx].field_0
                                                s = _20227 + 32
                                                t = sha3(mem[0])
                                                while _20227 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19936] = _20227
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31982 = mem[96]
                                                idx = 0
                                                while idx < _31982:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32470 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33326 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32470)
                                                    require ext_code.size(address(_33326))
                                                    call address(_33326).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32470)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31982 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19936] = _20227
                                            mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19936 + 64] = stor1[idx].field_512
                                            mem[_19936 + 96] = address(stor1[idx].field_768)
                                            mem[_19936 + 128] = stor1[idx].field_1024
                                            mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26158 = mem[96]
                                            idx = 0
                                            while idx < _26158:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26535 = mem[(32 * idx) + 128]
                                                if not mem[_19936 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27235 = mem[_19936 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26535)
                                                require ext_code.size(address(_27235))
                                                call address(_27235).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26535)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26158 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20227 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19936] = _20227
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26159 = mem[96]
                                                idx = 0
                                                while idx < _26159:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26537 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27239 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26537)
                                                    require ext_code.size(address(_27239))
                                                    call address(_27239).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26537)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26159 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20227 + 32] = stor1[idx].field_0
                                                s = _20227 + 32
                                                t = sha3(mem[0])
                                                while _20227 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19936] = _20227
                                                mem[_19936 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19936 + 64] = stor1[idx].field_512
                                                mem[_19936 + 96] = address(stor1[idx].field_768)
                                                mem[_19936 + 128] = stor1[idx].field_1024
                                                mem[_19936 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31983 = mem[96]
                                                idx = 0
                                                while idx < _31983:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32471 = mem[(32 * idx) + 128]
                                                    if not mem[_19936 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33329 = mem[_19936 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32471)
                                                    require ext_code.size(address(_33329))
                                                    call address(_33329).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32471)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31983 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_19569 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _19569 + uint255(stor1[idx].field_1) - mem[64]]) != _19561:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _27840 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _28221 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_28221] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27840] = _28221
                                            mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27840 + 64] = stor1[idx].field_512
                                            mem[_27840 + 96] = address(stor1[idx].field_768)
                                            mem[_27840 + 128] = stor1[idx].field_1024
                                            mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31972 = mem[96]
                                            idx = 0
                                            while idx < _31972:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32456 = mem[(32 * idx) + 128]
                                                if not mem[_27840 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33292 = mem[_27840 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32456)
                                                require ext_code.size(address(_33292))
                                                call address(_33292).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32456)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31972 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28221 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27840] = _28221
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31973 = mem[96]
                                                idx = 0
                                                while idx < _31973:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32458 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33296 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32458)
                                                    require ext_code.size(address(_33296))
                                                    call address(_33296).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32458)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31973 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28221 + 32] = stor1[idx].field_0
                                                s = _28221 + 32
                                                t = sha3(mem[0])
                                                while _28221 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27840] = _28221
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35400 = mem[96]
                                                idx = 0
                                                while idx < _35400:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35616 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35960 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35616)
                                                    require ext_code.size(address(_35960))
                                                    call address(_35960).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35616)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35400 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27840] = _28221
                                            mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27840 + 64] = stor1[idx].field_512
                                            mem[_27840 + 96] = address(stor1[idx].field_768)
                                            mem[_27840 + 128] = stor1[idx].field_1024
                                            mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31974 = mem[96]
                                            idx = 0
                                            while idx < _31974:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32459 = mem[(32 * idx) + 128]
                                                if not mem[_27840 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33299 = mem[_27840 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32459)
                                                require ext_code.size(address(_33299))
                                                call address(_33299).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32459)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31974 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28221 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27840] = _28221
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31975 = mem[96]
                                                idx = 0
                                                while idx < _31975:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32461 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33303 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32461)
                                                    require ext_code.size(address(_33303))
                                                    call address(_33303).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32461)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31975 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28221 + 32] = stor1[idx].field_0
                                                s = _28221 + 32
                                                t = sha3(mem[0])
                                                while _28221 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27840] = _28221
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35401 = mem[96]
                                                idx = 0
                                                while idx < _35401:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35617 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35963 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35617)
                                                    require ext_code.size(address(_35963))
                                                    call address(_35963).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35617)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35401 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _28363 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_28363] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27840] = _28363
                                            mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27840 + 64] = stor1[idx].field_512
                                            mem[_27840 + 96] = address(stor1[idx].field_768)
                                            mem[_27840 + 128] = stor1[idx].field_1024
                                            mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31976 = mem[96]
                                            idx = 0
                                            while idx < _31976:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32462 = mem[(32 * idx) + 128]
                                                if not mem[_27840 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33306 = mem[_27840 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32462)
                                                require ext_code.size(address(_33306))
                                                call address(_33306).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32462)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31976 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28363 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27840] = _28363
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31977 = mem[96]
                                                idx = 0
                                                while idx < _31977:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32464 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33310 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32464)
                                                    require ext_code.size(address(_33310))
                                                    call address(_33310).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32464)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31977 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28363 + 32] = stor1[idx].field_0
                                                s = _28363 + 32
                                                t = sha3(mem[0])
                                                while _28363 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27840] = _28363
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35402 = mem[96]
                                                idx = 0
                                                while idx < _35402:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35618 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35966 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35618)
                                                    require ext_code.size(address(_35966))
                                                    call address(_35966).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35618)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35402 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27840] = _28363
                                            mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27840 + 64] = stor1[idx].field_512
                                            mem[_27840 + 96] = address(stor1[idx].field_768)
                                            mem[_27840 + 128] = stor1[idx].field_1024
                                            mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31978 = mem[96]
                                            idx = 0
                                            while idx < _31978:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32465 = mem[(32 * idx) + 128]
                                                if not mem[_27840 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33313 = mem[_27840 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32465)
                                                require ext_code.size(address(_33313))
                                                call address(_33313).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32465)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31978 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28363 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27840] = _28363
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31979 = mem[96]
                                                idx = 0
                                                while idx < _31979:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32467 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33317 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32467)
                                                    require ext_code.size(address(_33317))
                                                    call address(_33317).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32467)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31979 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28363 + 32] = stor1[idx].field_0
                                                s = _28363 + 32
                                                t = sha3(mem[0])
                                                while _28363 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27840] = _28363
                                                mem[_27840 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27840 + 64] = stor1[idx].field_512
                                                mem[_27840 + 96] = address(stor1[idx].field_768)
                                                mem[_27840 + 128] = stor1[idx].field_1024
                                                mem[_27840 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35403 = mem[96]
                                                idx = 0
                                                while idx < _35403:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35619 = mem[(32 * idx) + 128]
                                                    if not mem[_27840 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35969 = mem[_27840 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35619)
                                                    require ext_code.size(address(_35969))
                                                    call address(_35969).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35619)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35403 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _19561:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _19938 = mem[64]
                            mem[64] = mem[64] + 192
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                _20172 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                mem[_20172] = uint255(stor1[idx].field_1)
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19938] = _20172
                                        mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19938 + 64] = stor1[idx].field_512
                                        mem[_19938 + 96] = address(stor1[idx].field_768)
                                        mem[_19938 + 128] = stor1[idx].field_1024
                                        mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26160 = mem[96]
                                        idx = 0
                                        while idx < _26160:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26538 = mem[(32 * idx) + 128]
                                            if not mem[_19938 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27242 = mem[_19938 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26538)
                                            require ext_code.size(address(_27242))
                                            call address(_27242).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26538)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26160 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20172 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19938] = _20172
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26161 = mem[96]
                                            idx = 0
                                            while idx < _26161:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26540 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27246 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26540)
                                                require ext_code.size(address(_27246))
                                                call address(_27246).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26540)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26161 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20172 + 32] = stor1[idx].field_0
                                            s = _20172 + 32
                                            t = sha3(mem[0])
                                            while _20172 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19938] = _20172
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31984 = mem[96]
                                            idx = 0
                                            while idx < _31984:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32472 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33332 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32472)
                                                require ext_code.size(address(_33332))
                                                call address(_33332).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32472)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31984 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19938] = _20172
                                        mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19938 + 64] = stor1[idx].field_512
                                        mem[_19938 + 96] = address(stor1[idx].field_768)
                                        mem[_19938 + 128] = stor1[idx].field_1024
                                        mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26162 = mem[96]
                                        idx = 0
                                        while idx < _26162:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26541 = mem[(32 * idx) + 128]
                                            if not mem[_19938 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27249 = mem[_19938 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26541)
                                            require ext_code.size(address(_27249))
                                            call address(_27249).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26541)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26162 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20172 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19938] = _20172
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26163 = mem[96]
                                            idx = 0
                                            while idx < _26163:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26543 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27253 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26543)
                                                require ext_code.size(address(_27253))
                                                call address(_27253).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26543)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26163 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20172 + 32] = stor1[idx].field_0
                                            s = _20172 + 32
                                            t = sha3(mem[0])
                                            while _20172 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19938] = _20172
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31985 = mem[96]
                                            idx = 0
                                            while idx < _31985:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32473 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33335 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32473)
                                                require ext_code.size(address(_33335))
                                                call address(_33335).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32473)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31985 = mem[96]
                                                idx = idx + 1
                                                continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                _20228 = mem[64]
                                mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                mem[_20228] = stor1[idx].field_1 % 128
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not uint255(stor1[idx].field_1):
                                        mem[_19938] = _20228
                                        mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19938 + 64] = stor1[idx].field_512
                                        mem[_19938 + 96] = address(stor1[idx].field_768)
                                        mem[_19938 + 128] = stor1[idx].field_1024
                                        mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26164 = mem[96]
                                        idx = 0
                                        while idx < _26164:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26544 = mem[(32 * idx) + 128]
                                            if not mem[_19938 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27256 = mem[_19938 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26544)
                                            require ext_code.size(address(_27256))
                                            call address(_27256).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26544)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26164 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= uint255(stor1[idx].field_1):
                                            mem[_20228 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19938] = _20228
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26165 = mem[96]
                                            idx = 0
                                            while idx < _26165:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26546 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27260 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26546)
                                                require ext_code.size(address(_27260))
                                                call address(_27260).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26546)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26165 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20228 + 32] = stor1[idx].field_0
                                            s = _20228 + 32
                                            t = sha3(mem[0])
                                            while _20228 + uint255(stor1[idx].field_1) > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19938] = _20228
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31986 = mem[96]
                                            idx = 0
                                            while idx < _31986:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32474 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33338 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32474)
                                                require ext_code.size(address(_33338))
                                                call address(_33338).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32474)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31986 = mem[96]
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not stor1[idx].field_1 % 128:
                                        mem[_19938] = _20228
                                        mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                        mem[_19938 + 64] = stor1[idx].field_512
                                        mem[_19938 + 96] = address(stor1[idx].field_768)
                                        mem[_19938 + 128] = stor1[idx].field_1024
                                        mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                        if not address(stor1[idx].field_768):
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _26166 = mem[96]
                                        idx = 0
                                        while idx < _26166:
                                            if idx >= mem[96]:
                                                revert with 'NH{q', 50
                                            _26547 = mem[(32 * idx) + 128]
                                            if not mem[_19938 + 108 len 20]:
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _27263 = mem[_19938 + 96]
                                            mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = address(_26547)
                                            require ext_code.size(address(_27263))
                                            call address(_27263).0x40d097c3 with:
                                                 gas gas_remaining wei
                                                args address(_26547)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            _26166 = mem[96]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 >= stor1[idx].field_1 % 128:
                                            mem[_20228 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                            mem[_19938] = _20228
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26167 = mem[96]
                                            idx = 0
                                            while idx < _26167:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26549 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27267 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26549)
                                                require ext_code.size(address(_27267))
                                                call address(_27267).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26549)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26167 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            mem[_20228 + 32] = stor1[idx].field_0
                                            s = _20228 + 32
                                            t = sha3(mem[0])
                                            while _20228 + stor1[idx].field_1 % 128 > s:
                                                mem[s + 32] = stor1[t].field_0
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            mem[_19938] = _20228
                                            mem[_19938 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19938 + 64] = stor1[idx].field_512
                                            mem[_19938 + 96] = address(stor1[idx].field_768)
                                            mem[_19938 + 128] = stor1[idx].field_1024
                                            mem[_19938 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31987 = mem[96]
                                            idx = 0
                                            while idx < _31987:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32475 = mem[(32 * idx) + 128]
                                                if not mem[_19938 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33341 = mem[_19938 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32475)
                                                require ext_code.size(address(_33341))
                                                call address(_33341).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32475)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31987 = mem[96]
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _20010 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20231 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20231] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_20010] = _20231
                                            mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_20010 + 64] = stor1[idx].field_512
                                            mem[_20010 + 96] = address(stor1[idx].field_768)
                                            mem[_20010 + 128] = stor1[idx].field_1024
                                            mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26168 = mem[96]
                                            idx = 0
                                            while idx < _26168:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26550 = mem[(32 * idx) + 128]
                                                if not mem[_20010 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27272 = mem[_20010 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26550)
                                                require ext_code.size(address(_27272))
                                                call address(_27272).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26550)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26168 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20231 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_20010] = _20231
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26169 = mem[96]
                                                idx = 0
                                                while idx < _26169:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26552 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27276 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26552)
                                                    require ext_code.size(address(_27276))
                                                    call address(_27276).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26552)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26169 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20231 + 32] = stor1[idx].field_0
                                                s = _20231 + 32
                                                t = sha3(mem[0])
                                                while _20231 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_20010] = _20231
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31996 = mem[96]
                                                idx = 0
                                                while idx < _31996:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32488 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33372 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32488)
                                                    require ext_code.size(address(_33372))
                                                    call address(_33372).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32488)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31996 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_20010] = _20231
                                            mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_20010 + 64] = stor1[idx].field_512
                                            mem[_20010 + 96] = address(stor1[idx].field_768)
                                            mem[_20010 + 128] = stor1[idx].field_1024
                                            mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26170 = mem[96]
                                            idx = 0
                                            while idx < _26170:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26553 = mem[(32 * idx) + 128]
                                                if not mem[_20010 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27279 = mem[_20010 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26553)
                                                require ext_code.size(address(_27279))
                                                call address(_27279).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26553)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26170 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20231 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_20010] = _20231
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26171 = mem[96]
                                                idx = 0
                                                while idx < _26171:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26555 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27283 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26555)
                                                    require ext_code.size(address(_27283))
                                                    call address(_27283).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26555)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26171 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20231 + 32] = stor1[idx].field_0
                                                s = _20231 + 32
                                                t = sha3(mem[0])
                                                while _20231 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_20010] = _20231
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31997 = mem[96]
                                                idx = 0
                                                while idx < _31997:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32489 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33375 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32489)
                                                    require ext_code.size(address(_33375))
                                                    call address(_33375).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32489)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31997 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20272 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20272] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_20010] = _20272
                                            mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_20010 + 64] = stor1[idx].field_512
                                            mem[_20010 + 96] = address(stor1[idx].field_768)
                                            mem[_20010 + 128] = stor1[idx].field_1024
                                            mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26172 = mem[96]
                                            idx = 0
                                            while idx < _26172:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26556 = mem[(32 * idx) + 128]
                                                if not mem[_20010 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27286 = mem[_20010 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26556)
                                                require ext_code.size(address(_27286))
                                                call address(_27286).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26556)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26172 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20272 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_20010] = _20272
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26173 = mem[96]
                                                idx = 0
                                                while idx < _26173:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26558 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27290 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26558)
                                                    require ext_code.size(address(_27290))
                                                    call address(_27290).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26558)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26173 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20272 + 32] = stor1[idx].field_0
                                                s = _20272 + 32
                                                t = sha3(mem[0])
                                                while _20272 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_20010] = _20272
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31998 = mem[96]
                                                idx = 0
                                                while idx < _31998:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32490 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33378 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32490)
                                                    require ext_code.size(address(_33378))
                                                    call address(_33378).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32490)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31998 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_20010] = _20272
                                            mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_20010 + 64] = stor1[idx].field_512
                                            mem[_20010 + 96] = address(stor1[idx].field_768)
                                            mem[_20010 + 128] = stor1[idx].field_1024
                                            mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26174 = mem[96]
                                            idx = 0
                                            while idx < _26174:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26559 = mem[(32 * idx) + 128]
                                                if not mem[_20010 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27293 = mem[_20010 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26559)
                                                require ext_code.size(address(_27293))
                                                call address(_27293).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26559)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26174 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20272 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_20010] = _20272
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26175 = mem[96]
                                                idx = 0
                                                while idx < _26175:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26561 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27297 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26561)
                                                    require ext_code.size(address(_27297))
                                                    call address(_27297).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26561)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26175 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20272 + 32] = stor1[idx].field_0
                                                s = _20272 + 32
                                                t = sha3(mem[0])
                                                while _20272 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_20010] = _20272
                                                mem[_20010 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20010 + 64] = stor1[idx].field_512
                                                mem[_20010 + 96] = address(stor1[idx].field_768)
                                                mem[_20010 + 128] = stor1[idx].field_1024
                                                mem[_20010 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31999 = mem[96]
                                                idx = 0
                                                while idx < _31999:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32491 = mem[(32 * idx) + 128]
                                                    if not mem[_20010 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33381 = mem[_20010 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32491)
                                                    require ext_code.size(address(_33381))
                                                    call address(_33381).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32491)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31999 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_19569 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _19569 + stor1[idx].field_1 % 128 - mem[64]]) != _19561:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _27866 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _28254 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_28254] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27866] = _28254
                                            mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27866 + 64] = stor1[idx].field_512
                                            mem[_27866 + 96] = address(stor1[idx].field_768)
                                            mem[_27866 + 128] = stor1[idx].field_1024
                                            mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31988 = mem[96]
                                            idx = 0
                                            while idx < _31988:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32476 = mem[(32 * idx) + 128]
                                                if not mem[_27866 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33344 = mem[_27866 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32476)
                                                require ext_code.size(address(_33344))
                                                call address(_33344).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32476)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31988 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28254 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27866] = _28254
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31989 = mem[96]
                                                idx = 0
                                                while idx < _31989:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32478 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33348 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32478)
                                                    require ext_code.size(address(_33348))
                                                    call address(_33348).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32478)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31989 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28254 + 32] = stor1[idx].field_0
                                                s = _28254 + 32
                                                t = sha3(mem[0])
                                                while _28254 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27866] = _28254
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35404 = mem[96]
                                                idx = 0
                                                while idx < _35404:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35620 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35972 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35620)
                                                    require ext_code.size(address(_35972))
                                                    call address(_35972).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35620)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35404 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27866] = _28254
                                            mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27866 + 64] = stor1[idx].field_512
                                            mem[_27866 + 96] = address(stor1[idx].field_768)
                                            mem[_27866 + 128] = stor1[idx].field_1024
                                            mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31990 = mem[96]
                                            idx = 0
                                            while idx < _31990:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32479 = mem[(32 * idx) + 128]
                                                if not mem[_27866 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33351 = mem[_27866 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32479)
                                                require ext_code.size(address(_33351))
                                                call address(_33351).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32479)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31990 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28254 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27866] = _28254
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31991 = mem[96]
                                                idx = 0
                                                while idx < _31991:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32481 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33355 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32481)
                                                    require ext_code.size(address(_33355))
                                                    call address(_33355).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32481)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31991 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28254 + 32] = stor1[idx].field_0
                                                s = _28254 + 32
                                                t = sha3(mem[0])
                                                while _28254 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27866] = _28254
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35405 = mem[96]
                                                idx = 0
                                                while idx < _35405:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35621 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35975 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35621)
                                                    require ext_code.size(address(_35975))
                                                    call address(_35975).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35621)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35405 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _28364 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_28364] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_27866] = _28364
                                            mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27866 + 64] = stor1[idx].field_512
                                            mem[_27866 + 96] = address(stor1[idx].field_768)
                                            mem[_27866 + 128] = stor1[idx].field_1024
                                            mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31992 = mem[96]
                                            idx = 0
                                            while idx < _31992:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32482 = mem[(32 * idx) + 128]
                                                if not mem[_27866 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33358 = mem[_27866 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32482)
                                                require ext_code.size(address(_33358))
                                                call address(_33358).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32482)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31992 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_28364 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27866] = _28364
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31993 = mem[96]
                                                idx = 0
                                                while idx < _31993:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32484 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33362 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32484)
                                                    require ext_code.size(address(_33362))
                                                    call address(_33362).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32484)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31993 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28364 + 32] = stor1[idx].field_0
                                                s = _28364 + 32
                                                t = sha3(mem[0])
                                                while _28364 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27866] = _28364
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35406 = mem[96]
                                                idx = 0
                                                while idx < _35406:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35622 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35978 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35622)
                                                    require ext_code.size(address(_35978))
                                                    call address(_35978).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35622)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35406 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_27866] = _28364
                                            mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_27866 + 64] = stor1[idx].field_512
                                            mem[_27866 + 96] = address(stor1[idx].field_768)
                                            mem[_27866 + 128] = stor1[idx].field_1024
                                            mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _31994 = mem[96]
                                            idx = 0
                                            while idx < _31994:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32485 = mem[(32 * idx) + 128]
                                                if not mem[_27866 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33365 = mem[_27866 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32485)
                                                require ext_code.size(address(_33365))
                                                call address(_33365).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32485)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _31994 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_28364 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_27866] = _28364
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _31995 = mem[96]
                                                idx = 0
                                                while idx < _31995:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32487 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33369 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32487)
                                                    require ext_code.size(address(_33369))
                                                    call address(_33369).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32487)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _31995 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_28364 + 32] = stor1[idx].field_0
                                                s = _28364 + 32
                                                t = sha3(mem[0])
                                                while _28364 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_27866] = _28364
                                                mem[_27866 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27866 + 64] = stor1[idx].field_512
                                                mem[_27866 + 96] = address(stor1[idx].field_768)
                                                mem[_27866 + 128] = stor1[idx].field_1024
                                                mem[_27866 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35407 = mem[96]
                                                idx = 0
                                                while idx < _35407:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35623 = mem[(32 * idx) + 128]
                                                    if not mem[_27866 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35981 = mem[_27866 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35623)
                                                    require ext_code.size(address(_35981))
                                                    call address(_35981).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35623)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35407 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _19577 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    _19586 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                    mem[_19586] = uint255(stor1.field_1536000000000000000001)
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1.field_1536000000000000000001):
                            mem[_19577] = _19586
                            mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26136 = mem[96]
                            idx = 0
                            while idx < _26136:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26502 = mem[(32 * idx) + 128]
                                if not mem[_19577 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _27156 = mem[_19577 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26502)
                                require ext_code.size(address(_27156))
                                call address(_27156).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26502)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26136 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(stor1.field_1536000000000000000001):
                                mem[_19586 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19577] = _19586
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26137 = mem[96]
                                idx = 0
                                while idx < _26137:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26504 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27160 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26504)
                                    require ext_code.size(address(_27160))
                                    call address(_27160).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26504)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26137 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19586 + 32] = stor1[6 * 10^18].field_0
                                idx = _19586 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19586 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19577] = _19586
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31964 = mem[96]
                                idx = 0
                                while idx < _31964:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32448 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33268 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32448)
                                    require ext_code.size(address(_33268))
                                    call address(_33268).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32448)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31964 = mem[96]
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1.field_1536000000000000000001 % 128:
                            mem[_19577] = _19586
                            mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26138 = mem[96]
                            idx = 0
                            while idx < _26138:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26505 = mem[(32 * idx) + 128]
                                if not mem[_19577 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _27163 = mem[_19577 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26505)
                                require ext_code.size(address(_27163))
                                call address(_27163).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26505)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26138 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= stor1.field_1536000000000000000001 % 128:
                                mem[_19586 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19577] = _19586
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26139 = mem[96]
                                idx = 0
                                while idx < _26139:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26507 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27167 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26507)
                                    require ext_code.size(address(_27167))
                                    call address(_27167).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26507)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26139 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19586 + 32] = stor1[6 * 10^18].field_0
                                idx = _19586 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19586 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19577] = _19586
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31965 = mem[96]
                                idx = 0
                                while idx < _31965:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32449 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33271 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32449)
                                    require ext_code.size(address(_33271))
                                    call address(_33271).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32449)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31965 = mem[96]
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    _19591 = mem[64]
                    mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                    mem[_19591] = stor1.field_1536000000000000000001 % 128
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        if not uint255(stor1.field_1536000000000000000001):
                            mem[_19577] = _19591
                            mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26140 = mem[96]
                            idx = 0
                            while idx < _26140:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26508 = mem[(32 * idx) + 128]
                                if not mem[_19577 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _27170 = mem[_19577 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26508)
                                require ext_code.size(address(_27170))
                                call address(_27170).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26508)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26140 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(stor1.field_1536000000000000000001):
                                mem[_19591 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19577] = _19591
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26141 = mem[96]
                                idx = 0
                                while idx < _26141:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26510 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27174 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26510)
                                    require ext_code.size(address(_27174))
                                    call address(_27174).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26510)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26141 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19591 + 32] = stor1[6 * 10^18].field_0
                                idx = _19591 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19591 + uint255(stor1.field_1536000000000000000001) > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19577] = _19591
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31966 = mem[96]
                                idx = 0
                                while idx < _31966:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32450 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33274 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32450)
                                    require ext_code.size(address(_33274))
                                    call address(_33274).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32450)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31966 = mem[96]
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        if not stor1.field_1536000000000000000001 % 128:
                            mem[_19577] = _19591
                            mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                            mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                            mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                            mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                            mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                            if not address(stor1.field_1536000000000000000768):
                                revert with 0, 'FOREST: No NFT address is set'
                            _26142 = mem[96]
                            idx = 0
                            while idx < _26142:
                                if idx >= mem[96]:
                                    revert with 'NH{q', 50
                                _26511 = mem[(32 * idx) + 128]
                                if not mem[_19577 + 108 len 20]:
                                    revert with 0, 'FOREST: No NFT address is set'
                                _27177 = mem[_19577 + 96]
                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = address(_26511)
                                require ext_code.size(address(_27177))
                                call address(_27177).0x40d097c3 with:
                                     gas gas_remaining wei
                                    args address(_26511)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 'NH{q', 17
                                _26142 = mem[96]
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= stor1.field_1536000000000000000001 % 128:
                                mem[_19591 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                mem[_19577] = _19591
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26143 = mem[96]
                                idx = 0
                                while idx < _26143:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26513 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27181 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26513)
                                    require ext_code.size(address(_27181))
                                    call address(_27181).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26513)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26143 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(1) + 6 * 10^18
                                mem[_19591 + 32] = stor1[6 * 10^18].field_0
                                idx = _19591 + 32
                                s = sha3(sha3(1) + 6 * 10^18)
                                while _19591 + stor1.field_1536000000000000000001 % 128 > idx:
                                    mem[idx + 32] = stor1[s].field_0
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[_19577] = _19591
                                mem[_19577 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19577 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19577 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19577 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19577 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _31967 = mem[96]
                                idx = 0
                                while idx < _31967:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32451 = mem[(32 * idx) + 128]
                                    if not mem[_19577 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33277 = mem[_19577 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32451)
                                    require ext_code.size(address(_33277))
                                    call address(_33277).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32451)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _31967 = mem[96]
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _19563 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                        mem[0] = 1
                        _19571 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _19563:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19875 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20125 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20125] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19875] = _20125
                                            mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19875 + 64] = stor1[idx].field_512
                                            mem[_19875 + 96] = address(stor1[idx].field_768)
                                            mem[_19875 + 128] = stor1[idx].field_1024
                                            mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26184 = mem[96]
                                            idx = 0
                                            while idx < _26184:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26576 = mem[(32 * idx) + 128]
                                                if not mem[_19875 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27328 = mem[_19875 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26576)
                                                require ext_code.size(address(_27328))
                                                call address(_27328).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26576)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26184 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20125 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19875] = _20125
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26185 = mem[96]
                                                idx = 0
                                                while idx < _26185:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26578 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27332 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26578)
                                                    require ext_code.size(address(_27332))
                                                    call address(_27332).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26578)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26185 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20125 + 32] = stor1[idx].field_0
                                                s = _20125 + 32
                                                t = sha3(mem[0])
                                                while _20125 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19875] = _20125
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32044 = mem[96]
                                                idx = 0
                                                while idx < _32044:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32556 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33540 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32556)
                                                    require ext_code.size(address(_33540))
                                                    call address(_33540).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32556)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32044 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19875] = _20125
                                            mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19875 + 64] = stor1[idx].field_512
                                            mem[_19875 + 96] = address(stor1[idx].field_768)
                                            mem[_19875 + 128] = stor1[idx].field_1024
                                            mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26186 = mem[96]
                                            idx = 0
                                            while idx < _26186:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26579 = mem[(32 * idx) + 128]
                                                if not mem[_19875 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27335 = mem[_19875 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26579)
                                                require ext_code.size(address(_27335))
                                                call address(_27335).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26579)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26186 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20125 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19875] = _20125
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26187 = mem[96]
                                                idx = 0
                                                while idx < _26187:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26581 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27339 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26581)
                                                    require ext_code.size(address(_27339))
                                                    call address(_27339).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26581)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26187 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20125 + 32] = stor1[idx].field_0
                                                s = _20125 + 32
                                                t = sha3(mem[0])
                                                while _20125 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19875] = _20125
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32045 = mem[96]
                                                idx = 0
                                                while idx < _32045:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32557 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33543 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32557)
                                                    require ext_code.size(address(_33543))
                                                    call address(_33543).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32557)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32045 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20187 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20187] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19875] = _20187
                                            mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19875 + 64] = stor1[idx].field_512
                                            mem[_19875 + 96] = address(stor1[idx].field_768)
                                            mem[_19875 + 128] = stor1[idx].field_1024
                                            mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26188 = mem[96]
                                            idx = 0
                                            while idx < _26188:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26582 = mem[(32 * idx) + 128]
                                                if not mem[_19875 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27342 = mem[_19875 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26582)
                                                require ext_code.size(address(_27342))
                                                call address(_27342).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26582)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26188 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20187 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19875] = _20187
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26189 = mem[96]
                                                idx = 0
                                                while idx < _26189:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26584 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27346 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26584)
                                                    require ext_code.size(address(_27346))
                                                    call address(_27346).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26584)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26189 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20187 + 32] = stor1[idx].field_0
                                                s = _20187 + 32
                                                t = sha3(mem[0])
                                                while _20187 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19875] = _20187
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32046 = mem[96]
                                                idx = 0
                                                while idx < _32046:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32558 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33546 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32558)
                                                    require ext_code.size(address(_33546))
                                                    call address(_33546).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32558)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32046 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19875] = _20187
                                            mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19875 + 64] = stor1[idx].field_512
                                            mem[_19875 + 96] = address(stor1[idx].field_768)
                                            mem[_19875 + 128] = stor1[idx].field_1024
                                            mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26190 = mem[96]
                                            idx = 0
                                            while idx < _26190:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26585 = mem[(32 * idx) + 128]
                                                if not mem[_19875 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27349 = mem[_19875 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26585)
                                                require ext_code.size(address(_27349))
                                                call address(_27349).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26585)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26190 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20187 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19875] = _20187
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26191 = mem[96]
                                                idx = 0
                                                while idx < _26191:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26587 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27353 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26587)
                                                    require ext_code.size(address(_27353))
                                                    call address(_27353).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26587)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26191 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20187 + 32] = stor1[idx].field_0
                                                s = _20187 + 32
                                                t = sha3(mem[0])
                                                while _20187 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19875] = _20187
                                                mem[_19875 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19875 + 64] = stor1[idx].field_512
                                                mem[_19875 + 96] = address(stor1[idx].field_768)
                                                mem[_19875 + 128] = stor1[idx].field_1024
                                                mem[_19875 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32047 = mem[96]
                                                idx = 0
                                                while idx < _32047:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32559 = mem[(32 * idx) + 128]
                                                    if not mem[_19875 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33549 = mem[_19875 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32559)
                                                    require ext_code.size(address(_33549))
                                                    call address(_33549).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32559)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32047 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _19957 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _20190 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_20190] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19957] = _20190
                                                mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19957 + 64] = stor1[idx].field_512
                                                mem[_19957 + 96] = address(stor1[idx].field_768)
                                                mem[_19957 + 128] = stor1[idx].field_1024
                                                mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26192 = mem[96]
                                                idx = 0
                                                while idx < _26192:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26588 = mem[(32 * idx) + 128]
                                                    if not mem[_19957 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27358 = mem[_19957 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26588)
                                                    require ext_code.size(address(_27358))
                                                    call address(_27358).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26588)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26192 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20190 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19957] = _20190
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26193 = mem[96]
                                                    idx = 0
                                                    while idx < _26193:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26590 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27362 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26590)
                                                        require ext_code.size(address(_27362))
                                                        call address(_27362).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26590)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26193 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20190 + 32] = stor1[idx].field_0
                                                    s = _20190 + 32
                                                    t = sha3(mem[0])
                                                    while _20190 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19957] = _20190
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32056 = mem[96]
                                                    idx = 0
                                                    while idx < _32056:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32572 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33580 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32572)
                                                        require ext_code.size(address(_33580))
                                                        call address(_33580).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32572)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32056 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19957] = _20190
                                                mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19957 + 64] = stor1[idx].field_512
                                                mem[_19957 + 96] = address(stor1[idx].field_768)
                                                mem[_19957 + 128] = stor1[idx].field_1024
                                                mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26194 = mem[96]
                                                idx = 0
                                                while idx < _26194:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26591 = mem[(32 * idx) + 128]
                                                    if not mem[_19957 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27365 = mem[_19957 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26591)
                                                    require ext_code.size(address(_27365))
                                                    call address(_27365).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26591)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26194 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20190 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19957] = _20190
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26195 = mem[96]
                                                    idx = 0
                                                    while idx < _26195:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26593 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27369 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26593)
                                                        require ext_code.size(address(_27369))
                                                        call address(_27369).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26593)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26195 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20190 + 32] = stor1[idx].field_0
                                                    s = _20190 + 32
                                                    t = sha3(mem[0])
                                                    while _20190 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19957] = _20190
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32057 = mem[96]
                                                    idx = 0
                                                    while idx < _32057:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32573 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33583 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32573)
                                                        require ext_code.size(address(_33583))
                                                        call address(_33583).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32573)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32057 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _20247 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_20247] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_19957] = _20247
                                                mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19957 + 64] = stor1[idx].field_512
                                                mem[_19957 + 96] = address(stor1[idx].field_768)
                                                mem[_19957 + 128] = stor1[idx].field_1024
                                                mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26196 = mem[96]
                                                idx = 0
                                                while idx < _26196:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26594 = mem[(32 * idx) + 128]
                                                    if not mem[_19957 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27372 = mem[_19957 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26594)
                                                    require ext_code.size(address(_27372))
                                                    call address(_27372).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26594)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26196 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20247 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19957] = _20247
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26197 = mem[96]
                                                    idx = 0
                                                    while idx < _26197:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26596 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27376 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26596)
                                                        require ext_code.size(address(_27376))
                                                        call address(_27376).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26596)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26197 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20247 + 32] = stor1[idx].field_0
                                                    s = _20247 + 32
                                                    t = sha3(mem[0])
                                                    while _20247 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19957] = _20247
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32058 = mem[96]
                                                    idx = 0
                                                    while idx < _32058:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32574 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33586 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32574)
                                                        require ext_code.size(address(_33586))
                                                        call address(_33586).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32574)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32058 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_19957] = _20247
                                                mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19957 + 64] = stor1[idx].field_512
                                                mem[_19957 + 96] = address(stor1[idx].field_768)
                                                mem[_19957 + 128] = stor1[idx].field_1024
                                                mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26198 = mem[96]
                                                idx = 0
                                                while idx < _26198:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26597 = mem[(32 * idx) + 128]
                                                    if not mem[_19957 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27379 = mem[_19957 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26597)
                                                    require ext_code.size(address(_27379))
                                                    call address(_27379).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26597)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26198 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20247 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_19957] = _20247
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26199 = mem[96]
                                                    idx = 0
                                                    while idx < _26199:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26599 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27383 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26599)
                                                        require ext_code.size(address(_27383))
                                                        call address(_27383).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26599)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26199 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20247 + 32] = stor1[idx].field_0
                                                    s = _20247 + 32
                                                    t = sha3(mem[0])
                                                    while _20247 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_19957] = _20247
                                                    mem[_19957 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_19957 + 64] = stor1[idx].field_512
                                                    mem[_19957 + 96] = address(stor1[idx].field_768)
                                                    mem[_19957 + 128] = stor1[idx].field_1024
                                                    mem[_19957 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32059 = mem[96]
                                                    idx = 0
                                                    while idx < _32059:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32575 = mem[(32 * idx) + 128]
                                                        if not mem[_19957 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33589 = mem[_19957 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32575)
                                                        require ext_code.size(address(_33589))
                                                        call address(_33589).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32575)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32059 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_19571 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _19571 + uint255(stor1[idx].field_1) - mem[64]]) != _19563:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _27905 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _28304 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_28304] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27905] = _28304
                                                mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27905 + 64] = stor1[idx].field_512
                                                mem[_27905 + 96] = address(stor1[idx].field_768)
                                                mem[_27905 + 128] = stor1[idx].field_1024
                                                mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32048 = mem[96]
                                                idx = 0
                                                while idx < _32048:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32560 = mem[(32 * idx) + 128]
                                                    if not mem[_27905 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33552 = mem[_27905 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32560)
                                                    require ext_code.size(address(_33552))
                                                    call address(_33552).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32560)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32048 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28304 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27905] = _28304
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32049 = mem[96]
                                                    idx = 0
                                                    while idx < _32049:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32562 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33556 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32562)
                                                        require ext_code.size(address(_33556))
                                                        call address(_33556).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32562)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32049 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28304 + 32] = stor1[idx].field_0
                                                    s = _28304 + 32
                                                    t = sha3(mem[0])
                                                    while _28304 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27905] = _28304
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35444 = mem[96]
                                                    idx = 0
                                                    while idx < _35444:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35668 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36100 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35668)
                                                        require ext_code.size(address(_36100))
                                                        call address(_36100).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35668)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35444 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27905] = _28304
                                                mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27905 + 64] = stor1[idx].field_512
                                                mem[_27905 + 96] = address(stor1[idx].field_768)
                                                mem[_27905 + 128] = stor1[idx].field_1024
                                                mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32050 = mem[96]
                                                idx = 0
                                                while idx < _32050:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32563 = mem[(32 * idx) + 128]
                                                    if not mem[_27905 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33559 = mem[_27905 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32563)
                                                    require ext_code.size(address(_33559))
                                                    call address(_33559).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32563)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32050 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28304 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27905] = _28304
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32051 = mem[96]
                                                    idx = 0
                                                    while idx < _32051:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32565 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33563 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32565)
                                                        require ext_code.size(address(_33563))
                                                        call address(_33563).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32565)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32051 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28304 + 32] = stor1[idx].field_0
                                                    s = _28304 + 32
                                                    t = sha3(mem[0])
                                                    while _28304 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27905] = _28304
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35445 = mem[96]
                                                    idx = 0
                                                    while idx < _35445:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35669 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36103 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35669)
                                                        require ext_code.size(address(_36103))
                                                        call address(_36103).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35669)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35445 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _28370 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_28370] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27905] = _28370
                                                mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27905 + 64] = stor1[idx].field_512
                                                mem[_27905 + 96] = address(stor1[idx].field_768)
                                                mem[_27905 + 128] = stor1[idx].field_1024
                                                mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32052 = mem[96]
                                                idx = 0
                                                while idx < _32052:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32566 = mem[(32 * idx) + 128]
                                                    if not mem[_27905 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33566 = mem[_27905 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32566)
                                                    require ext_code.size(address(_33566))
                                                    call address(_33566).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32566)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32052 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28370 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27905] = _28370
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32053 = mem[96]
                                                    idx = 0
                                                    while idx < _32053:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32568 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33570 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32568)
                                                        require ext_code.size(address(_33570))
                                                        call address(_33570).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32568)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32053 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28370 + 32] = stor1[idx].field_0
                                                    s = _28370 + 32
                                                    t = sha3(mem[0])
                                                    while _28370 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27905] = _28370
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35446 = mem[96]
                                                    idx = 0
                                                    while idx < _35446:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35670 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36106 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35670)
                                                        require ext_code.size(address(_36106))
                                                        call address(_36106).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35670)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35446 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27905] = _28370
                                                mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27905 + 64] = stor1[idx].field_512
                                                mem[_27905 + 96] = address(stor1[idx].field_768)
                                                mem[_27905 + 128] = stor1[idx].field_1024
                                                mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32054 = mem[96]
                                                idx = 0
                                                while idx < _32054:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32569 = mem[(32 * idx) + 128]
                                                    if not mem[_27905 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33573 = mem[_27905 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32569)
                                                    require ext_code.size(address(_33573))
                                                    call address(_33573).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32569)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32054 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28370 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27905] = _28370
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32055 = mem[96]
                                                    idx = 0
                                                    while idx < _32055:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32571 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33577 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32571)
                                                        require ext_code.size(address(_33577))
                                                        call address(_33577).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32571)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32055 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28370 + 32] = stor1[idx].field_0
                                                    s = _28370 + 32
                                                    t = sha3(mem[0])
                                                    while _28370 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27905] = _28370
                                                    mem[_27905 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27905 + 64] = stor1[idx].field_512
                                                    mem[_27905 + 96] = address(stor1[idx].field_768)
                                                    mem[_27905 + 128] = stor1[idx].field_1024
                                                    mem[_27905 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35447 = mem[96]
                                                    idx = 0
                                                    while idx < _35447:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35671 = mem[(32 * idx) + 128]
                                                        if not mem[_27905 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36109 = mem[_27905 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35671)
                                                        require ext_code.size(address(_36109))
                                                        call address(_36109).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35671)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35447 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _19563:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _19959 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _20191 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_20191] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19959] = _20191
                                            mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19959 + 64] = stor1[idx].field_512
                                            mem[_19959 + 96] = address(stor1[idx].field_768)
                                            mem[_19959 + 128] = stor1[idx].field_1024
                                            mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26200 = mem[96]
                                            idx = 0
                                            while idx < _26200:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26600 = mem[(32 * idx) + 128]
                                                if not mem[_19959 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27386 = mem[_19959 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26600)
                                                require ext_code.size(address(_27386))
                                                call address(_27386).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26600)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26200 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20191 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19959] = _20191
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26201 = mem[96]
                                                idx = 0
                                                while idx < _26201:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26602 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27390 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26602)
                                                    require ext_code.size(address(_27390))
                                                    call address(_27390).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26602)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26201 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20191 + 32] = stor1[idx].field_0
                                                s = _20191 + 32
                                                t = sha3(mem[0])
                                                while _20191 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19959] = _20191
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32060 = mem[96]
                                                idx = 0
                                                while idx < _32060:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32576 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33592 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32576)
                                                    require ext_code.size(address(_33592))
                                                    call address(_33592).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32576)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32060 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19959] = _20191
                                            mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19959 + 64] = stor1[idx].field_512
                                            mem[_19959 + 96] = address(stor1[idx].field_768)
                                            mem[_19959 + 128] = stor1[idx].field_1024
                                            mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26202 = mem[96]
                                            idx = 0
                                            while idx < _26202:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26603 = mem[(32 * idx) + 128]
                                                if not mem[_19959 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27393 = mem[_19959 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26603)
                                                require ext_code.size(address(_27393))
                                                call address(_27393).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26603)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26202 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20191 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19959] = _20191
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26203 = mem[96]
                                                idx = 0
                                                while idx < _26203:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26605 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27397 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26605)
                                                    require ext_code.size(address(_27397))
                                                    call address(_27397).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26605)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26203 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20191 + 32] = stor1[idx].field_0
                                                s = _20191 + 32
                                                t = sha3(mem[0])
                                                while _20191 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19959] = _20191
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32061 = mem[96]
                                                idx = 0
                                                while idx < _32061:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32577 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33595 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32577)
                                                    require ext_code.size(address(_33595))
                                                    call address(_33595).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32577)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32061 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _20248 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_20248] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_19959] = _20248
                                            mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19959 + 64] = stor1[idx].field_512
                                            mem[_19959 + 96] = address(stor1[idx].field_768)
                                            mem[_19959 + 128] = stor1[idx].field_1024
                                            mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26204 = mem[96]
                                            idx = 0
                                            while idx < _26204:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26606 = mem[(32 * idx) + 128]
                                                if not mem[_19959 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27400 = mem[_19959 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26606)
                                                require ext_code.size(address(_27400))
                                                call address(_27400).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26606)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26204 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_20248 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19959] = _20248
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26205 = mem[96]
                                                idx = 0
                                                while idx < _26205:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26608 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27404 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26608)
                                                    require ext_code.size(address(_27404))
                                                    call address(_27404).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26608)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26205 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20248 + 32] = stor1[idx].field_0
                                                s = _20248 + 32
                                                t = sha3(mem[0])
                                                while _20248 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19959] = _20248
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32062 = mem[96]
                                                idx = 0
                                                while idx < _32062:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32578 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33598 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32578)
                                                    require ext_code.size(address(_33598))
                                                    call address(_33598).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32578)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32062 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_19959] = _20248
                                            mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_19959 + 64] = stor1[idx].field_512
                                            mem[_19959 + 96] = address(stor1[idx].field_768)
                                            mem[_19959 + 128] = stor1[idx].field_1024
                                            mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _26206 = mem[96]
                                            idx = 0
                                            while idx < _26206:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _26609 = mem[(32 * idx) + 128]
                                                if not mem[_19959 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _27407 = mem[_19959 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_26609)
                                                require ext_code.size(address(_27407))
                                                call address(_27407).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_26609)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _26206 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_20248 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_19959] = _20248
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26207 = mem[96]
                                                idx = 0
                                                while idx < _26207:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26611 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27411 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26611)
                                                    require ext_code.size(address(_27411))
                                                    call address(_27411).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26611)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26207 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_20248 + 32] = stor1[idx].field_0
                                                s = _20248 + 32
                                                t = sha3(mem[0])
                                                while _20248 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_19959] = _20248
                                                mem[_19959 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_19959 + 64] = stor1[idx].field_512
                                                mem[_19959 + 96] = address(stor1[idx].field_768)
                                                mem[_19959 + 128] = stor1[idx].field_1024
                                                mem[_19959 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32063 = mem[96]
                                                idx = 0
                                                while idx < _32063:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32579 = mem[(32 * idx) + 128]
                                                    if not mem[_19959 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33601 = mem[_19959 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32579)
                                                    require ext_code.size(address(_33601))
                                                    call address(_33601).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32579)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32063 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _20027 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _20251 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_20251] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_20027] = _20251
                                                mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20027 + 64] = stor1[idx].field_512
                                                mem[_20027 + 96] = address(stor1[idx].field_768)
                                                mem[_20027 + 128] = stor1[idx].field_1024
                                                mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26208 = mem[96]
                                                idx = 0
                                                while idx < _26208:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26612 = mem[(32 * idx) + 128]
                                                    if not mem[_20027 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27416 = mem[_20027 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26612)
                                                    require ext_code.size(address(_27416))
                                                    call address(_27416).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26612)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26208 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20251 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_20027] = _20251
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26209 = mem[96]
                                                    idx = 0
                                                    while idx < _26209:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26614 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27420 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26614)
                                                        require ext_code.size(address(_27420))
                                                        call address(_27420).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26614)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26209 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20251 + 32] = stor1[idx].field_0
                                                    s = _20251 + 32
                                                    t = sha3(mem[0])
                                                    while _20251 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_20027] = _20251
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32072 = mem[96]
                                                    idx = 0
                                                    while idx < _32072:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32592 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33632 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32592)
                                                        require ext_code.size(address(_33632))
                                                        call address(_33632).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32592)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32072 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_20027] = _20251
                                                mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20027 + 64] = stor1[idx].field_512
                                                mem[_20027 + 96] = address(stor1[idx].field_768)
                                                mem[_20027 + 128] = stor1[idx].field_1024
                                                mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26210 = mem[96]
                                                idx = 0
                                                while idx < _26210:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26615 = mem[(32 * idx) + 128]
                                                    if not mem[_20027 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27423 = mem[_20027 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26615)
                                                    require ext_code.size(address(_27423))
                                                    call address(_27423).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26615)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26210 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20251 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_20027] = _20251
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26211 = mem[96]
                                                    idx = 0
                                                    while idx < _26211:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26617 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27427 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26617)
                                                        require ext_code.size(address(_27427))
                                                        call address(_27427).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26617)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26211 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20251 + 32] = stor1[idx].field_0
                                                    s = _20251 + 32
                                                    t = sha3(mem[0])
                                                    while _20251 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_20027] = _20251
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32073 = mem[96]
                                                    idx = 0
                                                    while idx < _32073:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32593 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33635 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32593)
                                                        require ext_code.size(address(_33635))
                                                        call address(_33635).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32593)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32073 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _20287 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_20287] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_20027] = _20287
                                                mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20027 + 64] = stor1[idx].field_512
                                                mem[_20027 + 96] = address(stor1[idx].field_768)
                                                mem[_20027 + 128] = stor1[idx].field_1024
                                                mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26212 = mem[96]
                                                idx = 0
                                                while idx < _26212:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26618 = mem[(32 * idx) + 128]
                                                    if not mem[_20027 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27430 = mem[_20027 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26618)
                                                    require ext_code.size(address(_27430))
                                                    call address(_27430).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26618)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26212 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_20287 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_20027] = _20287
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26213 = mem[96]
                                                    idx = 0
                                                    while idx < _26213:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26620 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27434 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26620)
                                                        require ext_code.size(address(_27434))
                                                        call address(_27434).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26620)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26213 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20287 + 32] = stor1[idx].field_0
                                                    s = _20287 + 32
                                                    t = sha3(mem[0])
                                                    while _20287 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_20027] = _20287
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32074 = mem[96]
                                                    idx = 0
                                                    while idx < _32074:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32594 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33638 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32594)
                                                        require ext_code.size(address(_33638))
                                                        call address(_33638).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32594)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32074 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_20027] = _20287
                                                mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_20027 + 64] = stor1[idx].field_512
                                                mem[_20027 + 96] = address(stor1[idx].field_768)
                                                mem[_20027 + 128] = stor1[idx].field_1024
                                                mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _26214 = mem[96]
                                                idx = 0
                                                while idx < _26214:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _26621 = mem[(32 * idx) + 128]
                                                    if not mem[_20027 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _27437 = mem[_20027 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_26621)
                                                    require ext_code.size(address(_27437))
                                                    call address(_27437).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_26621)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _26214 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_20287 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_20027] = _20287
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _26215 = mem[96]
                                                    idx = 0
                                                    while idx < _26215:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _26623 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _27441 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_26623)
                                                        require ext_code.size(address(_27441))
                                                        call address(_27441).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_26623)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _26215 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_20287 + 32] = stor1[idx].field_0
                                                    s = _20287 + 32
                                                    t = sha3(mem[0])
                                                    while _20287 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_20027] = _20287
                                                    mem[_20027 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_20027 + 64] = stor1[idx].field_512
                                                    mem[_20027 + 96] = address(stor1[idx].field_768)
                                                    mem[_20027 + 128] = stor1[idx].field_1024
                                                    mem[_20027 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32075 = mem[96]
                                                    idx = 0
                                                    while idx < _32075:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32595 = mem[(32 * idx) + 128]
                                                        if not mem[_20027 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33641 = mem[_20027 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32595)
                                                        require ext_code.size(address(_33641))
                                                        call address(_33641).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32595)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32075 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_19571 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _19571 + stor1[idx].field_1 % 128 - mem[64]]) != _19563:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _27931 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _28337 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_28337] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27931] = _28337
                                                mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27931 + 64] = stor1[idx].field_512
                                                mem[_27931 + 96] = address(stor1[idx].field_768)
                                                mem[_27931 + 128] = stor1[idx].field_1024
                                                mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32064 = mem[96]
                                                idx = 0
                                                while idx < _32064:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32580 = mem[(32 * idx) + 128]
                                                    if not mem[_27931 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33604 = mem[_27931 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32580)
                                                    require ext_code.size(address(_33604))
                                                    call address(_33604).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32580)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32064 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28337 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27931] = _28337
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32065 = mem[96]
                                                    idx = 0
                                                    while idx < _32065:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32582 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33608 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32582)
                                                        require ext_code.size(address(_33608))
                                                        call address(_33608).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32582)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32065 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28337 + 32] = stor1[idx].field_0
                                                    s = _28337 + 32
                                                    t = sha3(mem[0])
                                                    while _28337 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27931] = _28337
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35448 = mem[96]
                                                    idx = 0
                                                    while idx < _35448:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35672 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36112 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35672)
                                                        require ext_code.size(address(_36112))
                                                        call address(_36112).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35672)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35448 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27931] = _28337
                                                mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27931 + 64] = stor1[idx].field_512
                                                mem[_27931 + 96] = address(stor1[idx].field_768)
                                                mem[_27931 + 128] = stor1[idx].field_1024
                                                mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32066 = mem[96]
                                                idx = 0
                                                while idx < _32066:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32583 = mem[(32 * idx) + 128]
                                                    if not mem[_27931 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33611 = mem[_27931 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32583)
                                                    require ext_code.size(address(_33611))
                                                    call address(_33611).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32583)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32066 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28337 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27931] = _28337
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32067 = mem[96]
                                                    idx = 0
                                                    while idx < _32067:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32585 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33615 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32585)
                                                        require ext_code.size(address(_33615))
                                                        call address(_33615).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32585)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32067 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28337 + 32] = stor1[idx].field_0
                                                    s = _28337 + 32
                                                    t = sha3(mem[0])
                                                    while _28337 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27931] = _28337
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35449 = mem[96]
                                                    idx = 0
                                                    while idx < _35449:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35673 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36115 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35673)
                                                        require ext_code.size(address(_36115))
                                                        call address(_36115).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35673)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35449 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _28371 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_28371] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_27931] = _28371
                                                mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27931 + 64] = stor1[idx].field_512
                                                mem[_27931 + 96] = address(stor1[idx].field_768)
                                                mem[_27931 + 128] = stor1[idx].field_1024
                                                mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32068 = mem[96]
                                                idx = 0
                                                while idx < _32068:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32586 = mem[(32 * idx) + 128]
                                                    if not mem[_27931 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33618 = mem[_27931 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32586)
                                                    require ext_code.size(address(_33618))
                                                    call address(_33618).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32586)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32068 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_28371 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27931] = _28371
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32069 = mem[96]
                                                    idx = 0
                                                    while idx < _32069:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32588 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33622 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32588)
                                                        require ext_code.size(address(_33622))
                                                        call address(_33622).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32588)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32069 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28371 + 32] = stor1[idx].field_0
                                                    s = _28371 + 32
                                                    t = sha3(mem[0])
                                                    while _28371 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27931] = _28371
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35450 = mem[96]
                                                    idx = 0
                                                    while idx < _35450:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35674 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36118 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35674)
                                                        require ext_code.size(address(_36118))
                                                        call address(_36118).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35674)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35450 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_27931] = _28371
                                                mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_27931 + 64] = stor1[idx].field_512
                                                mem[_27931 + 96] = address(stor1[idx].field_768)
                                                mem[_27931 + 128] = stor1[idx].field_1024
                                                mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32070 = mem[96]
                                                idx = 0
                                                while idx < _32070:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32589 = mem[(32 * idx) + 128]
                                                    if not mem[_27931 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33625 = mem[_27931 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32589)
                                                    require ext_code.size(address(_33625))
                                                    call address(_33625).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32589)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32070 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_28371 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_27931] = _28371
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32071 = mem[96]
                                                    idx = 0
                                                    while idx < _32071:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32591 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33629 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32591)
                                                        require ext_code.size(address(_33629))
                                                        call address(_33629).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32591)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32071 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_28371 + 32] = stor1[idx].field_0
                                                    s = _28371 + 32
                                                    t = sha3(mem[0])
                                                    while _28371 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_27931] = _28371
                                                    mem[_27931 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_27931 + 64] = stor1[idx].field_512
                                                    mem[_27931 + 96] = address(stor1[idx].field_768)
                                                    mem[_27931 + 128] = stor1[idx].field_1024
                                                    mem[_27931 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35451 = mem[96]
                                                    idx = 0
                                                    while idx < _35451:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35675 = mem[(32 * idx) + 128]
                                                        if not mem[_27931 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36121 = mem[_27931 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35675)
                                                        require ext_code.size(address(_36121))
                                                        call address(_36121).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35675)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35451 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _19579 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _19587 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                        mem[_19587] = uint255(stor1.field_1536000000000000000001)
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_19579] = _19587
                                mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26176 = mem[96]
                                idx = 0
                                while idx < _26176:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26564 = mem[(32 * idx) + 128]
                                    if not mem[_19579 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27300 = mem[_19579 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26564)
                                    require ext_code.size(address(_27300))
                                    call address(_27300).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26564)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26176 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_19587 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19579] = _19587
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26177 = mem[96]
                                    idx = 0
                                    while idx < _26177:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26566 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27304 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26566)
                                        require ext_code.size(address(_27304))
                                        call address(_27304).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26566)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26177 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19587 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19587 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19587 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19579] = _19587
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32040 = mem[96]
                                    idx = 0
                                    while idx < _32040:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32552 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33528 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32552)
                                        require ext_code.size(address(_33528))
                                        call address(_33528).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32552)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32040 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_19579] = _19587
                                mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26178 = mem[96]
                                idx = 0
                                while idx < _26178:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26567 = mem[(32 * idx) + 128]
                                    if not mem[_19579 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27307 = mem[_19579 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26567)
                                    require ext_code.size(address(_27307))
                                    call address(_27307).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26567)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26178 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_19587 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19579] = _19587
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26179 = mem[96]
                                    idx = 0
                                    while idx < _26179:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26569 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27311 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26569)
                                        require ext_code.size(address(_27311))
                                        call address(_27311).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26569)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26179 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19587 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19587 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19587 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19579] = _19587
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32041 = mem[96]
                                    idx = 0
                                    while idx < _32041:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32553 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33531 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32553)
                                        require ext_code.size(address(_33531))
                                        call address(_33531).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32553)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32041 = mem[96]
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _19593 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                        mem[_19593] = stor1.field_1536000000000000000001 % 128
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_19579] = _19593
                                mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26180 = mem[96]
                                idx = 0
                                while idx < _26180:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26570 = mem[(32 * idx) + 128]
                                    if not mem[_19579 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27314 = mem[_19579 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26570)
                                    require ext_code.size(address(_27314))
                                    call address(_27314).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26570)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26180 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_19593 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19579] = _19593
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26181 = mem[96]
                                    idx = 0
                                    while idx < _26181:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26572 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27318 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26572)
                                        require ext_code.size(address(_27318))
                                        call address(_27318).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26572)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26181 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19593 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19593 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19593 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19579] = _19593
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32042 = mem[96]
                                    idx = 0
                                    while idx < _32042:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32554 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33534 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32554)
                                        require ext_code.size(address(_33534))
                                        call address(_33534).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32554)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32042 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_19579] = _19593
                                mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _26182 = mem[96]
                                idx = 0
                                while idx < _26182:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _26573 = mem[(32 * idx) + 128]
                                    if not mem[_19579 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _27321 = mem[_19579 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_26573)
                                    require ext_code.size(address(_27321))
                                    call address(_27321).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_26573)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _26182 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_19593 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_19579] = _19593
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _26183 = mem[96]
                                    idx = 0
                                    while idx < _26183:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _26575 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _27325 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_26575)
                                        require ext_code.size(address(_27325))
                                        call address(_27325).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_26575)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _26183 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_19593 + 32] = stor1[6 * 10^18].field_0
                                    idx = _19593 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _19593 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_19579] = _19593
                                    mem[_19579 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_19579 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_19579 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_19579 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_19579 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32043 = mem[96]
                                    idx = 0
                                    while idx < _32043:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32555 = mem[(32 * idx) + 128]
                                        if not mem[_19579 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33537 = mem[_19579 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32555)
                                        require ext_code.size(address(_33537))
                                        call address(_33537).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32555)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32043 = mem[96]
                                        idx = idx + 1
                                        continue 
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_13035 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _13035 + stor1[idx].field_1 % 128 - mem[64]]) != _13033:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    idx = 0
                    while idx < stor1.length:
                        _26339 = sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]])
                        mem[0] = 1
                        _26563 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _26339:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _28683 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _29073 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_29073] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28683] = _29073
                                            mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28683 + 64] = stor1[idx].field_512
                                            mem[_28683 + 96] = address(stor1[idx].field_768)
                                            mem[_28683 + 128] = stor1[idx].field_1024
                                            mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32008 = mem[96]
                                            idx = 0
                                            while idx < _32008:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32504 = mem[(32 * idx) + 128]
                                                if not mem[_28683 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33412 = mem[_28683 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32504)
                                                require ext_code.size(address(_33412))
                                                call address(_33412).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32504)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32008 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29073 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28683] = _29073
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32009 = mem[96]
                                                idx = 0
                                                while idx < _32009:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32506 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33416 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32506)
                                                    require ext_code.size(address(_33416))
                                                    call address(_33416).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32506)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32009 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29073 + 32] = stor1[idx].field_0
                                                s = _29073 + 32
                                                t = sha3(mem[0])
                                                while _29073 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28683] = _29073
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35412 = mem[96]
                                                idx = 0
                                                while idx < _35412:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35628 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35996 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35628)
                                                    require ext_code.size(address(_35996))
                                                    call address(_35996).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35628)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35412 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28683] = _29073
                                            mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28683 + 64] = stor1[idx].field_512
                                            mem[_28683 + 96] = address(stor1[idx].field_768)
                                            mem[_28683 + 128] = stor1[idx].field_1024
                                            mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32010 = mem[96]
                                            idx = 0
                                            while idx < _32010:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32507 = mem[(32 * idx) + 128]
                                                if not mem[_28683 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33419 = mem[_28683 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32507)
                                                require ext_code.size(address(_33419))
                                                call address(_33419).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32507)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32010 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29073 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28683] = _29073
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32011 = mem[96]
                                                idx = 0
                                                while idx < _32011:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32509 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33423 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32509)
                                                    require ext_code.size(address(_33423))
                                                    call address(_33423).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32509)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32011 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29073 + 32] = stor1[idx].field_0
                                                s = _29073 + 32
                                                t = sha3(mem[0])
                                                while _29073 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28683] = _29073
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35413 = mem[96]
                                                idx = 0
                                                while idx < _35413:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35629 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35999 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35629)
                                                    require ext_code.size(address(_35999))
                                                    call address(_35999).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35629)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35413 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _29203 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_29203] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28683] = _29203
                                            mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28683 + 64] = stor1[idx].field_512
                                            mem[_28683 + 96] = address(stor1[idx].field_768)
                                            mem[_28683 + 128] = stor1[idx].field_1024
                                            mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32012 = mem[96]
                                            idx = 0
                                            while idx < _32012:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32510 = mem[(32 * idx) + 128]
                                                if not mem[_28683 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33426 = mem[_28683 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32510)
                                                require ext_code.size(address(_33426))
                                                call address(_33426).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32510)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32012 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29203 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28683] = _29203
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32013 = mem[96]
                                                idx = 0
                                                while idx < _32013:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32512 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33430 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32512)
                                                    require ext_code.size(address(_33430))
                                                    call address(_33430).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32512)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32013 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29203 + 32] = stor1[idx].field_0
                                                s = _29203 + 32
                                                t = sha3(mem[0])
                                                while _29203 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28683] = _29203
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35414 = mem[96]
                                                idx = 0
                                                while idx < _35414:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35630 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36002 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35630)
                                                    require ext_code.size(address(_36002))
                                                    call address(_36002).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35630)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35414 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28683] = _29203
                                            mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28683 + 64] = stor1[idx].field_512
                                            mem[_28683 + 96] = address(stor1[idx].field_768)
                                            mem[_28683 + 128] = stor1[idx].field_1024
                                            mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32014 = mem[96]
                                            idx = 0
                                            while idx < _32014:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32513 = mem[(32 * idx) + 128]
                                                if not mem[_28683 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33433 = mem[_28683 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32513)
                                                require ext_code.size(address(_33433))
                                                call address(_33433).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32513)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32014 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29203 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28683] = _29203
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32015 = mem[96]
                                                idx = 0
                                                while idx < _32015:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32515 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33437 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32515)
                                                    require ext_code.size(address(_33437))
                                                    call address(_33437).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32515)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32015 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29203 + 32] = stor1[idx].field_0
                                                s = _29203 + 32
                                                t = sha3(mem[0])
                                                while _29203 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28683] = _29203
                                                mem[_28683 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28683 + 64] = stor1[idx].field_512
                                                mem[_28683 + 96] = address(stor1[idx].field_768)
                                                mem[_28683 + 128] = stor1[idx].field_1024
                                                mem[_28683 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35415 = mem[96]
                                                idx = 0
                                                while idx < _35415:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35631 = mem[(32 * idx) + 128]
                                                    if not mem[_28683 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36005 = mem[_28683 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35631)
                                                    require ext_code.size(address(_36005))
                                                    call address(_36005).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35631)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35415 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _28773 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _29206 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_29206] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28773] = _29206
                                                mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28773 + 64] = stor1[idx].field_512
                                                mem[_28773 + 96] = address(stor1[idx].field_768)
                                                mem[_28773 + 128] = stor1[idx].field_1024
                                                mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32016 = mem[96]
                                                idx = 0
                                                while idx < _32016:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32516 = mem[(32 * idx) + 128]
                                                    if not mem[_28773 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33442 = mem[_28773 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32516)
                                                    require ext_code.size(address(_33442))
                                                    call address(_33442).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32516)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32016 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29206 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28773] = _29206
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32017 = mem[96]
                                                    idx = 0
                                                    while idx < _32017:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32518 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33446 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32518)
                                                        require ext_code.size(address(_33446))
                                                        call address(_33446).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32518)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32017 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29206 + 32] = stor1[idx].field_0
                                                    s = _29206 + 32
                                                    t = sha3(mem[0])
                                                    while _29206 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28773] = _29206
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35424 = mem[96]
                                                    idx = 0
                                                    while idx < _35424:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35644 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36036 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35644)
                                                        require ext_code.size(address(_36036))
                                                        call address(_36036).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35644)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35424 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28773] = _29206
                                                mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28773 + 64] = stor1[idx].field_512
                                                mem[_28773 + 96] = address(stor1[idx].field_768)
                                                mem[_28773 + 128] = stor1[idx].field_1024
                                                mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32018 = mem[96]
                                                idx = 0
                                                while idx < _32018:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32519 = mem[(32 * idx) + 128]
                                                    if not mem[_28773 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33449 = mem[_28773 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32519)
                                                    require ext_code.size(address(_33449))
                                                    call address(_33449).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32519)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32018 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29206 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28773] = _29206
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32019 = mem[96]
                                                    idx = 0
                                                    while idx < _32019:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32521 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33453 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32521)
                                                        require ext_code.size(address(_33453))
                                                        call address(_33453).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32521)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32019 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29206 + 32] = stor1[idx].field_0
                                                    s = _29206 + 32
                                                    t = sha3(mem[0])
                                                    while _29206 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28773] = _29206
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35425 = mem[96]
                                                    idx = 0
                                                    while idx < _35425:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35645 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36039 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35645)
                                                        require ext_code.size(address(_36039))
                                                        call address(_36039).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35645)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35425 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _29341 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_29341] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28773] = _29341
                                                mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28773 + 64] = stor1[idx].field_512
                                                mem[_28773 + 96] = address(stor1[idx].field_768)
                                                mem[_28773 + 128] = stor1[idx].field_1024
                                                mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32020 = mem[96]
                                                idx = 0
                                                while idx < _32020:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32522 = mem[(32 * idx) + 128]
                                                    if not mem[_28773 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33456 = mem[_28773 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32522)
                                                    require ext_code.size(address(_33456))
                                                    call address(_33456).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32522)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32020 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29341 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28773] = _29341
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32021 = mem[96]
                                                    idx = 0
                                                    while idx < _32021:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32524 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33460 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32524)
                                                        require ext_code.size(address(_33460))
                                                        call address(_33460).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32524)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32021 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29341 + 32] = stor1[idx].field_0
                                                    s = _29341 + 32
                                                    t = sha3(mem[0])
                                                    while _29341 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28773] = _29341
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35426 = mem[96]
                                                    idx = 0
                                                    while idx < _35426:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35646 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36042 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35646)
                                                        require ext_code.size(address(_36042))
                                                        call address(_36042).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35646)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35426 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28773] = _29341
                                                mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28773 + 64] = stor1[idx].field_512
                                                mem[_28773 + 96] = address(stor1[idx].field_768)
                                                mem[_28773 + 128] = stor1[idx].field_1024
                                                mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32022 = mem[96]
                                                idx = 0
                                                while idx < _32022:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32525 = mem[(32 * idx) + 128]
                                                    if not mem[_28773 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33463 = mem[_28773 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32525)
                                                    require ext_code.size(address(_33463))
                                                    call address(_33463).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32525)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32022 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29341 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28773] = _29341
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32023 = mem[96]
                                                    idx = 0
                                                    while idx < _32023:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32527 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33467 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32527)
                                                        require ext_code.size(address(_33467))
                                                        call address(_33467).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32527)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32023 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29341 + 32] = stor1[idx].field_0
                                                    s = _29341 + 32
                                                    t = sha3(mem[0])
                                                    while _29341 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28773] = _29341
                                                    mem[_28773 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28773 + 64] = stor1[idx].field_512
                                                    mem[_28773 + 96] = address(stor1[idx].field_768)
                                                    mem[_28773 + 128] = stor1[idx].field_1024
                                                    mem[_28773 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35427 = mem[96]
                                                    idx = 0
                                                    while idx < _35427:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35647 = mem[(32 * idx) + 128]
                                                        if not mem[_28773 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36045 = mem[_28773 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35647)
                                                        require ext_code.size(address(_36045))
                                                        call address(_36045).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35647)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35427 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_26563 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _26563 + uint255(stor1[idx].field_1) - mem[64]]) != _26339:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _34021 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _34486 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_34486] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_34021] = _34486
                                                mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34021 + 64] = stor1[idx].field_512
                                                mem[_34021 + 96] = address(stor1[idx].field_768)
                                                mem[_34021 + 128] = stor1[idx].field_1024
                                                mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35416 = mem[96]
                                                idx = 0
                                                while idx < _35416:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35632 = mem[(32 * idx) + 128]
                                                    if not mem[_34021 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36008 = mem[_34021 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35632)
                                                    require ext_code.size(address(_36008))
                                                    call address(_36008).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35632)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35416 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34486 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34021] = _34486
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35417 = mem[96]
                                                    idx = 0
                                                    while idx < _35417:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35634 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36012 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35634)
                                                        require ext_code.size(address(_36012))
                                                        call address(_36012).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35634)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35417 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34486 + 32] = stor1[idx].field_0
                                                    s = _34486 + 32
                                                    t = sha3(mem[0])
                                                    while _34486 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34021] = _34486
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36484 = mem[96]
                                                    idx = 0
                                                    while idx < _36484:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36516 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36564 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36516)
                                                        require ext_code.size(address(_36564))
                                                        call address(_36564).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36516)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36484 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_34021] = _34486
                                                mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34021 + 64] = stor1[idx].field_512
                                                mem[_34021 + 96] = address(stor1[idx].field_768)
                                                mem[_34021 + 128] = stor1[idx].field_1024
                                                mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35418 = mem[96]
                                                idx = 0
                                                while idx < _35418:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35635 = mem[(32 * idx) + 128]
                                                    if not mem[_34021 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36015 = mem[_34021 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35635)
                                                    require ext_code.size(address(_36015))
                                                    call address(_36015).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35635)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35418 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34486 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34021] = _34486
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35419 = mem[96]
                                                    idx = 0
                                                    while idx < _35419:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35637 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36019 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35637)
                                                        require ext_code.size(address(_36019))
                                                        call address(_36019).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35637)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35419 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34486 + 32] = stor1[idx].field_0
                                                    s = _34486 + 32
                                                    t = sha3(mem[0])
                                                    while _34486 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34021] = _34486
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36485 = mem[96]
                                                    idx = 0
                                                    while idx < _36485:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36517 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36567 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36517)
                                                        require ext_code.size(address(_36567))
                                                        call address(_36567).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36517)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36485 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _34610 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_34610] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_34021] = _34610
                                                mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34021 + 64] = stor1[idx].field_512
                                                mem[_34021 + 96] = address(stor1[idx].field_768)
                                                mem[_34021 + 128] = stor1[idx].field_1024
                                                mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35420 = mem[96]
                                                idx = 0
                                                while idx < _35420:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35638 = mem[(32 * idx) + 128]
                                                    if not mem[_34021 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36022 = mem[_34021 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35638)
                                                    require ext_code.size(address(_36022))
                                                    call address(_36022).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35638)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35420 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34610 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34021] = _34610
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35421 = mem[96]
                                                    idx = 0
                                                    while idx < _35421:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35640 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36026 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35640)
                                                        require ext_code.size(address(_36026))
                                                        call address(_36026).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35640)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35421 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34610 + 32] = stor1[idx].field_0
                                                    s = _34610 + 32
                                                    t = sha3(mem[0])
                                                    while _34610 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34021] = _34610
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36486 = mem[96]
                                                    idx = 0
                                                    while idx < _36486:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36518 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36570 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36518)
                                                        require ext_code.size(address(_36570))
                                                        call address(_36570).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36518)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36486 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_34021] = _34610
                                                mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34021 + 64] = stor1[idx].field_512
                                                mem[_34021 + 96] = address(stor1[idx].field_768)
                                                mem[_34021 + 128] = stor1[idx].field_1024
                                                mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35422 = mem[96]
                                                idx = 0
                                                while idx < _35422:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35641 = mem[(32 * idx) + 128]
                                                    if not mem[_34021 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36029 = mem[_34021 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35641)
                                                    require ext_code.size(address(_36029))
                                                    call address(_36029).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35641)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35422 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34610 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34021] = _34610
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35423 = mem[96]
                                                    idx = 0
                                                    while idx < _35423:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35643 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36033 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35643)
                                                        require ext_code.size(address(_36033))
                                                        call address(_36033).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35643)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35423 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34610 + 32] = stor1[idx].field_0
                                                    s = _34610 + 32
                                                    t = sha3(mem[0])
                                                    while _34610 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34021] = _34610
                                                    mem[_34021 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34021 + 64] = stor1[idx].field_512
                                                    mem[_34021 + 96] = address(stor1[idx].field_768)
                                                    mem[_34021 + 128] = stor1[idx].field_1024
                                                    mem[_34021 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36487 = mem[96]
                                                    idx = 0
                                                    while idx < _36487:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36519 = mem[(32 * idx) + 128]
                                                        if not mem[_34021 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36573 = mem[_34021 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36519)
                                                        require ext_code.size(address(_36573))
                                                        call address(_36573).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36519)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36487 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _26339:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _28775 = mem[64]
                                mem[64] = mem[64] + 192
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    _29207 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                    mem[_29207] = uint255(stor1[idx].field_1)
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28775] = _29207
                                            mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28775 + 64] = stor1[idx].field_512
                                            mem[_28775 + 96] = address(stor1[idx].field_768)
                                            mem[_28775 + 128] = stor1[idx].field_1024
                                            mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32024 = mem[96]
                                            idx = 0
                                            while idx < _32024:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32528 = mem[(32 * idx) + 128]
                                                if not mem[_28775 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33470 = mem[_28775 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32528)
                                                require ext_code.size(address(_33470))
                                                call address(_33470).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32528)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32024 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29207 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28775] = _29207
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32025 = mem[96]
                                                idx = 0
                                                while idx < _32025:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32530 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33474 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32530)
                                                    require ext_code.size(address(_33474))
                                                    call address(_33474).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32530)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32025 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29207 + 32] = stor1[idx].field_0
                                                s = _29207 + 32
                                                t = sha3(mem[0])
                                                while _29207 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28775] = _29207
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35428 = mem[96]
                                                idx = 0
                                                while idx < _35428:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35648 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36048 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35648)
                                                    require ext_code.size(address(_36048))
                                                    call address(_36048).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35648)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35428 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28775] = _29207
                                            mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28775 + 64] = stor1[idx].field_512
                                            mem[_28775 + 96] = address(stor1[idx].field_768)
                                            mem[_28775 + 128] = stor1[idx].field_1024
                                            mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32026 = mem[96]
                                            idx = 0
                                            while idx < _32026:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32531 = mem[(32 * idx) + 128]
                                                if not mem[_28775 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33477 = mem[_28775 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32531)
                                                require ext_code.size(address(_33477))
                                                call address(_33477).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32531)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32026 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29207 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28775] = _29207
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32027 = mem[96]
                                                idx = 0
                                                while idx < _32027:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32533 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33481 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32533)
                                                    require ext_code.size(address(_33481))
                                                    call address(_33481).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32533)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32027 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29207 + 32] = stor1[idx].field_0
                                                s = _29207 + 32
                                                t = sha3(mem[0])
                                                while _29207 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28775] = _29207
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35429 = mem[96]
                                                idx = 0
                                                while idx < _35429:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35649 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36051 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35649)
                                                    require ext_code.size(address(_36051))
                                                    call address(_36051).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35649)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35429 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    _29342 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                    mem[_29342] = stor1[idx].field_1 % 128
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not uint255(stor1[idx].field_1):
                                            mem[_28775] = _29342
                                            mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28775 + 64] = stor1[idx].field_512
                                            mem[_28775 + 96] = address(stor1[idx].field_768)
                                            mem[_28775 + 128] = stor1[idx].field_1024
                                            mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32028 = mem[96]
                                            idx = 0
                                            while idx < _32028:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32534 = mem[(32 * idx) + 128]
                                                if not mem[_28775 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33484 = mem[_28775 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32534)
                                                require ext_code.size(address(_33484))
                                                call address(_33484).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32534)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32028 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= uint255(stor1[idx].field_1):
                                                mem[_29342 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28775] = _29342
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32029 = mem[96]
                                                idx = 0
                                                while idx < _32029:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32536 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33488 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32536)
                                                    require ext_code.size(address(_33488))
                                                    call address(_33488).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32536)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32029 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29342 + 32] = stor1[idx].field_0
                                                s = _29342 + 32
                                                t = sha3(mem[0])
                                                while _29342 + uint255(stor1[idx].field_1) > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28775] = _29342
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35430 = mem[96]
                                                idx = 0
                                                while idx < _35430:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35650 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36054 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35650)
                                                    require ext_code.size(address(_36054))
                                                    call address(_36054).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35650)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35430 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not stor1[idx].field_1 % 128:
                                            mem[_28775] = _29342
                                            mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                            mem[_28775 + 64] = stor1[idx].field_512
                                            mem[_28775 + 96] = address(stor1[idx].field_768)
                                            mem[_28775 + 128] = stor1[idx].field_1024
                                            mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                            if not address(stor1[idx].field_768):
                                                revert with 0, 'FOREST: No NFT address is set'
                                            _32030 = mem[96]
                                            idx = 0
                                            while idx < _32030:
                                                if idx >= mem[96]:
                                                    revert with 'NH{q', 50
                                                _32537 = mem[(32 * idx) + 128]
                                                if not mem[_28775 + 108 len 20]:
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _33491 = mem[_28775 + 96]
                                                mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = address(_32537)
                                                require ext_code.size(address(_33491))
                                                call address(_33491).0x40d097c3 with:
                                                     gas gas_remaining wei
                                                    args address(_32537)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                _32030 = mem[96]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 >= stor1[idx].field_1 % 128:
                                                mem[_29342 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                mem[_28775] = _29342
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32031 = mem[96]
                                                idx = 0
                                                while idx < _32031:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32539 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33495 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32539)
                                                    require ext_code.size(address(_33495))
                                                    call address(_33495).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32539)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32031 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                mem[_29342 + 32] = stor1[idx].field_0
                                                s = _29342 + 32
                                                t = sha3(mem[0])
                                                while _29342 + stor1[idx].field_1 % 128 > s:
                                                    mem[s + 32] = stor1[t].field_0
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                mem[_28775] = _29342
                                                mem[_28775 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28775 + 64] = stor1[idx].field_512
                                                mem[_28775 + 96] = address(stor1[idx].field_768)
                                                mem[_28775 + 128] = stor1[idx].field_1024
                                                mem[_28775 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35431 = mem[96]
                                                idx = 0
                                                while idx < _35431:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35651 = mem[(32 * idx) + 128]
                                                    if not mem[_28775 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36057 = mem[_28775 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35651)
                                                    require ext_code.size(address(_36057))
                                                    call address(_36057).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35651)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35431 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[floor32(('cd', 4).length) + 129 len mem[floor32(('cd', 4).length) + 97]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _28871 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _29345 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_29345] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28871] = _29345
                                                mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28871 + 64] = stor1[idx].field_512
                                                mem[_28871 + 96] = address(stor1[idx].field_768)
                                                mem[_28871 + 128] = stor1[idx].field_1024
                                                mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32032 = mem[96]
                                                idx = 0
                                                while idx < _32032:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32540 = mem[(32 * idx) + 128]
                                                    if not mem[_28871 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33500 = mem[_28871 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32540)
                                                    require ext_code.size(address(_33500))
                                                    call address(_33500).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32540)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32032 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29345 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28871] = _29345
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32033 = mem[96]
                                                    idx = 0
                                                    while idx < _32033:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32542 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33504 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32542)
                                                        require ext_code.size(address(_33504))
                                                        call address(_33504).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32542)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32033 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29345 + 32] = stor1[idx].field_0
                                                    s = _29345 + 32
                                                    t = sha3(mem[0])
                                                    while _29345 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28871] = _29345
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35440 = mem[96]
                                                    idx = 0
                                                    while idx < _35440:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35664 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36088 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35664)
                                                        require ext_code.size(address(_36088))
                                                        call address(_36088).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35664)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35440 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28871] = _29345
                                                mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28871 + 64] = stor1[idx].field_512
                                                mem[_28871 + 96] = address(stor1[idx].field_768)
                                                mem[_28871 + 128] = stor1[idx].field_1024
                                                mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32034 = mem[96]
                                                idx = 0
                                                while idx < _32034:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32543 = mem[(32 * idx) + 128]
                                                    if not mem[_28871 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33507 = mem[_28871 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32543)
                                                    require ext_code.size(address(_33507))
                                                    call address(_33507).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32543)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32034 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29345 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28871] = _29345
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32035 = mem[96]
                                                    idx = 0
                                                    while idx < _32035:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32545 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33511 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32545)
                                                        require ext_code.size(address(_33511))
                                                        call address(_33511).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32545)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32035 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29345 + 32] = stor1[idx].field_0
                                                    s = _29345 + 32
                                                    t = sha3(mem[0])
                                                    while _29345 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28871] = _29345
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35441 = mem[96]
                                                    idx = 0
                                                    while idx < _35441:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35665 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36091 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35665)
                                                        require ext_code.size(address(_36091))
                                                        call address(_36091).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35665)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35441 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _29459 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_29459] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_28871] = _29459
                                                mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28871 + 64] = stor1[idx].field_512
                                                mem[_28871 + 96] = address(stor1[idx].field_768)
                                                mem[_28871 + 128] = stor1[idx].field_1024
                                                mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32036 = mem[96]
                                                idx = 0
                                                while idx < _32036:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32546 = mem[(32 * idx) + 128]
                                                    if not mem[_28871 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33514 = mem[_28871 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32546)
                                                    require ext_code.size(address(_33514))
                                                    call address(_33514).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32546)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32036 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_29459 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28871] = _29459
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32037 = mem[96]
                                                    idx = 0
                                                    while idx < _32037:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32548 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33518 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32548)
                                                        require ext_code.size(address(_33518))
                                                        call address(_33518).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32548)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32037 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29459 + 32] = stor1[idx].field_0
                                                    s = _29459 + 32
                                                    t = sha3(mem[0])
                                                    while _29459 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28871] = _29459
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35442 = mem[96]
                                                    idx = 0
                                                    while idx < _35442:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35666 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36094 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35666)
                                                        require ext_code.size(address(_36094))
                                                        call address(_36094).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35666)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35442 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_28871] = _29459
                                                mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_28871 + 64] = stor1[idx].field_512
                                                mem[_28871 + 96] = address(stor1[idx].field_768)
                                                mem[_28871 + 128] = stor1[idx].field_1024
                                                mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _32038 = mem[96]
                                                idx = 0
                                                while idx < _32038:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _32549 = mem[(32 * idx) + 128]
                                                    if not mem[_28871 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _33521 = mem[_28871 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_32549)
                                                    require ext_code.size(address(_33521))
                                                    call address(_33521).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_32549)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _32038 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_29459 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_28871] = _29459
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _32039 = mem[96]
                                                    idx = 0
                                                    while idx < _32039:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _32551 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _33525 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_32551)
                                                        require ext_code.size(address(_33525))
                                                        call address(_33525).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_32551)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _32039 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_29459 + 32] = stor1[idx].field_0
                                                    s = _29459 + 32
                                                    t = sha3(mem[0])
                                                    while _29459 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_28871] = _29459
                                                    mem[_28871 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_28871 + 64] = stor1[idx].field_512
                                                    mem[_28871 + 96] = address(stor1[idx].field_768)
                                                    mem[_28871 + 128] = stor1[idx].field_1024
                                                    mem[_28871 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35443 = mem[96]
                                                    idx = 0
                                                    while idx < _35443:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35667 = mem[(32 * idx) + 128]
                                                        if not mem[_28871 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36097 = mem[_28871 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35667)
                                                        require ext_code.size(address(_36097))
                                                        call address(_36097).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35667)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35443 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_26563 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _26563 + stor1[idx].field_1 % 128 - mem[64]]) != _26339:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _34047 = mem[64]
                                    mem[64] = mem[64] + 192
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        _34519 = mem[64]
                                        mem[64] = mem[64] + ceil32(uint255(stor1[idx].field_1)) + 32
                                        mem[_34519] = uint255(stor1[idx].field_1)
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_34047] = _34519
                                                mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34047 + 64] = stor1[idx].field_512
                                                mem[_34047 + 96] = address(stor1[idx].field_768)
                                                mem[_34047 + 128] = stor1[idx].field_1024
                                                mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35432 = mem[96]
                                                idx = 0
                                                while idx < _35432:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35652 = mem[(32 * idx) + 128]
                                                    if not mem[_34047 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36060 = mem[_34047 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35652)
                                                    require ext_code.size(address(_36060))
                                                    call address(_36060).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35652)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35432 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34519 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34047] = _34519
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35433 = mem[96]
                                                    idx = 0
                                                    while idx < _35433:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35654 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36064 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35654)
                                                        require ext_code.size(address(_36064))
                                                        call address(_36064).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35654)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35433 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34519 + 32] = stor1[idx].field_0
                                                    s = _34519 + 32
                                                    t = sha3(mem[0])
                                                    while _34519 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34047] = _34519
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36488 = mem[96]
                                                    idx = 0
                                                    while idx < _36488:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36520 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36576 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36520)
                                                        require ext_code.size(address(_36576))
                                                        call address(_36576).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36520)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36488 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_34047] = _34519
                                                mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34047 + 64] = stor1[idx].field_512
                                                mem[_34047 + 96] = address(stor1[idx].field_768)
                                                mem[_34047 + 128] = stor1[idx].field_1024
                                                mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35434 = mem[96]
                                                idx = 0
                                                while idx < _35434:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35655 = mem[(32 * idx) + 128]
                                                    if not mem[_34047 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36067 = mem[_34047 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35655)
                                                    require ext_code.size(address(_36067))
                                                    call address(_36067).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35655)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35434 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34519 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34047] = _34519
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35435 = mem[96]
                                                    idx = 0
                                                    while idx < _35435:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35657 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36071 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35657)
                                                        require ext_code.size(address(_36071))
                                                        call address(_36071).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35657)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35435 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34519 + 32] = stor1[idx].field_0
                                                    s = _34519 + 32
                                                    t = sha3(mem[0])
                                                    while _34519 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34047] = _34519
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36489 = mem[96]
                                                    idx = 0
                                                    while idx < _36489:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36521 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36579 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36521)
                                                        require ext_code.size(address(_36579))
                                                        call address(_36579).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36521)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36489 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        _34611 = mem[64]
                                        mem[64] = mem[64] + ceil32(stor1[idx].field_1 % 128) + 32
                                        mem[_34611] = stor1[idx].field_1 % 128
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not uint255(stor1[idx].field_1):
                                                mem[_34047] = _34611
                                                mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34047 + 64] = stor1[idx].field_512
                                                mem[_34047 + 96] = address(stor1[idx].field_768)
                                                mem[_34047 + 128] = stor1[idx].field_1024
                                                mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35436 = mem[96]
                                                idx = 0
                                                while idx < _35436:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35658 = mem[(32 * idx) + 128]
                                                    if not mem[_34047 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36074 = mem[_34047 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35658)
                                                    require ext_code.size(address(_36074))
                                                    call address(_36074).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35658)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35436 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= uint255(stor1[idx].field_1):
                                                    mem[_34611 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34047] = _34611
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35437 = mem[96]
                                                    idx = 0
                                                    while idx < _35437:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35660 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36078 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35660)
                                                        require ext_code.size(address(_36078))
                                                        call address(_36078).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35660)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35437 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34611 + 32] = stor1[idx].field_0
                                                    s = _34611 + 32
                                                    t = sha3(mem[0])
                                                    while _34611 + uint255(stor1[idx].field_1) > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34047] = _34611
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36490 = mem[96]
                                                    idx = 0
                                                    while idx < _36490:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36522 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36582 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36522)
                                                        require ext_code.size(address(_36582))
                                                        call address(_36582).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36522)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36490 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not stor1[idx].field_1 % 128:
                                                mem[_34047] = _34611
                                                mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                mem[_34047 + 64] = stor1[idx].field_512
                                                mem[_34047 + 96] = address(stor1[idx].field_768)
                                                mem[_34047 + 128] = stor1[idx].field_1024
                                                mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                if not address(stor1[idx].field_768):
                                                    revert with 0, 'FOREST: No NFT address is set'
                                                _35438 = mem[96]
                                                idx = 0
                                                while idx < _35438:
                                                    if idx >= mem[96]:
                                                        revert with 'NH{q', 50
                                                    _35661 = mem[(32 * idx) + 128]
                                                    if not mem[_34047 + 108 len 20]:
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36081 = mem[_34047 + 96]
                                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = address(_35661)
                                                    require ext_code.size(address(_36081))
                                                    call address(_36081).0x40d097c3 with:
                                                         gas gas_remaining wei
                                                        args address(_35661)
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    _35438 = mem[96]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 >= stor1[idx].field_1 % 128:
                                                    mem[_34611 + 32] = 256 * Mask(248, 0, stor1[idx].field_8)
                                                    mem[_34047] = _34611
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _35439 = mem[96]
                                                    idx = 0
                                                    while idx < _35439:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _35663 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36085 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_35663)
                                                        require ext_code.size(address(_36085))
                                                        call address(_36085).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_35663)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _35439 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    mem[_34611 + 32] = stor1[idx].field_0
                                                    s = _34611 + 32
                                                    t = sha3(mem[0])
                                                    while _34611 + stor1[idx].field_1 % 128 > s:
                                                        mem[s + 32] = stor1[t].field_0
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    mem[_34047] = _34611
                                                    mem[_34047 + 32] = bool(uint8(stor1[idx].field_256))
                                                    mem[_34047 + 64] = stor1[idx].field_512
                                                    mem[_34047 + 96] = address(stor1[idx].field_768)
                                                    mem[_34047 + 128] = stor1[idx].field_1024
                                                    mem[_34047 + 160] = bool(uint8(stor1[idx].field_1280))
                                                    if not address(stor1[idx].field_768):
                                                        revert with 0, 'FOREST: No NFT address is set'
                                                    _36491 = mem[96]
                                                    idx = 0
                                                    while idx < _36491:
                                                        if idx >= mem[96]:
                                                            revert with 'NH{q', 50
                                                        _36523 = mem[(32 * idx) + 128]
                                                        if not mem[_34047 + 108 len 20]:
                                                            revert with 0, 'FOREST: No NFT address is set'
                                                        _36585 = mem[_34047 + 96]
                                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = address(_36523)
                                                        require ext_code.size(address(_36585))
                                                        call address(_36585).0x40d097c3 with:
                                                             gas gas_remaining wei
                                                            args address(_36523)
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        _36491 = mem[96]
                                                        idx = idx + 1
                                                        continue 
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _26807 = mem[64]
                    mem[64] = mem[64] + 192
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        _27665 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(stor1.field_1536000000000000000001)) + 32
                        mem[_27665] = uint255(stor1.field_1536000000000000000001)
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_26807] = _27665
                                mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _32000 = mem[96]
                                idx = 0
                                while idx < _32000:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32492 = mem[(32 * idx) + 128]
                                    if not mem[_26807 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33384 = mem[_26807 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32492)
                                    require ext_code.size(address(_33384))
                                    call address(_33384).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32492)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _32000 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_27665 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26807] = _27665
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32001 = mem[96]
                                    idx = 0
                                    while idx < _32001:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32494 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33388 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32494)
                                        require ext_code.size(address(_33388))
                                        call address(_33388).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32494)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32001 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27665 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27665 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27665 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26807] = _27665
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35408 = mem[96]
                                    idx = 0
                                    while idx < _35408:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35624 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35984 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35624)
                                        require ext_code.size(address(_35984))
                                        call address(_35984).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35624)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35408 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_26807] = _27665
                                mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _32002 = mem[96]
                                idx = 0
                                while idx < _32002:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32495 = mem[(32 * idx) + 128]
                                    if not mem[_26807 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33391 = mem[_26807 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32495)
                                    require ext_code.size(address(_33391))
                                    call address(_33391).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32495)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _32002 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_27665 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26807] = _27665
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32003 = mem[96]
                                    idx = 0
                                    while idx < _32003:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32497 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33395 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32497)
                                        require ext_code.size(address(_33395))
                                        call address(_33395).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32497)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32003 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27665 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27665 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27665 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26807] = _27665
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35409 = mem[96]
                                    idx = 0
                                    while idx < _35409:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35625 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35987 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35625)
                                        require ext_code.size(address(_35987))
                                        call address(_35987).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35625)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35409 = mem[96]
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        _27879 = mem[64]
                        mem[64] = mem[64] + ceil32(stor1.field_1536000000000000000001 % 128) + 32
                        mem[_27879] = stor1.field_1536000000000000000001 % 128
                        if bool(stor1.field_1536 * 10^18):
                            if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                revert with 'NH{q', 34
                            if not uint255(stor1.field_1536000000000000000001):
                                mem[_26807] = _27879
                                mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _32004 = mem[96]
                                idx = 0
                                while idx < _32004:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32498 = mem[(32 * idx) + 128]
                                    if not mem[_26807 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33398 = mem[_26807 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32498)
                                    require ext_code.size(address(_33398))
                                    call address(_33398).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32498)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _32004 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(stor1.field_1536000000000000000001):
                                    mem[_27879 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26807] = _27879
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32005 = mem[96]
                                    idx = 0
                                    while idx < _32005:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32500 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33402 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32500)
                                        require ext_code.size(address(_33402))
                                        call address(_33402).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32500)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32005 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27879 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27879 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27879 + uint255(stor1.field_1536000000000000000001) > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26807] = _27879
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35410 = mem[96]
                                    idx = 0
                                    while idx < _35410:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35626 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35990 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35626)
                                        require ext_code.size(address(_35990))
                                        call address(_35990).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35626)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35410 = mem[96]
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                revert with 'NH{q', 34
                            if not stor1.field_1536000000000000000001 % 128:
                                mem[_26807] = _27879
                                mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                if not address(stor1.field_1536000000000000000768):
                                    revert with 0, 'FOREST: No NFT address is set'
                                _32006 = mem[96]
                                idx = 0
                                while idx < _32006:
                                    if idx >= mem[96]:
                                        revert with 'NH{q', 50
                                    _32501 = mem[(32 * idx) + 128]
                                    if not mem[_26807 + 108 len 20]:
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _33405 = mem[_26807 + 96]
                                    mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = address(_32501)
                                    require ext_code.size(address(_33405))
                                    call address(_33405).0x40d097c3 with:
                                         gas gas_remaining wei
                                        args address(_32501)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    _32006 = mem[96]
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= stor1.field_1536000000000000000001 % 128:
                                    mem[_27879 + 32] = 256 * Mask(248, 0, stor1.field_1536000000000000000008)
                                    mem[_26807] = _27879
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _32007 = mem[96]
                                    idx = 0
                                    while idx < _32007:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _32503 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _33409 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_32503)
                                        require ext_code.size(address(_33409))
                                        call address(_33409).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_32503)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _32007 = mem[96]
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[0] = sha3(1) + 6 * 10^18
                                    mem[_27879 + 32] = stor1[6 * 10^18].field_0
                                    idx = _27879 + 32
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    while _27879 + stor1.field_1536000000000000000001 % 128 > idx:
                                        mem[idx + 32] = stor1[s].field_0
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[_26807] = _27879
                                    mem[_26807 + 32] = bool(uint8(stor1.field_1536000000000000000256))
                                    mem[_26807 + 64] = uint256(stor1.field_1536000000000000000512)
                                    mem[_26807 + 96] = address(stor1.field_1536000000000000000768)
                                    mem[_26807 + 128] = uint256(stor1.field_1536000000000000001024)
                                    mem[_26807 + 160] = bool(uint8(stor1.field_1536000000000000001280))
                                    if not address(stor1.field_1536000000000000000768):
                                        revert with 0, 'FOREST: No NFT address is set'
                                    _35411 = mem[96]
                                    idx = 0
                                    while idx < _35411:
                                        if idx >= mem[96]:
                                            revert with 'NH{q', 50
                                        _35627 = mem[(32 * idx) + 128]
                                        if not mem[_26807 + 108 len 20]:
                                            revert with 0, 'FOREST: No NFT address is set'
                                        _35993 = mem[_26807 + 96]
                                        mem[mem[64]] = 0x40d097c300000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = address(_35627)
                                        require ext_code.size(address(_35993))
                                        call address(_35993).0x40d097c3 with:
                                             gas gas_remaining wei
                                            args address(_35627)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        _35411 = mem[96]
                                        idx = idx + 1
                                        continue 
    revert with 0, 'FOREST: Target NFT does not exist'
}

function sub_2742fc5b(?) {
    require calldata.size - 4 >= 192
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + 97 > test266151307() or ceil32(ceil32(arg1.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg1.length)) + ceil32(ceil32(arg2.length)) + 98 > test266151307() or ceil32(ceil32(arg2.length)) + 98 < 97:
        revert with 'NH{q', 65
    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(ceil32(arg2.length)) + 98
    mem[ceil32(ceil32(arg1.length)) + 97] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[ceil32(ceil32(arg1.length)) + 129 len arg2.length] = arg2[all]
    mem[ceil32(ceil32(arg1.length)) + arg2.length + 129] = 0
    require arg3 == bool(arg3)
    require arg4 == arg4
    require arg5 == address(arg5)
    require arg6 == bool(arg6)
    if owner != msg.sender:
        revert with 0, 'FOREST: Caller is not the owner'
    idx = 0
    while idx < stor1.length:
        _13592 = sha3(mem[128 len mem[96]])
        mem[0] = 1
        _13594 = mem[64]
        if bool(stor1[idx].field_0):
            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _13592:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if ext_code.size(address(arg5)) <= 0:
                    revert with 0, 'FOREST: NFT Address is not a contract'
                _13615 = mem[64]
                mem[64] = mem[64] + 192
                mem[_13615] = ceil32(ceil32(arg1.length)) + 97
                mem[_13615 + 32] = bool(arg3)
                mem[_13615 + 64] = arg4
                mem[_13615 + 96] = address(arg5)
                idx = 0
                while idx < stor1.length:
                    _27190 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _27198 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _27190:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            mem[_13615 + 128] = stor1[idx].field_1024
                            mem[_13615 + 160] = bool(arg6)
                            idx = 0
                            while idx < stor1.length:
                                _41930 = sha3(mem[128 len mem[96]])
                                mem[0] = 1
                                _41974 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41930:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43123 = mem[_13615]
                                        _43124 = mem[mem[_13615]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43124:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43124) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43123 + 32
                                                while _43123 + _43124 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43124 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43124:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43124) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43123 + 32
                                                while _43123 + _43124 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43124 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43214 = mem[_13615]
                                            _43215 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43215:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43215) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43214 + 32
                                                    while _43214 + _43215 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43215 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43215:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43215) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43214 + 32
                                                    while _43214 + _43215 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43215 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < uint255(stor1[idx].field_1):
                                                mem[_41974 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41974 + uint255(stor1[idx].field_1) - mem[64]]) != _41930:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61584 = mem[_13615]
                                            _61585 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61585:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61585) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61584 + 32
                                                    while _61584 + _61585 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61585 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61585:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61585) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61584 + 32
                                                    while _61584 + _61585 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61585 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41930:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43217 = mem[_13615]
                                        _43218 = mem[mem[_13615]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43218:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43218) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43217 + 32
                                                while _43217 + _43218 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43218 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43218:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43218) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43217 + 32
                                                while _43217 + _43218 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43218 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43495 = mem[_13615]
                                            _43496 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43496:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43496) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43495 + 32
                                                    while _43495 + _43496 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43496 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43496:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43496) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43495 + 32
                                                    while _43495 + _43496 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43496 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < stor1[idx].field_1 % 128:
                                                mem[_41974 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41974 + stor1[idx].field_1 % 128 - mem[64]]) != _41930:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61587 = mem[_13615]
                                            _61588 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61588:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61588) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61587 + 32
                                                    while _61587 + _61588 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61588 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61588:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61588) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61587 + 32
                                                    while _61587 + _61588 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61588 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                stor1[idx].field_512 = mem[_13615 + 64]
                                address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                stor1[idx].field_1024 = mem[_13615 + 128]
                                uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                            if 10^18 >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _42019 = mem[_13615]
                            _42020 = mem[mem[_13615]]
                            if bool(stor1.field_1536 * 10^18):
                                if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42020:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42020) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42019 + 32
                                    while _42019 + _42020 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42020 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42020:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42020) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42019 + 32
                                    while _42019 + _42020 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42020 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13615 + 128] = stor1[idx].field_1024
                                mem[_13615 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41932 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _41976 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41932:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43127 = mem[_13615]
                                            _43128 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43128:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43128) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43127 + 32
                                                    while _43127 + _43128 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43128 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43128:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43128) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43127 + 32
                                                    while _43127 + _43128 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43128 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43228 = mem[_13615]
                                                _43229 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43229:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43229) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43228 + 32
                                                        while _43228 + _43229 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43229 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43229:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43229) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43228 + 32
                                                        while _43228 + _43229 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43229 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_41976 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41976 + uint255(stor1[idx].field_1) - mem[64]]) != _41932:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61591 = mem[_13615]
                                                _61592 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61592:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61592) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61591 + 32
                                                        while _61591 + _61592 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61592 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61592:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61592) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61591 + 32
                                                        while _61591 + _61592 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61592 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41932:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43231 = mem[_13615]
                                            _43232 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43232:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43232) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43231 + 32
                                                    while _43231 + _43232 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43232 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43232:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43232) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43231 + 32
                                                    while _43231 + _43232 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43232 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43506 = mem[_13615]
                                                _43507 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43507:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43507) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43506 + 32
                                                        while _43506 + _43507 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43507 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43507:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43507) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43506 + 32
                                                        while _43506 + _43507 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43507 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_41976 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41976 + stor1[idx].field_1 % 128 - mem[64]]) != _41932:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61594 = mem[_13615]
                                                _61595 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61595:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61595) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61594 + 32
                                                        while _61594 + _61595 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61595 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61595:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61595) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61594 + 32
                                                        while _61594 + _61595 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61595 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                    stor1[idx].field_512 = mem[_13615 + 64]
                                    address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13615 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42022 = mem[_13615]
                                _42023 = mem[mem[_13615]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42023:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42023) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42022 + 32
                                        while _42022 + _42023 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42023 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42023:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42023) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42022 + 32
                                        while _42022 + _42023 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42023 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_27198 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _27198 + uint255(stor1[idx].field_1) - mem[64]]) != _27190:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13615 + 128] = stor1[idx].field_1024
                                mem[_13615 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57184 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57400 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57184:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62722 = mem[_13615]
                                            _62723 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62723:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62723) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62722 + 32
                                                    while _62722 + _62723 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62723 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62723:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62723) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62722 + 32
                                                    while _62722 + _62723 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62723 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62827 = mem[_13615]
                                                _62828 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62828:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62828) + 1
                                                        if _62827 + _62828 + 32 > var169003:
                                                            stor[var169002] = mem[var169003]
                                                            var169002 = var169002 + 1
                                                            var169003 = var169003 + 32
                                                            continue 
                                                        s = var169002
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62828:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62828) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62827 + 32
                                                        while _62827 + _62828 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62828 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57400 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57400 + uint255(stor1[idx].field_1) - mem[64]]) != _57184:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77918 = mem[_13615]
                                                _77919 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77919:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77919) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77918 + 32
                                                        while _77918 + _77919 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77919 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77919:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77919) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77918 + 32
                                                        while _77918 + _77919 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77919 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57184:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62830 = mem[_13615]
                                            _62831 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62831:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62831) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62830 + 32
                                                    while _62830 + _62831 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62831 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62831:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62831) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62830 + 32
                                                    while _62830 + _62831 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62831 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63121 = mem[_13615]
                                                _63122 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63122:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63122) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63121 + 32
                                                        while _63121 + _63122 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63122 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63122:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63122) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63121 + 32
                                                        while _63121 + _63122 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63122 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57400 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57400 + stor1[idx].field_1 % 128 - mem[64]]) != _57184:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77921 = mem[_13615]
                                                _77922 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77922:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77922) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77921 + 32
                                                        while _77921 + _77922 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77922 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77922:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77922) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77921 + 32
                                                        while _77921 + _77922 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77922 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                    stor1[idx].field_512 = mem[_13615 + 64]
                                    address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13615 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _57736 = mem[_13615]
                                _57737 = mem[mem[_13615]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _57737:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _57737) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _57736 + 32
                                        while _57736 + _57737 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _57737 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _57737:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _57737) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _57736 + 32
                                        while _57736 + _57737 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _57737 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _27190:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            mem[_13615 + 128] = stor1[idx].field_1024
                            mem[_13615 + 160] = bool(arg6)
                            idx = 0
                            while idx < stor1.length:
                                _41934 = sha3(mem[128 len mem[96]])
                                mem[0] = 1
                                _41978 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41934:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43130 = mem[_13615]
                                        _43131 = mem[mem[_13615]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43131:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43131) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43130 + 32
                                                while _43130 + _43131 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43131 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43131:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43131) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43130 + 32
                                                while _43130 + _43131 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43131 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43241 = mem[_13615]
                                            _43242 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43242:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43242) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43241 + 32
                                                    while _43241 + _43242 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43242 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43242:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43242) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43241 + 32
                                                    while _43241 + _43242 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43242 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < uint255(stor1[idx].field_1):
                                                mem[_41978 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41978 + uint255(stor1[idx].field_1) - mem[64]]) != _41934:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61597 = mem[_13615]
                                            _61598 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61598:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61598) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61597 + 32
                                                    while _61597 + _61598 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61598 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61598:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61598) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61597 + 32
                                                    while _61597 + _61598 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61598 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41934:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43244 = mem[_13615]
                                        _43245 = mem[mem[_13615]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43245:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43245) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43244 + 32
                                                while _43244 + _43245 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43245 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43245:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43245) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43244 + 32
                                                while _43244 + _43245 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43245 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43516 = mem[_13615]
                                            _43517 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43517:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43517) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43516 + 32
                                                    while _43516 + _43517 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43517 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43517:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43517) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43516 + 32
                                                    while _43516 + _43517 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43517 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < stor1[idx].field_1 % 128:
                                                mem[_41978 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41978 + stor1[idx].field_1 % 128 - mem[64]]) != _41934:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61600 = mem[_13615]
                                            _61601 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61601:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61601) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61600 + 32
                                                    while _61600 + _61601 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61601 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61601:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61601) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61600 + 32
                                                    while _61600 + _61601 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61601 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                stor1[idx].field_512 = mem[_13615 + 64]
                                address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                stor1[idx].field_1024 = mem[_13615 + 128]
                                uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                            if 10^18 >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _42025 = mem[_13615]
                            _42026 = mem[mem[_13615]]
                            if bool(stor1.field_1536 * 10^18):
                                if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42026:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42026) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42025 + 32
                                    while _42025 + _42026 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42026 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42026:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42026) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42025 + 32
                                    while _42025 + _42026 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42026 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13615 + 128] = stor1[idx].field_1024
                                mem[_13615 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41936 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _41980 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41936:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43134 = mem[_13615]
                                            _43135 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43135:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43135) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43134 + 32
                                                    while _43134 + _43135 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43135 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43135:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43135) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43134 + 32
                                                    while _43134 + _43135 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43135 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43255 = mem[_13615]
                                                _43256 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43256:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43256) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43255 + 32
                                                        while _43255 + _43256 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43256 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43256:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43256) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43255 + 32
                                                        while _43255 + _43256 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43256 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_41980 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41980 + uint255(stor1[idx].field_1) - mem[64]]) != _41936:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61604 = mem[_13615]
                                                _61605 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61605:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61605) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61604 + 32
                                                        while _61604 + _61605 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61605 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61605:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61605) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61604 + 32
                                                        while _61604 + _61605 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61605 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41936:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43258 = mem[_13615]
                                            _43259 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43259:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43259) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43258 + 32
                                                    while _43258 + _43259 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43259 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43259:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43259) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43258 + 32
                                                    while _43258 + _43259 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43259 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43527 = mem[_13615]
                                                _43528 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43528:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43528) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43527 + 32
                                                        while _43527 + _43528 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43528 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43528:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43528) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43527 + 32
                                                        while _43527 + _43528 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43528 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_41980 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41980 + stor1[idx].field_1 % 128 - mem[64]]) != _41936:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61607 = mem[_13615]
                                                _61608 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61608:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61608) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61607 + 32
                                                        while _61607 + _61608 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61608 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61608:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61608) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61607 + 32
                                                        while _61607 + _61608 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61608 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                    stor1[idx].field_512 = mem[_13615 + 64]
                                    address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13615 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42028 = mem[_13615]
                                _42029 = mem[mem[_13615]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42029:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42029) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42028 + 32
                                        while _42028 + _42029 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42029 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42029:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42029) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42028 + 32
                                        while _42028 + _42029 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42029 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_27198 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _27198 + stor1[idx].field_1 % 128 - mem[64]]) != _27190:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13615 + 128] = stor1[idx].field_1024
                                mem[_13615 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57206 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57402 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57206:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62729 = mem[_13615]
                                            _62730 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62730:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62730) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62729 + 32
                                                    while _62729 + _62730 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62730 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62730:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62730) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62729 + 32
                                                    while _62729 + _62730 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62730 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62844 = mem[_13615]
                                                _62845 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62845:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62845) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62844 + 32
                                                        while _62844 + _62845 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62845 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62845:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62845) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62844 + 32
                                                        while _62844 + _62845 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62845 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57402 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57402 + uint255(stor1[idx].field_1) - mem[64]]) != _57206:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77924 = mem[_13615]
                                                _77925 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77925:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77925) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77924 + 32
                                                        while _77924 + _77925 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77925 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77925:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77925) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77924 + 32
                                                        while _77924 + _77925 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77925 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57206:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62847 = mem[_13615]
                                            _62848 = mem[mem[_13615]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62848:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62848) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62847 + 32
                                                    while _62847 + _62848 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62848 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62848:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62848) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62847 + 32
                                                    while _62847 + _62848 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62848 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63151 = mem[_13615]
                                                _63152 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63152:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63152) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63151 + 32
                                                        while _63151 + _63152 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63152 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63152:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63152) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63151 + 32
                                                        while _63151 + _63152 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63152 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57402 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57402 + stor1[idx].field_1 % 128 - mem[64]]) != _57206:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77927 = mem[_13615]
                                                _77928 = mem[mem[_13615]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77928:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77928) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77927 + 32
                                                        while _77927 + _77928 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77928 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77928:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77928) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77927 + 32
                                                        while _77927 + _77928 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77928 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                                    stor1[idx].field_512 = mem[_13615 + 64]
                                    address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13615 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _58039 = mem[_13615]
                                _58040 = mem[mem[_13615]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58040:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58040) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58039 + 32
                                        while _58039 + _58040 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58040 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58040:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58040) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58039 + 32
                                        while _58039 + _58040 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58040 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13615 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_13615 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_13615 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_13615 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13615 + 160]))
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                mem[_13615 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_13615 + 160] = bool(arg6)
                idx = 0
                while idx < stor1.length:
                    _41928 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _41972 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41928:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _43120 = mem[_13615]
                            _43121 = mem[mem[_13615]]
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43121:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43121) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43120 + 32
                                    while _43120 + _43121 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43121 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43121:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43121) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43120 + 32
                                    while _43120 + _43121 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43121 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43201 = mem[_13615]
                                _43202 = mem[mem[_13615]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43202:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43202) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43201 + 32
                                        while _43201 + _43202 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43202 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43202:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43202) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43201 + 32
                                        while _43201 + _43202 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43202 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_41972 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _41972 + uint255(stor1[idx].field_1) - mem[64]]) != _41928:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _61578 = mem[_13615]
                                _61579 = mem[mem[_13615]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61579:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61579) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61578 + 32
                                        while _61578 + _61579 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61579 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61579:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61579) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61578 + 32
                                        while _61578 + _61579 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61579 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41928:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _43204 = mem[_13615]
                            _43205 = mem[mem[_13615]]
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43205:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43205) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43204 + 32
                                    while _43204 + _43205 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43205 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43205:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43205) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43204 + 32
                                    while _43204 + _43205 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43205 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43485 = mem[_13615]
                                _43486 = mem[mem[_13615]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43486:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43486) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43485 + 32
                                        while _43485 + _43486 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43486 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43486:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43486) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43485 + 32
                                        while _43485 + _43486 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43486 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_41972 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _41972 + stor1[idx].field_1 % 128 - mem[64]]) != _41928:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _61581 = mem[_13615]
                                _61582 = mem[mem[_13615]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61582:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61582) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61581 + 32
                                        while _61581 + _61582 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61582 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61582:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61582) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61581 + 32
                                        while _61581 + _61582 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61582 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13615 + 32]))
                    stor1[idx].field_512 = mem[_13615 + 64]
                    address(stor1[idx].field_768) = mem[_13615 + 108 len 20]
                    stor1[idx].field_1024 = mem[_13615 + 128]
                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13615 + 160]))
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _42016 = mem[_13615]
                _42017 = mem[mem[_13615]]
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    mem[0] = sha3(1) + 6 * 10^18
                    if not _42017:
                        uint256(stor1.field_1536 * 10^18) = 0
                        idx = sha3(sha3(1) + 6 * 10^18)
                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                    else:
                        uint256(stor1.field_1536 * 10^18) = (2 * _42017) + 1
                        s = sha3(sha3(1) + 6 * 10^18)
                        idx = _42016 + 32
                        while _42016 + _42017 + 32 > idx:
                            stor[s] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42017 + 31) >> 5)
                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    mem[0] = sha3(1) + 6 * 10^18
                    if not _42017:
                        uint256(stor1.field_1536 * 10^18) = 0
                        idx = sha3(sha3(1) + 6 * 10^18)
                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                    else:
                        uint256(stor1.field_1536 * 10^18) = (2 * _42017) + 1
                        s = sha3(sha3(1) + 6 * 10^18)
                        idx = _42016 + 32
                        while _42016 + _42017 + 32 > idx:
                            stor[s] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42017 + 31) >> 5)
                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13615 + 32]))
                uint256(stor1.field_1536000000000000000512) = mem[_13615 + 64]
                address(stor1.field_1536000000000000000768) = mem[_13615 + 108 len 20]
                uint256(stor1.field_1536000000000000001024) = mem[_13615 + 128]
                uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13615 + 160]))
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if ext_code.size(address(arg5)) <= 0:
                        revert with 0, 'FOREST: NFT Address is not a contract'
                    _13617 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_13617] = ceil32(ceil32(arg1.length)) + 97
                    mem[_13617 + 32] = bool(arg3)
                    mem[_13617 + 64] = arg4
                    mem[_13617 + 96] = address(arg5)
                    idx = 0
                    while idx < stor1.length:
                        _27192 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _27200 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _27192:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13617 + 128] = stor1[idx].field_1024
                                mem[_13617 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41942 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _41986 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41942:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43143 = mem[_13617]
                                            _43144 = mem[mem[_13617]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43144:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43144) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43143 + 32
                                                    while _43143 + _43144 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43144 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43144:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43144) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43143 + 32
                                                    while _43143 + _43144 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43144 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43289 = mem[_13617]
                                                _43290 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43290:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43290) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43289 + 32
                                                        while _43289 + _43290 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43290 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43290:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43290) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43289 + 32
                                                        while _43289 + _43290 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43290 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_41986 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41986 + uint255(stor1[idx].field_1) - mem[64]]) != _41942:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61623 = mem[_13617]
                                                _61624 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61624:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61624) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61623 + 32
                                                        while _61623 + _61624 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61624 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61624:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61624) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61623 + 32
                                                        while _61623 + _61624 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61624 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41942:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43292 = mem[_13617]
                                            _43293 = mem[mem[_13617]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43293:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43293) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43292 + 32
                                                    while _43292 + _43293 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43293 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43293:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43293) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43292 + 32
                                                    while _43292 + _43293 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43293 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43559 = mem[_13617]
                                                _43560 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43560:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43560) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43559 + 32
                                                        while _43559 + _43560 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43560 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43560:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43560) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43559 + 32
                                                        while _43559 + _43560 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43560 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_41986 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41986 + stor1[idx].field_1 % 128 - mem[64]]) != _41942:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61626 = mem[_13617]
                                                _61627 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61627:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61627) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61626 + 32
                                                        while _61626 + _61627 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61627 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61627:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61627) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61626 + 32
                                                        while _61626 + _61627 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61627 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                    stor1[idx].field_512 = mem[_13617 + 64]
                                    address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13617 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42035 = mem[_13617]
                                _42036 = mem[mem[_13617]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42036:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42036) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42035 + 32
                                        while _42035 + _42036 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42036 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42036:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42036) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42035 + 32
                                        while _42035 + _42036 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42036 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13617 + 128] = stor1[idx].field_1024
                                    mem[_13617 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _41944 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _41988 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41944:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43147 = mem[_13617]
                                                _43148 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43148:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43148) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43147 + 32
                                                        while _43147 + _43148 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43148 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43148:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43148) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43147 + 32
                                                        while _43147 + _43148 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43148 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43303 = mem[_13617]
                                                    _43304 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43304:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43304) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43303 + 32
                                                            while _43303 + _43304 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43304 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43304:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43304) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43303 + 32
                                                            while _43303 + _43304 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43304 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_41988 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _41988 + uint255(stor1[idx].field_1) - mem[64]]) != _41944:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61630 = mem[_13617]
                                                    _61631 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61631:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61631) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61630 + 32
                                                            while _61630 + _61631 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61631 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61631:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61631) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61630 + 32
                                                            while _61630 + _61631 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61631 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41944:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43306 = mem[_13617]
                                                _43307 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43307:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43307) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43306 + 32
                                                        while _43306 + _43307 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43307 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43307:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43307) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43306 + 32
                                                        while _43306 + _43307 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43307 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43570 = mem[_13617]
                                                    _43571 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43571:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43571) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43570 + 32
                                                            while _43570 + _43571 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43571 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43571:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43571) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43570 + 32
                                                            while _43570 + _43571 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43571 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_41988 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _41988 + stor1[idx].field_1 % 128 - mem[64]]) != _41944:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61633 = mem[_13617]
                                                    _61634 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61634:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61634) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61633 + 32
                                                            while _61633 + _61634 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61634 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61634:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61634) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61633 + 32
                                                            while _61633 + _61634 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61634 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                        stor1[idx].field_512 = mem[_13617 + 64]
                                        address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13617 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _42038 = mem[_13617]
                                    _42039 = mem[mem[_13617]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42039:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42039) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42038 + 32
                                            while _42038 + _42039 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42039 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42039:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42039) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42038 + 32
                                            while _42038 + _42039 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42039 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_27200 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _27200 + uint255(stor1[idx].field_1) - mem[64]]) != _27192:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13617 + 128] = stor1[idx].field_1024
                                    mem[_13617 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57248 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57414 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57248:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62755 = mem[_13617]
                                                _62756 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62756:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62756) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62755 + 32
                                                        while _62755 + _62756 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62756 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62756:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62756) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62755 + 32
                                                        while _62755 + _62756 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62756 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _62930 = mem[_13617]
                                                    _62931 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62931:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62931) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62930 + 32
                                                            while _62930 + _62931 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62931 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62931:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62931) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62930 + 32
                                                            while _62930 + _62931 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62931 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57414 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57414 + uint255(stor1[idx].field_1) - mem[64]]) != _57248:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77962 = mem[_13617]
                                                    _77963 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77963:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77963) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77962 + 32
                                                            while _77962 + _77963 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77963 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77963:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77963) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77962 + 32
                                                            while _77962 + _77963 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77963 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57248:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62933 = mem[_13617]
                                                _62934 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62934:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62934) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62933 + 32
                                                        while _62933 + _62934 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62934 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62934:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62934) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62933 + 32
                                                        while _62933 + _62934 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62934 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63243 = mem[_13617]
                                                    _63244 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63244:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63244) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63243 + 32
                                                            while _63243 + _63244 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63244 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63244:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63244) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63243 + 32
                                                            while _63243 + _63244 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63244 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57414 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57414 + stor1[idx].field_1 % 128 - mem[64]]) != _57248:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77965 = mem[_13617]
                                                    _77966 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77966:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77966) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77965 + 32
                                                            while _77965 + _77966 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77966 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77966:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77966) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77965 + 32
                                                            while _77965 + _77966 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77966 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                        stor1[idx].field_512 = mem[_13617 + 64]
                                        address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13617 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _58507 = mem[_13617]
                                    _58508 = mem[mem[_13617]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58508:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58508) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58507 + 32
                                            while _58507 + _58508 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58508 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58508:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58508) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58507 + 32
                                            while _58507 + _58508 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58508 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _27192:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13617 + 128] = stor1[idx].field_1024
                                mem[_13617 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41946 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _41990 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41946:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43150 = mem[_13617]
                                            _43151 = mem[mem[_13617]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43151:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43151) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43150 + 32
                                                    while _43150 + _43151 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43151 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43151:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43151) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43150 + 32
                                                    while _43150 + _43151 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43151 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43316 = mem[_13617]
                                                _43317 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43317:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43317) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43316 + 32
                                                        while _43316 + _43317 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43317 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43317:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43317) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43316 + 32
                                                        while _43316 + _43317 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43317 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_41990 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41990 + uint255(stor1[idx].field_1) - mem[64]]) != _41946:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61636 = mem[_13617]
                                                _61637 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61637:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61637) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61636 + 32
                                                        while _61636 + _61637 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61637 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61637:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61637) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61636 + 32
                                                        while _61636 + _61637 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61637 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41946:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43319 = mem[_13617]
                                            _43320 = mem[mem[_13617]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43320:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43320) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43319 + 32
                                                    while _43319 + _43320 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43320 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43320:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43320) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43319 + 32
                                                    while _43319 + _43320 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43320 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43580 = mem[_13617]
                                                _43581 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43581:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43581) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43580 + 32
                                                        while _43580 + _43581 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43581 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43581:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43581) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43580 + 32
                                                        while _43580 + _43581 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43581 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_41990 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41990 + stor1[idx].field_1 % 128 - mem[64]]) != _41946:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61639 = mem[_13617]
                                                _61640 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61640:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61640) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61639 + 32
                                                        while _61639 + _61640 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61640 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61640:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61640) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61639 + 32
                                                        while _61639 + _61640 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61640 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                    stor1[idx].field_512 = mem[_13617 + 64]
                                    address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13617 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42041 = mem[_13617]
                                _42042 = mem[mem[_13617]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42042:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42042) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42041 + 32
                                        while _42041 + _42042 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42042 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42042:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42042) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42041 + 32
                                        while _42041 + _42042 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42042 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13617 + 128] = stor1[idx].field_1024
                                    mem[_13617 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _41948 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _41992 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41948:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43154 = mem[_13617]
                                                _43155 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43155:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43155) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43154 + 32
                                                        while _43154 + _43155 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43155 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43155:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43155) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43154 + 32
                                                        while _43154 + _43155 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43155 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43330 = mem[_13617]
                                                    _43331 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43331:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43331) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43330 + 32
                                                            while _43330 + _43331 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43331 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43331:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43331) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43330 + 32
                                                            while _43330 + _43331 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43331 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_41992 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _41992 + uint255(stor1[idx].field_1) - mem[64]]) != _41948:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61643 = mem[_13617]
                                                    _61644 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61644:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61644) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61643 + 32
                                                            while _61643 + _61644 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61644 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61644:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61644) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61643 + 32
                                                            while _61643 + _61644 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61644 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41948:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43333 = mem[_13617]
                                                _43334 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43334:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43334) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43333 + 32
                                                        while _43333 + _43334 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43334 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43334:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43334) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43333 + 32
                                                        while _43333 + _43334 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43334 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43591 = mem[_13617]
                                                    _43592 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43592:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43592) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43591 + 32
                                                            while _43591 + _43592 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43592 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43592:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43592) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43591 + 32
                                                            while _43591 + _43592 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43592 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_41992 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _41992 + stor1[idx].field_1 % 128 - mem[64]]) != _41948:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61646 = mem[_13617]
                                                    _61647 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61647:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61647) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61646 + 32
                                                            while _61646 + _61647 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61647 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61647:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61647) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61646 + 32
                                                            while _61646 + _61647 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61647 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                        stor1[idx].field_512 = mem[_13617 + 64]
                                        address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13617 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _42044 = mem[_13617]
                                    _42045 = mem[mem[_13617]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42045:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42045) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42044 + 32
                                            while _42044 + _42045 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42045 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42045:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42045) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42044 + 32
                                            while _42044 + _42045 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42045 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_27200 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _27200 + stor1[idx].field_1 % 128 - mem[64]]) != _27192:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13617 + 128] = stor1[idx].field_1024
                                    mem[_13617 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57270 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57416 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57270:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62762 = mem[_13617]
                                                _62763 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62763:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62763) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62762 + 32
                                                        while _62762 + _62763 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62763 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62763:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62763) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62762 + 32
                                                        while _62762 + _62763 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62763 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _62947 = mem[_13617]
                                                    _62948 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62948:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62948) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62947 + 32
                                                            while _62947 + _62948 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62948 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62948:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62948) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62947 + 32
                                                            while _62947 + _62948 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62948 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57416 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57416 + uint255(stor1[idx].field_1) - mem[64]]) != _57270:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77968 = mem[_13617]
                                                    _77969 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77969:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77969) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77968 + 32
                                                            while _77968 + _77969 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77969 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77969:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77969) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77968 + 32
                                                            while _77968 + _77969 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77969 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57270:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62950 = mem[_13617]
                                                _62951 = mem[mem[_13617]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62951:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62951) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62950 + 32
                                                        while _62950 + _62951 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62951 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62951:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62951) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62950 + 32
                                                        while _62950 + _62951 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62951 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63273 = mem[_13617]
                                                    _63274 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63274:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63274) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63273 + 32
                                                            while _63273 + _63274 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63274 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63274:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63274) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63273 + 32
                                                            while _63273 + _63274 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63274 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57416 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57416 + stor1[idx].field_1 % 128 - mem[64]]) != _57270:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77971 = mem[_13617]
                                                    _77972 = mem[mem[_13617]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77972:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77972) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77971 + 32
                                                            while _77971 + _77972 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77972 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77972:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77972) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77971 + 32
                                                            while _77971 + _77972 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77972 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                                        stor1[idx].field_512 = mem[_13617 + 64]
                                        address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13617 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _58810 = mem[_13617]
                                    _58811 = mem[mem[_13617]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58811:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58811) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58810 + 32
                                            while _58810 + _58811 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58811 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58811:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58811) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58810 + 32
                                            while _58810 + _58811 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58811 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13617 + 32]))
                        uint256(stor1.field_1536000000000000000512) = mem[_13617 + 64]
                        address(stor1.field_1536000000000000000768) = mem[_13617 + 108 len 20]
                        uint256(stor1.field_1536000000000000001024) = mem[_13617 + 128]
                        uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13617 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    mem[_13617 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_13617 + 160] = bool(arg6)
                    idx = 0
                    while idx < stor1.length:
                        _41940 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _41984 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41940:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43140 = mem[_13617]
                                _43141 = mem[mem[_13617]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43141:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43141) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43140 + 32
                                        while _43140 + _43141 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43141 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43141:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43141) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43140 + 32
                                        while _43140 + _43141 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43141 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _43276 = mem[_13617]
                                    _43277 = mem[mem[_13617]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43277:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43277) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43276 + 32
                                            while _43276 + _43277 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43277 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43277:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43277) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43276 + 32
                                            while _43276 + _43277 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43277 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_41984 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _41984 + uint255(stor1[idx].field_1) - mem[64]]) != _41940:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _61617 = mem[_13617]
                                    _61618 = mem[mem[_13617]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61618:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61618) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61617 + 32
                                            while _61617 + _61618 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61618 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61618:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61618) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61617 + 32
                                            while _61617 + _61618 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61618 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41940:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43279 = mem[_13617]
                                _43280 = mem[mem[_13617]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43280:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43280) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43279 + 32
                                        while _43279 + _43280 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43280 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43280:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43280) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43279 + 32
                                        while _43279 + _43280 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43280 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _43549 = mem[_13617]
                                    _43550 = mem[mem[_13617]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43550:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43550) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43549 + 32
                                            while _43549 + _43550 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43550 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43550:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43550) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43549 + 32
                                            while _43549 + _43550 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43550 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_41984 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _41984 + stor1[idx].field_1 % 128 - mem[64]]) != _41940:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _61620 = mem[_13617]
                                    _61621 = mem[mem[_13617]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61621:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61621) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61620 + 32
                                            while _61620 + _61621 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61621 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61621:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61621) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61620 + 32
                                            while _61620 + _61621 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61621 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13617 + 32]))
                        stor1[idx].field_512 = mem[_13617 + 64]
                        address(stor1[idx].field_768) = mem[_13617 + 108 len 20]
                        stor1[idx].field_1024 = mem[_13617 + 128]
                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13617 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _42032 = mem[_13617]
                    _42033 = mem[mem[_13617]]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _42033:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _42033) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _42032 + 32
                            while _42032 + _42033 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42033 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _42033:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _42033) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _42032 + 32
                            while _42032 + _42033 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42033 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13617 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_13617 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_13617 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_13617 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13617 + 160]))
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < uint255(stor1[idx].field_1):
                        mem[_13594 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _13594 + uint255(stor1[idx].field_1) - mem[64]]) != _13592:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if ext_code.size(address(arg5)) <= 0:
                        revert with 0, 'FOREST: NFT Address is not a contract'
                    _27243 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_27243] = ceil32(ceil32(arg1.length)) + 97
                    mem[_27243 + 32] = bool(arg3)
                    mem[_27243 + 64] = arg4
                    mem[_27243 + 96] = address(arg5)
                    idx = 0
                    while idx < stor1.length:
                        _41938 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _41982 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41938:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_27243 + 128] = stor1[idx].field_1024
                                mem[_27243 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57220 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57406 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57220:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62737 = mem[_27243]
                                            _62738 = mem[mem[_27243]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62738:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62738) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62737 + 32
                                                    while _62737 + _62738 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62738 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62738:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62738) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62737 + 32
                                                    while _62737 + _62738 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62738 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62872 = mem[_27243]
                                                _62873 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62873:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62873) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62872 + 32
                                                        while _62872 + _62873 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62873 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62873:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62873) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62872 + 32
                                                        while _62872 + _62873 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62873 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57406 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57406 + uint255(stor1[idx].field_1) - mem[64]]) != _57220:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77936 = mem[_27243]
                                                _77937 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77937:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77937) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77936 + 32
                                                        while _77936 + _77937 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77937 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77937:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77937) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77936 + 32
                                                        while _77936 + _77937 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77937 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57220:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62875 = mem[_27243]
                                            _62876 = mem[mem[_27243]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62876:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62876) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62875 + 32
                                                    while _62875 + _62876 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62876 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62876:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62876) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62875 + 32
                                                    while _62875 + _62876 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62876 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63181 = mem[_27243]
                                                _63182 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63182:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63182) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63181 + 32
                                                        while _63181 + _63182 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63182 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63182:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63182) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63181 + 32
                                                        while _63181 + _63182 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63182 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57406 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57406 + stor1[idx].field_1 % 128 - mem[64]]) != _57220:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77939 = mem[_27243]
                                                _77940 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77940:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77940) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77939 + 32
                                                        while _77939 + _77940 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77940 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77940:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77940) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77939 + 32
                                                        while _77939 + _77940 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77940 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                    stor1[idx].field_512 = mem[_27243 + 64]
                                    address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_27243 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _58195 = mem[_27243]
                                _58196 = mem[mem[_27243]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58196:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58196) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58195 + 32
                                        while _58195 + _58196 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58196 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58196:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58196) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58195 + 32
                                        while _58195 + _58196 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58196 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27243 + 128] = stor1[idx].field_1024
                                    mem[_27243 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57222 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57408 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57222:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62741 = mem[_27243]
                                                _62742 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62742:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62742) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62741 + 32
                                                        while _62741 + _62742 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62742 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62742:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62742) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62741 + 32
                                                        while _62741 + _62742 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62742 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _62886 = mem[_27243]
                                                    _62887 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62887:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62887) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62886 + 32
                                                            while _62886 + _62887 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62887 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62887:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62887) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62886 + 32
                                                            while _62886 + _62887 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62887 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57408 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57408 + uint255(stor1[idx].field_1) - mem[64]]) != _57222:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77943 = mem[_27243]
                                                    _77944 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77944:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77944) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77943 + 32
                                                            while _77943 + _77944 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77944 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77944:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77944) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77943 + 32
                                                            while _77943 + _77944 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77944 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57222:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62889 = mem[_27243]
                                                _62890 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62890:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62890) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62889 + 32
                                                        while _62889 + _62890 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62890 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62890:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62890) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62889 + 32
                                                        while _62889 + _62890 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62890 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63192 = mem[_27243]
                                                    _63193 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63193:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63193) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63192 + 32
                                                            while _63192 + _63193 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63193 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63193:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63193) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63192 + 32
                                                            while _63192 + _63193 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63193 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57408 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57408 + stor1[idx].field_1 % 128 - mem[64]]) != _57222:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77946 = mem[_27243]
                                                    _77947 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77947:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77947) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77946 + 32
                                                            while _77946 + _77947 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77947 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77947:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77947) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77946 + 32
                                                            while _77946 + _77947 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77947 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                        stor1[idx].field_512 = mem[_27243 + 64]
                                        address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27243 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _58198 = mem[_27243]
                                    _58199 = mem[mem[_27243]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58199:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58199) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58198 + 32
                                            while _58198 + _58199 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58199 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58199:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58199) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58198 + 32
                                            while _58198 + _58199 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58199 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_41982 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _41982 + uint255(stor1[idx].field_1) - mem[64]]) != _41938:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27243 + 128] = stor1[idx].field_1024
                                    mem[_27243 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _71418 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _71626 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _71418:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78362 = mem[_27243]
                                                _78363 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78363:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78363) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78362 + 32
                                                        while _78362 + _78363 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78363 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78363:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78363) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78362 + 32
                                                        while _78362 + _78363 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78363 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78417 = mem[_27243]
                                                    _78418 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78418:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78418) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78417 + 32
                                                            while _78417 + _78418 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78418 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78418:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78418) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78417 + 32
                                                            while _78417 + _78418 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78418 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_71626 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71626 + uint255(stor1[idx].field_1) - mem[64]]) != _71418:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84766 = mem[_27243]
                                                    _84767 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84767:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84767) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84766 + 32
                                                            while _84766 + _84767 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84767 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84767:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84767) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84766 + 32
                                                            while _84766 + _84767 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84767 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _71418:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78420 = mem[_27243]
                                                _78421 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78421:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78421) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78420 + 32
                                                        while _78420 + _78421 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78421 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78421:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78421) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78420 + 32
                                                        while _78420 + _78421 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78421 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78537 = mem[_27243]
                                                    _78538 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78538:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78538) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78537 + 32
                                                            while _78537 + _78538 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78538 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78538:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78538) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78537 + 32
                                                            while _78537 + _78538 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78538 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_71626 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71626 + stor1[idx].field_1 % 128 - mem[64]]) != _71418:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84769 = mem[_27243]
                                                    _84770 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84770:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84770) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84769 + 32
                                                            while _84769 + _84770 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84770 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84770:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84770) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84769 + 32
                                                            while _84769 + _84770 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84770 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                        stor1[idx].field_512 = mem[_27243 + 64]
                                        address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27243 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _72784 = mem[_27243]
                                    _72785 = mem[mem[_27243]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _72785:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _72785) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _72784 + 32
                                            while _72784 + _72785 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _72785 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _72785:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _72785) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _72784 + 32
                                            while _72784 + _72785 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _72785 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41938:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_27243 + 128] = stor1[idx].field_1024
                                mem[_27243 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57224 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57410 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57224:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62744 = mem[_27243]
                                            _62745 = mem[mem[_27243]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62745:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62745) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62744 + 32
                                                    while _62744 + _62745 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62745 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62745:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62745) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62744 + 32
                                                    while _62744 + _62745 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62745 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62899 = mem[_27243]
                                                _62900 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62900:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62900) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62899 + 32
                                                        while _62899 + _62900 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62900 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62900:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62900) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62899 + 32
                                                        while _62899 + _62900 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62900 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57410 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57410 + uint255(stor1[idx].field_1) - mem[64]]) != _57224:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77949 = mem[_27243]
                                                _77950 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77950:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77950) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77949 + 32
                                                        while _77949 + _77950 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77950 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77950:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77950) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77949 + 32
                                                        while _77949 + _77950 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77950 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57224:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62902 = mem[_27243]
                                            _62903 = mem[mem[_27243]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62903:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62903) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62902 + 32
                                                    while _62902 + _62903 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62903 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62903:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62903) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62902 + 32
                                                    while _62902 + _62903 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62903 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63202 = mem[_27243]
                                                _63203 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63203:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63203) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63202 + 32
                                                        while _63202 + _63203 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63203 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63203:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63203) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63202 + 32
                                                        while _63202 + _63203 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63203 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57410 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57410 + stor1[idx].field_1 % 128 - mem[64]]) != _57224:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77952 = mem[_27243]
                                                _77953 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77953:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77953) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77952 + 32
                                                        while _77952 + _77953 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77953 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77953:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77953) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77952 + 32
                                                        while _77952 + _77953 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77953 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                    stor1[idx].field_512 = mem[_27243 + 64]
                                    address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_27243 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _58201 = mem[_27243]
                                _58202 = mem[mem[_27243]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58202:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58202) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58201 + 32
                                        while _58201 + _58202 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58202 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _58202:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _58202) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _58201 + 32
                                        while _58201 + _58202 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58202 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27243 + 128] = stor1[idx].field_1024
                                    mem[_27243 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57226 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57412 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57226:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62748 = mem[_27243]
                                                _62749 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62749:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62749) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62748 + 32
                                                        while _62748 + _62749 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62749 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62749:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62749) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62748 + 32
                                                        while _62748 + _62749 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62749 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _62913 = mem[_27243]
                                                    _62914 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62914:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62914) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62913 + 32
                                                            while _62913 + _62914 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62914 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _62914:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _62914) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _62913 + 32
                                                            while _62913 + _62914 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62914 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57412 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57412 + uint255(stor1[idx].field_1) - mem[64]]) != _57226:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77956 = mem[_27243]
                                                    _77957 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77957:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77957) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77956 + 32
                                                            while _77956 + _77957 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77957 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77957:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77957) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77956 + 32
                                                            while _77956 + _77957 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77957 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57226:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62916 = mem[_27243]
                                                _62917 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62917:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62917) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62916 + 32
                                                        while _62916 + _62917 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62917 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62917:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62917) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62916 + 32
                                                        while _62916 + _62917 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62917 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63213 = mem[_27243]
                                                    _63214 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63214:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63214) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63213 + 32
                                                            while _63213 + _63214 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63214 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63214:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63214) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63213 + 32
                                                            while _63213 + _63214 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63214 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57412 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57412 + stor1[idx].field_1 % 128 - mem[64]]) != _57226:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77959 = mem[_27243]
                                                    _77960 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77960:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77960) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77959 + 32
                                                            while _77959 + _77960 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77960 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _77960:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _77960) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77959 + 32
                                                            while _77959 + _77960 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77960 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                        stor1[idx].field_512 = mem[_27243 + 64]
                                        address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27243 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _58204 = mem[_27243]
                                    _58205 = mem[mem[_27243]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58205:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58205) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58204 + 32
                                            while _58204 + _58205 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58205 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _58205:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _58205) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _58204 + 32
                                            while _58204 + _58205 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58205 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_41982 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _41982 + stor1[idx].field_1 % 128 - mem[64]]) != _41938:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27243 + 128] = stor1[idx].field_1024
                                    mem[_27243 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _71440 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _71628 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _71440:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78369 = mem[_27243]
                                                _78370 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78370:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78370) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78369 + 32
                                                        while _78369 + _78370 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78370 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78370:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78370) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78369 + 32
                                                        while _78369 + _78370 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78370 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78434 = mem[_27243]
                                                    _78435 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78435:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78435) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78434 + 32
                                                            while _78434 + _78435 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78435 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78435:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78435) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78434 + 32
                                                            while _78434 + _78435 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78435 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_71628 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71628 + uint255(stor1[idx].field_1) - mem[64]]) != _71440:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84772 = mem[_27243]
                                                    _84773 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84773:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84773) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84772 + 32
                                                            while _84772 + _84773 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84773 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84773:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84773) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84772 + 32
                                                            while _84772 + _84773 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84773 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _71440:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78437 = mem[_27243]
                                                _78438 = mem[mem[_27243]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78438:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78438) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78437 + 32
                                                        while _78437 + _78438 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78438 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78438:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78438) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78437 + 32
                                                        while _78437 + _78438 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78438 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78567 = mem[_27243]
                                                    _78568 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78568:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78568) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78567 + 32
                                                            while _78567 + _78568 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78568 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78568:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78568) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78567 + 32
                                                            while _78567 + _78568 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78568 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_71628 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71628 + stor1[idx].field_1 % 128 - mem[64]]) != _71440:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84775 = mem[_27243]
                                                    _84776 = mem[mem[_27243]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84776:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84776) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84775 + 32
                                                            while _84775 + _84776 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84776 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84776:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84776) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84775 + 32
                                                            while _84775 + _84776 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84776 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                                        stor1[idx].field_512 = mem[_27243 + 64]
                                        address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27243 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _73087 = mem[_27243]
                                    _73088 = mem[mem[_27243]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _73088:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _73088) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _73087 + 32
                                            while _73087 + _73088 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _73088 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _73088:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _73088) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _73087 + 32
                                            while _73087 + _73088 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _73088 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_27243 + 32]))
                        uint256(stor1.field_1536000000000000000512) = mem[_27243 + 64]
                        address(stor1.field_1536000000000000000768) = mem[_27243 + 108 len 20]
                        uint256(stor1.field_1536000000000000001024) = mem[_27243 + 128]
                        uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_27243 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    mem[_27243 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_27243 + 160] = bool(arg6)
                    idx = 0
                    while idx < stor1.length:
                        _57218 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _57404 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57218:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _62734 = mem[_27243]
                                _62735 = mem[mem[_27243]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62735:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62735) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62734 + 32
                                        while _62734 + _62735 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62735 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62735:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62735) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62734 + 32
                                        while _62734 + _62735 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62735 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _62859 = mem[_27243]
                                    _62860 = mem[mem[_27243]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _62860:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _62860) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _62859 + 32
                                            while _62859 + _62860 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62860 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _62860:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _62860) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _62859 + 32
                                            while _62859 + _62860 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62860 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_57404 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _57404 + uint255(stor1[idx].field_1) - mem[64]]) != _57218:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _77930 = mem[_27243]
                                    _77931 = mem[mem[_27243]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77931:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77931) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77930 + 32
                                            while _77930 + _77931 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77931 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77931:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77931) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77930 + 32
                                            while _77930 + _77931 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77931 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57218:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _62862 = mem[_27243]
                                _62863 = mem[mem[_27243]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62863:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62863) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62862 + 32
                                        while _62862 + _62863 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62863 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62863:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62863) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62862 + 32
                                        while _62862 + _62863 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62863 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _63171 = mem[_27243]
                                    _63172 = mem[mem[_27243]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _63172:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _63172) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _63171 + 32
                                            while _63171 + _63172 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63172 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _63172:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _63172) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _63171 + 32
                                            while _63171 + _63172 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63172 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_57404 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _57404 + stor1[idx].field_1 % 128 - mem[64]]) != _57218:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _77933 = mem[_27243]
                                    _77934 = mem[mem[_27243]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77934:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77934) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77933 + 32
                                            while _77933 + _77934 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77934 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77934:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77934) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77933 + 32
                                            while _77933 + _77934 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77934 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27243 + 32]))
                        stor1[idx].field_512 = mem[_27243 + 64]
                        address(stor1[idx].field_768) = mem[_27243 + 108 len 20]
                        stor1[idx].field_1024 = mem[_27243 + 128]
                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27243 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _58192 = mem[_27243]
                    _58193 = mem[mem[_27243]]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _58193:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _58193) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _58192 + 32
                            while _58192 + _58193 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58193 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _58193:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _58193) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _58192 + 32
                            while _58192 + _58193 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _58193 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_27243 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_27243 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_27243 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_27243 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_27243 + 160]))
        else:
            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor1[idx].field_0):
                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _13592:
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                if idx == 10^18:
                    revert with 0, 'FOREST: Target NFT does not exist'
                if ext_code.size(address(arg5)) <= 0:
                    revert with 0, 'FOREST: NFT Address is not a contract'
                _13619 = mem[64]
                mem[64] = mem[64] + 192
                mem[_13619] = ceil32(ceil32(arg1.length)) + 97
                mem[_13619 + 32] = bool(arg3)
                mem[_13619 + 64] = arg4
                mem[_13619 + 96] = address(arg5)
                idx = 0
                while idx < stor1.length:
                    _27194 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _27202 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _27194:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            mem[_13619 + 128] = stor1[idx].field_1024
                            mem[_13619 + 160] = bool(arg6)
                            idx = 0
                            while idx < stor1.length:
                                _41952 = sha3(mem[128 len mem[96]])
                                mem[0] = 1
                                _41996 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41952:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43160 = mem[_13619]
                                        _43161 = mem[mem[_13619]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43161:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43161) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43160 + 32
                                                while _43160 + _43161 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43161 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43161:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43161) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43160 + 32
                                                while _43160 + _43161 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43161 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43356 = mem[_13619]
                                            _43357 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43357:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43357) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43356 + 32
                                                    while _43356 + _43357 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43357 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43357:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43357) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43356 + 32
                                                    while _43356 + _43357 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43357 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < uint255(stor1[idx].field_1):
                                                mem[_41996 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41996 + uint255(stor1[idx].field_1) - mem[64]]) != _41952:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61655 = mem[_13619]
                                            _61656 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61656:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61656) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61655 + 32
                                                    while _61655 + _61656 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61656 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61656:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61656) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61655 + 32
                                                    while _61655 + _61656 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61656 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41952:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43359 = mem[_13619]
                                        _43360 = mem[mem[_13619]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43360:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43360) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43359 + 32
                                                while _43359 + _43360 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43360 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43360:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43360) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43359 + 32
                                                while _43359 + _43360 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43360 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43611 = mem[_13619]
                                            _43612 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43612:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43612) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43611 + 32
                                                    while _43611 + _43612 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43612 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43612:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43612) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43611 + 32
                                                    while _43611 + _43612 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43612 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < stor1[idx].field_1 % 128:
                                                mem[_41996 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _41996 + stor1[idx].field_1 % 128 - mem[64]]) != _41952:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61658 = mem[_13619]
                                            _61659 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61659:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61659) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61658 + 32
                                                    while _61658 + _61659 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61659 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61659:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61659) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61658 + 32
                                                    while _61658 + _61659 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61659 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                stor1[idx].field_512 = mem[_13619 + 64]
                                address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                stor1[idx].field_1024 = mem[_13619 + 128]
                                uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                            if 10^18 >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _42050 = mem[_13619]
                            _42051 = mem[mem[_13619]]
                            if bool(stor1.field_1536 * 10^18):
                                if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42051:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42051) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42050 + 32
                                    while _42050 + _42051 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42051 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42051:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42051) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42050 + 32
                                    while _42050 + _42051 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42051 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13619 + 128] = stor1[idx].field_1024
                                mem[_13619 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41954 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _41998 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41954:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43164 = mem[_13619]
                                            _43165 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43165:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43165) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43164 + 32
                                                    while _43164 + _43165 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43165 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43165:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43165) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43164 + 32
                                                    while _43164 + _43165 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43165 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43370 = mem[_13619]
                                                _43371 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43371:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43371) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43370 + 32
                                                        while _43370 + _43371 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43371 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43371:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43371) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43370 + 32
                                                        while _43370 + _43371 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43371 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_41998 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41998 + uint255(stor1[idx].field_1) - mem[64]]) != _41954:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61662 = mem[_13619]
                                                _61663 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61663:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61663) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61662 + 32
                                                        while _61662 + _61663 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61663 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61663:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61663) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61662 + 32
                                                        while _61662 + _61663 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61663 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41954:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43373 = mem[_13619]
                                            _43374 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43374:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43374) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43373 + 32
                                                    while _43373 + _43374 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43374 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43374:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43374) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43373 + 32
                                                    while _43373 + _43374 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43374 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43622 = mem[_13619]
                                                _43623 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43623:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43623) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43622 + 32
                                                        while _43622 + _43623 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43623 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43623:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43623) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43622 + 32
                                                        while _43622 + _43623 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43623 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_41998 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _41998 + stor1[idx].field_1 % 128 - mem[64]]) != _41954:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61665 = mem[_13619]
                                                _61666 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61666:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61666) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61665 + 32
                                                        while _61665 + _61666 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61666 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61666:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61666) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61665 + 32
                                                        while _61665 + _61666 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61666 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                    stor1[idx].field_512 = mem[_13619 + 64]
                                    address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13619 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42053 = mem[_13619]
                                _42054 = mem[mem[_13619]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42054:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42054) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42053 + 32
                                        while _42053 + _42054 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42054 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42054:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42054) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42053 + 32
                                        while _42053 + _42054 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42054 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_27202 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _27202 + uint255(stor1[idx].field_1) - mem[64]]) != _27194:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13619 + 128] = stor1[idx].field_1024
                                mem[_13619 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57302 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57418 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57302:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62771 = mem[_13619]
                                            _62772 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62772:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62772) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62771 + 32
                                                    while _62771 + _62772 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62772 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62772:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62772) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62771 + 32
                                                    while _62771 + _62772 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62772 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62966 = mem[_13619]
                                                _62967 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62967:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62967) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62966 + 32
                                                        while _62966 + _62967 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62967 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62967:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62967) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62966 + 32
                                                        while _62966 + _62967 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62967 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57418 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57418 + uint255(stor1[idx].field_1) - mem[64]]) != _57302:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77974 = mem[_13619]
                                                _77975 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77975:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77975) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77974 + 32
                                                        while _77974 + _77975 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77975 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77975:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77975) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77974 + 32
                                                        while _77974 + _77975 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77975 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57302:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62969 = mem[_13619]
                                            _62970 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62970:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62970) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62969 + 32
                                                    while _62969 + _62970 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62970 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62970:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62970) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62969 + 32
                                                    while _62969 + _62970 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62970 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63313 = mem[_13619]
                                                _63314 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63314:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63314) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63313 + 32
                                                        while _63313 + _63314 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63314 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63314:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63314) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63313 + 32
                                                        while _63313 + _63314 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63314 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57418 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57418 + stor1[idx].field_1 % 128 - mem[64]]) != _57302:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77977 = mem[_13619]
                                                _77978 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77978:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77978) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77977 + 32
                                                        while _77977 + _77978 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77978 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77978:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77978) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77977 + 32
                                                        while _77977 + _77978 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77978 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                    stor1[idx].field_512 = mem[_13619 + 64]
                                    address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13619 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _59263 = mem[_13619]
                                _59264 = mem[mem[_13619]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59264:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59264) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59263 + 32
                                        while _59263 + _59264 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59264 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59264:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59264) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59263 + 32
                                        while _59263 + _59264 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59264 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _27194:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            mem[_13619 + 128] = stor1[idx].field_1024
                            mem[_13619 + 160] = bool(arg6)
                            idx = 0
                            while idx < stor1.length:
                                _41956 = sha3(mem[128 len mem[96]])
                                mem[0] = 1
                                _42000 = mem[64]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41956:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43167 = mem[_13619]
                                        _43168 = mem[mem[_13619]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43168:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43168) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43167 + 32
                                                while _43167 + _43168 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43168 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43168:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43168) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43167 + 32
                                                while _43167 + _43168 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43168 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43383 = mem[_13619]
                                            _43384 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43384:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43384) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43383 + 32
                                                    while _43383 + _43384 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43384 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43384:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43384) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43383 + 32
                                                    while _43383 + _43384 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43384 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < uint255(stor1[idx].field_1):
                                                mem[_42000 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _42000 + uint255(stor1[idx].field_1) - mem[64]]) != _41956:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61668 = mem[_13619]
                                            _61669 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61669:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61669) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61668 + 32
                                                    while _61668 + _61669 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61669 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61669:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61669) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61668 + 32
                                                    while _61668 + _61669 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61669 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    if not bool(stor1[idx].field_0):
                                        mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                        if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41956:
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            continue 
                                        if idx >= stor1.length:
                                            revert with 'NH{q', 50
                                        mem[0] = 1
                                        _43386 = mem[_13619]
                                        _43387 = mem[mem[_13619]]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43387:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43387) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43386 + 32
                                                while _43386 + _43387 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43387 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            mem[0] = (6 * idx) + sha3(1)
                                            if not _43387:
                                                stor1[idx].field_0 = 0
                                                s = sha3((6 * idx) + sha3(1))
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                stor1[idx].field_0 = (2 * _43387) + 1
                                                t = sha3((6 * idx) + sha3(1))
                                                s = _43386 + 32
                                                while _43386 + _43387 + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43387 + 31) >> 5)
                                                while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor1[idx].field_0) != 1:
                                            if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43632 = mem[_13619]
                                            _43633 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43633:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43633) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43632 + 32
                                                    while _43632 + _43633 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43633 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43633:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43633) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43632 + 32
                                                    while _43632 + _43633 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43633 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            mem[0] = (6 * idx) + sha3(1)
                                            s = 0
                                            t = sha3(mem[0])
                                            while s < stor1[idx].field_1 % 128:
                                                mem[_42000 + s] = stor[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                            if sha3(mem[mem[64] len _42000 + stor1[idx].field_1 % 128 - mem[64]]) != _41956:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _61671 = mem[_13619]
                                            _61672 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61672:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61672) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61671 + 32
                                                    while _61671 + _61672 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61672 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _61672:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _61672) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _61671 + 32
                                                    while _61671 + _61672 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61672 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                stor1[idx].field_512 = mem[_13619 + 64]
                                address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                stor1[idx].field_1024 = mem[_13619 + 128]
                                uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                            if 10^18 >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _42056 = mem[_13619]
                            _42057 = mem[mem[_13619]]
                            if bool(stor1.field_1536 * 10^18):
                                if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42057:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42057) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42056 + 32
                                    while _42056 + _42057 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42057 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = sha3(1) + 6 * 10^18
                                if not _42057:
                                    uint256(stor1.field_1536 * 10^18) = 0
                                    idx = sha3(sha3(1) + 6 * 10^18)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    uint256(stor1.field_1536 * 10^18) = (2 * _42057) + 1
                                    s = sha3(sha3(1) + 6 * 10^18)
                                    idx = _42056 + 32
                                    while _42056 + _42057 + 32 > idx:
                                        stor[s] = mem[idx]
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42057 + 31) >> 5)
                                    while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                        stor[idx] = 0
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13619 + 128] = stor1[idx].field_1024
                                mem[_13619 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41958 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _42002 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41958:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43171 = mem[_13619]
                                            _43172 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43172:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43172) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43171 + 32
                                                    while _43171 + _43172 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43172 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43172:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43172) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43171 + 32
                                                    while _43171 + _43172 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43172 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43397 = mem[_13619]
                                                _43398 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43398:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43398) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43397 + 32
                                                        while _43397 + _43398 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43398 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43398:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43398) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43397 + 32
                                                        while _43397 + _43398 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43398 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_42002 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42002 + uint255(stor1[idx].field_1) - mem[64]]) != _41958:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61675 = mem[_13619]
                                                _61676 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61676:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61676) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61675 + 32
                                                        while _61675 + _61676 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61676 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61676:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61676) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61675 + 32
                                                        while _61675 + _61676 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61676 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41958:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43400 = mem[_13619]
                                            _43401 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43401:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43401) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43400 + 32
                                                    while _43400 + _43401 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43401 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43401:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43401) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43400 + 32
                                                    while _43400 + _43401 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43401 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43643 = mem[_13619]
                                                _43644 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43644:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43644) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43643 + 32
                                                        while _43643 + _43644 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43644 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43644:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43644) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43643 + 32
                                                        while _43643 + _43644 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43644 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_42002 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42002 + stor1[idx].field_1 % 128 - mem[64]]) != _41958:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61678 = mem[_13619]
                                                _61679 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61679:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61679) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61678 + 32
                                                        while _61678 + _61679 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61679 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61679:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61679) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61678 + 32
                                                        while _61678 + _61679 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61679 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                    stor1[idx].field_512 = mem[_13619 + 64]
                                    address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13619 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42059 = mem[_13619]
                                _42060 = mem[mem[_13619]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42060:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42060) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42059 + 32
                                        while _42059 + _42060 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42060 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42060:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42060) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42059 + 32
                                        while _42059 + _42060 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42060 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_27202 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _27202 + stor1[idx].field_1 % 128 - mem[64]]) != _27194:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13619 + 128] = stor1[idx].field_1024
                                mem[_13619 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57324 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57420 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57324:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62778 = mem[_13619]
                                            _62779 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62779:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62779) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62778 + 32
                                                    while _62778 + _62779 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62779 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62779:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62779) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62778 + 32
                                                    while _62778 + _62779 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62779 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62983 = mem[_13619]
                                                _62984 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62984:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62984) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62983 + 32
                                                        while _62983 + _62984 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62984 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62984:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62984) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62983 + 32
                                                        while _62983 + _62984 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62984 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57420 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57420 + uint255(stor1[idx].field_1) - mem[64]]) != _57324:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77980 = mem[_13619]
                                                _77981 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77981:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77981) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77980 + 32
                                                        while _77980 + _77981 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77981 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77981:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77981) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77980 + 32
                                                        while _77980 + _77981 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77981 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57324:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62986 = mem[_13619]
                                            _62987 = mem[mem[_13619]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62987:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62987) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62986 + 32
                                                    while _62986 + _62987 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62987 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62987:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62987) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62986 + 32
                                                    while _62986 + _62987 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62987 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63343 = mem[_13619]
                                                _63344 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63344:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63344) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63343 + 32
                                                        while _63343 + _63344 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63344 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63344:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63344) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63343 + 32
                                                        while _63343 + _63344 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63344 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57420 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57420 + stor1[idx].field_1 % 128 - mem[64]]) != _57324:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77983 = mem[_13619]
                                                _77984 = mem[mem[_13619]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77984:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77984) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77983 + 32
                                                        while _77983 + _77984 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77984 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77984:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77984) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77983 + 32
                                                        while _77983 + _77984 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77984 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                                    stor1[idx].field_512 = mem[_13619 + 64]
                                    address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13619 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _59566 = mem[_13619]
                                _59567 = mem[mem[_13619]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59567:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59567) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59566 + 32
                                        while _59566 + _59567 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59567 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59567:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59567) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59566 + 32
                                        while _59566 + _59567 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59567 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13619 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_13619 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_13619 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_13619 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13619 + 160]))
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                mem[_13619 + 128] = uint256(stor1.field_1536000000000000001024)
                mem[_13619 + 160] = bool(arg6)
                idx = 0
                while idx < stor1.length:
                    _41950 = sha3(mem[128 len mem[96]])
                    mem[0] = 1
                    _41994 = mem[64]
                    if bool(stor1[idx].field_0):
                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41950:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _43157 = mem[_13619]
                            _43158 = mem[mem[_13619]]
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43158:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43158) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43157 + 32
                                    while _43157 + _43158 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43158 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43158:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43158) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43157 + 32
                                    while _43157 + _43158 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43158 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43343 = mem[_13619]
                                _43344 = mem[mem[_13619]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43344:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43344) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43343 + 32
                                        while _43343 + _43344 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43344 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43344:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43344) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43343 + 32
                                        while _43343 + _43344 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43344 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(stor1[idx].field_1):
                                    mem[_41994 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _41994 + uint255(stor1[idx].field_1) - mem[64]]) != _41950:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _61649 = mem[_13619]
                                _61650 = mem[mem[_13619]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61650:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61650) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61649 + 32
                                        while _61649 + _61650 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61650 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61650:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61650) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61649 + 32
                                        while _61649 + _61650 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61650 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor1[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41950:
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            if idx >= stor1.length:
                                revert with 'NH{q', 50
                            mem[0] = 1
                            _43346 = mem[_13619]
                            _43347 = mem[mem[_13619]]
                            if bool(stor1[idx].field_0):
                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43347:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43347) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43346 + 32
                                    while _43346 + _43347 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43347 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                    revert with 'NH{q', 34
                                mem[0] = (6 * idx) + sha3(1)
                                if not _43347:
                                    stor1[idx].field_0 = 0
                                    s = sha3((6 * idx) + sha3(1))
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    stor1[idx].field_0 = (2 * _43347) + 1
                                    t = sha3((6 * idx) + sha3(1))
                                    s = _43346 + 32
                                    while _43346 + _43347 + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43347 + 31) >> 5)
                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor1[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43601 = mem[_13619]
                                _43602 = mem[mem[_13619]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43602:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43602) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43601 + 32
                                        while _43601 + _43602 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43602 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43602:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43602) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43601 + 32
                                        while _43601 + _43602 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43602 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                mem[0] = (6 * idx) + sha3(1)
                                s = 0
                                t = sha3(mem[0])
                                while s < stor1[idx].field_1 % 128:
                                    mem[_41994 + s] = stor[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _41994 + stor1[idx].field_1 % 128 - mem[64]]) != _41950:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _61652 = mem[_13619]
                                _61653 = mem[mem[_13619]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61653:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61653) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61652 + 32
                                        while _61652 + _61653 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61653 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _61653:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _61653) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _61652 + 32
                                        while _61652 + _61653 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61653 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13619 + 32]))
                    stor1[idx].field_512 = mem[_13619 + 64]
                    address(stor1[idx].field_768) = mem[_13619 + 108 len 20]
                    stor1[idx].field_1024 = mem[_13619 + 128]
                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13619 + 160]))
                if 10^18 >= stor1.length:
                    revert with 'NH{q', 50
                mem[0] = 1
                _42047 = mem[_13619]
                _42048 = mem[mem[_13619]]
                if bool(stor1.field_1536 * 10^18):
                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                        revert with 'NH{q', 34
                    mem[0] = sha3(1) + 6 * 10^18
                    if not _42048:
                        uint256(stor1.field_1536 * 10^18) = 0
                        idx = sha3(sha3(1) + 6 * 10^18)
                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                    else:
                        uint256(stor1.field_1536 * 10^18) = (2 * _42048) + 1
                        s = sha3(sha3(1) + 6 * 10^18)
                        idx = _42047 + 32
                        while _42047 + _42048 + 32 > idx:
                            stor[s] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42048 + 31) >> 5)
                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                else:
                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                        revert with 'NH{q', 34
                    mem[0] = sha3(1) + 6 * 10^18
                    if not _42048:
                        uint256(stor1.field_1536 * 10^18) = 0
                        idx = sha3(sha3(1) + 6 * 10^18)
                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                    else:
                        uint256(stor1.field_1536 * 10^18) = (2 * _42048) + 1
                        s = sha3(sha3(1) + 6 * 10^18)
                        idx = _42047 + 32
                        while _42047 + _42048 + 32 > idx:
                            stor[s] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42048 + 31) >> 5)
                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                            stor[idx] = 0
                            idx = idx + 1
                            continue 
                uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13619 + 32]))
                uint256(stor1.field_1536000000000000000512) = mem[_13619 + 64]
                address(stor1.field_1536000000000000000768) = mem[_13619 + 108 len 20]
                uint256(stor1.field_1536000000000000001024) = mem[_13619 + 128]
                uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13619 + 160]))
            else:
                if bool(stor1[idx].field_0) != 1:
                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if ext_code.size(address(arg5)) <= 0:
                        revert with 0, 'FOREST: NFT Address is not a contract'
                    _13622 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_13622] = ceil32(ceil32(arg1.length)) + 97
                    mem[_13622 + 32] = bool(arg3)
                    mem[_13622 + 64] = arg4
                    mem[_13622 + 96] = address(arg5)
                    idx = 0
                    while idx < stor1.length:
                        _27196 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _27204 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _27196:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13622 + 128] = stor1[idx].field_1024
                                mem[_13622 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41964 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _42008 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41964:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43180 = mem[_13622]
                                            _43181 = mem[mem[_13622]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43181:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43181) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43180 + 32
                                                    while _43180 + _43181 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43181 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43181:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43181) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43180 + 32
                                                    while _43180 + _43181 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43181 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43431 = mem[_13622]
                                                _43432 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43432:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43432) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43431 + 32
                                                        while _43431 + _43432 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43432 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43432:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43432) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43431 + 32
                                                        while _43431 + _43432 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43432 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_42008 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42008 + uint255(stor1[idx].field_1) - mem[64]]) != _41964:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61694 = mem[_13622]
                                                _61695 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61695:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61695) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61694 + 32
                                                        while _61694 + _61695 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61695 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61695:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61695) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61694 + 32
                                                        while _61694 + _61695 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61695 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41964:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43434 = mem[_13622]
                                            _43435 = mem[mem[_13622]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43435:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43435) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43434 + 32
                                                    while _43434 + _43435 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43435 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43435:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43435) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43434 + 32
                                                    while _43434 + _43435 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43435 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43675 = mem[_13622]
                                                _43676 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43676:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43676) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43675 + 32
                                                        while _43675 + _43676 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43676 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43676:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43676) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43675 + 32
                                                        while _43675 + _43676 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43676 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_42008 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42008 + stor1[idx].field_1 % 128 - mem[64]]) != _41964:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61697 = mem[_13622]
                                                _61698 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61698:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61698) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61697 + 32
                                                        while _61697 + _61698 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61698 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61698:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61698) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61697 + 32
                                                        while _61697 + _61698 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61698 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                    stor1[idx].field_512 = mem[_13622 + 64]
                                    address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13622 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42066 = mem[_13622]
                                _42067 = mem[mem[_13622]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42067:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42067) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42066 + 32
                                        while _42066 + _42067 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42067 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42067:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42067) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42066 + 32
                                        while _42066 + _42067 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42067 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13622 + 128] = stor1[idx].field_1024
                                    mem[_13622 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _41966 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _42010 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41966:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43184 = mem[_13622]
                                                _43185 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43185:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43185) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43184 + 32
                                                        while _43184 + _43185 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43185 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43185:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43185) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43184 + 32
                                                        while _43184 + _43185 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43185 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43445 = mem[_13622]
                                                    _43446 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43446:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43446) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43445 + 32
                                                            while _43445 + _43446 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43446 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43446:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43446) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43445 + 32
                                                            while _43445 + _43446 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43446 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_42010 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _42010 + uint255(stor1[idx].field_1) - mem[64]]) != _41966:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61701 = mem[_13622]
                                                    _61702 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61702:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61702) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61701 + 32
                                                            while _61701 + _61702 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61702 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61702:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61702) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61701 + 32
                                                            while _61701 + _61702 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61702 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41966:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43448 = mem[_13622]
                                                _43449 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43449:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43449) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43448 + 32
                                                        while _43448 + _43449 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43449 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43449:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43449) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43448 + 32
                                                        while _43448 + _43449 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43449 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43686 = mem[_13622]
                                                    _43687 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43687:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43687) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43686 + 32
                                                            while _43686 + _43687 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43687 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43687:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43687) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43686 + 32
                                                            while _43686 + _43687 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43687 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_42010 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _42010 + stor1[idx].field_1 % 128 - mem[64]]) != _41966:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61704 = mem[_13622]
                                                    _61705 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61705:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61705) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61704 + 32
                                                            while _61704 + _61705 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61705 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61705:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61705) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61704 + 32
                                                            while _61704 + _61705 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61705 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                        stor1[idx].field_512 = mem[_13622 + 64]
                                        address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13622 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _42069 = mem[_13622]
                                    _42070 = mem[mem[_13622]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42070:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42070) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42069 + 32
                                            while _42069 + _42070 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42070 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42070:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42070) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42069 + 32
                                            while _42069 + _42070 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42070 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_27204 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _27204 + uint255(stor1[idx].field_1) - mem[64]]) != _27196:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13622 + 128] = stor1[idx].field_1024
                                    mem[_13622 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57366 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57432 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57366:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62804 = mem[_13622]
                                                _62805 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62805:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62805) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62804 + 32
                                                        while _62804 + _62805 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62805 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62805:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62805) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62804 + 32
                                                        while _62804 + _62805 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62805 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63069 = mem[_13622]
                                                    _63070 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63070:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63070) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63069 + 32
                                                            while _63069 + _63070 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63070 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63070:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63070) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63069 + 32
                                                            while _63069 + _63070 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63070 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57432 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57432 + uint255(stor1[idx].field_1) - mem[64]]) != _57366:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78018 = mem[_13622]
                                                    _78019 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78019:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78019) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78018 + 32
                                                            while _78018 + _78019 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78019 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78019:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78019) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78018 + 32
                                                            while _78018 + _78019 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78019 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57366:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63072 = mem[_13622]
                                                _63073 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63073:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63073) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63072 + 32
                                                        while _63072 + _63073 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63073 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63073:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63073) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63072 + 32
                                                        while _63072 + _63073 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63073 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63435 = mem[_13622]
                                                    _63436 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63436:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63436) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63435 + 32
                                                            while _63435 + _63436 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63436 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63436:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63436) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63435 + 32
                                                            while _63435 + _63436 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63436 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57432 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57432 + stor1[idx].field_1 % 128 - mem[64]]) != _57366:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78021 = mem[_13622]
                                                    _78022 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78022:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78022) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78021 + 32
                                                            while _78021 + _78022 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78022 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78022:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78022) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78021 + 32
                                                            while _78021 + _78022 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78022 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                        stor1[idx].field_512 = mem[_13622 + 64]
                                        address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13622 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _60034 = mem[_13622]
                                    _60035 = mem[mem[_13622]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _60035:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _60035) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _60034 + 32
                                            while _60034 + _60035 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _60035 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _60035:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _60035) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _60034 + 32
                                            while _60034 + _60035 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _60035 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _27196:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_13622 + 128] = stor1[idx].field_1024
                                mem[_13622 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _41968 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _42012 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41968:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43187 = mem[_13622]
                                            _43188 = mem[mem[_13622]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43188:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43188) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43187 + 32
                                                    while _43187 + _43188 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43188 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43188:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43188) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43187 + 32
                                                    while _43187 + _43188 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43188 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43458 = mem[_13622]
                                                _43459 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43459:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43459) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43458 + 32
                                                        while _43458 + _43459 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43459 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43459:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43459) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43458 + 32
                                                        while _43458 + _43459 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43459 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_42012 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42012 + uint255(stor1[idx].field_1) - mem[64]]) != _41968:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61707 = mem[_13622]
                                                _61708 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61708:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61708) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61707 + 32
                                                        while _61707 + _61708 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61708 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61708:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61708) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61707 + 32
                                                        while _61707 + _61708 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61708 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41968:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _43461 = mem[_13622]
                                            _43462 = mem[mem[_13622]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43462:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43462) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43461 + 32
                                                    while _43461 + _43462 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43462 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _43462:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _43462) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _43461 + 32
                                                    while _43461 + _43462 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43462 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43696 = mem[_13622]
                                                _43697 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43697:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43697) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43696 + 32
                                                        while _43696 + _43697 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43697 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43697:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43697) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43696 + 32
                                                        while _43696 + _43697 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43697 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_42012 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _42012 + stor1[idx].field_1 % 128 - mem[64]]) != _41968:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _61710 = mem[_13622]
                                                _61711 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61711:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61711) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61710 + 32
                                                        while _61710 + _61711 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61711 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _61711:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _61711) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _61710 + 32
                                                        while _61710 + _61711 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61711 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                    stor1[idx].field_512 = mem[_13622 + 64]
                                    address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_13622 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _42072 = mem[_13622]
                                _42073 = mem[mem[_13622]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42073:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42073) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42072 + 32
                                        while _42072 + _42073 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42073 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _42073:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _42073) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _42072 + 32
                                        while _42072 + _42073 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42073 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13622 + 128] = stor1[idx].field_1024
                                    mem[_13622 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _41970 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _42014 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41970:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43191 = mem[_13622]
                                                _43192 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43192:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43192) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43191 + 32
                                                        while _43191 + _43192 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43192 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43192:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43192) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43191 + 32
                                                        while _43191 + _43192 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43192 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43472 = mem[_13622]
                                                    _43473 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43473:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43473) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43472 + 32
                                                            while _43472 + _43473 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43473 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43473:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43473) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43472 + 32
                                                            while _43472 + _43473 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43473 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_42014 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _42014 + uint255(stor1[idx].field_1) - mem[64]]) != _41970:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61714 = mem[_13622]
                                                    _61715 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61715:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61715) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61714 + 32
                                                            while _61714 + _61715 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61715 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61715:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61715) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61714 + 32
                                                            while _61714 + _61715 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61715 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41970:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _43475 = mem[_13622]
                                                _43476 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43476:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43476) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43475 + 32
                                                        while _43475 + _43476 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43476 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _43476:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _43476) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _43475 + 32
                                                        while _43475 + _43476 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43476 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _43707 = mem[_13622]
                                                    _43708 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43708:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43708) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43707 + 32
                                                            while _43707 + _43708 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43708 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _43708:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _43708) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _43707 + 32
                                                            while _43707 + _43708 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43708 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_42014 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _42014 + stor1[idx].field_1 % 128 - mem[64]]) != _41970:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _61717 = mem[_13622]
                                                    _61718 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61718:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61718) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61717 + 32
                                                            while _61717 + _61718 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61718 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _61718:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _61718) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _61717 + 32
                                                            while _61717 + _61718 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61718 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                        stor1[idx].field_512 = mem[_13622 + 64]
                                        address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13622 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _42075 = mem[_13622]
                                    _42076 = mem[mem[_13622]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42076:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42076) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42075 + 32
                                            while _42075 + _42076 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42076 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _42076:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _42076) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _42075 + 32
                                            while _42075 + _42076 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42076 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_27204 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _27204 + stor1[idx].field_1 % 128 - mem[64]]) != _27196:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_13622 + 128] = stor1[idx].field_1024
                                    mem[_13622 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57388 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57434 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57388:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62811 = mem[_13622]
                                                _62812 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62812:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62812) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62811 + 32
                                                        while _62811 + _62812 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62812 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62812:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62812) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62811 + 32
                                                        while _62811 + _62812 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62812 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63086 = mem[_13622]
                                                    _63087 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63087:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63087) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63086 + 32
                                                            while _63086 + _63087 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63087 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63087:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63087) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63086 + 32
                                                            while _63086 + _63087 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63087 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57434 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57434 + uint255(stor1[idx].field_1) - mem[64]]) != _57388:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78024 = mem[_13622]
                                                    _78025 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78025:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78025) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78024 + 32
                                                            while _78024 + _78025 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78025 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78025:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78025) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78024 + 32
                                                            while _78024 + _78025 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78025 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57388:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63089 = mem[_13622]
                                                _63090 = mem[mem[_13622]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63090:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63090) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63089 + 32
                                                        while _63089 + _63090 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63090 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63090:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63090) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63089 + 32
                                                        while _63089 + _63090 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63090 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63465 = mem[_13622]
                                                    _63466 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63466:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63466) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63465 + 32
                                                            while _63465 + _63466 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63466 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63466:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63466) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63465 + 32
                                                            while _63465 + _63466 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63466 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57434 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57434 + stor1[idx].field_1 % 128 - mem[64]]) != _57388:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78027 = mem[_13622]
                                                    _78028 = mem[mem[_13622]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78028:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78028) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78027 + 32
                                                            while _78027 + _78028 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78028 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78028:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78028) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78027 + 32
                                                            while _78027 + _78028 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78028 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                                        stor1[idx].field_512 = mem[_13622 + 64]
                                        address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_13622 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _60337 = mem[_13622]
                                    _60338 = mem[mem[_13622]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _60338:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _60338) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _60337 + 32
                                            while _60337 + _60338 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _60338 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _60338:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _60338) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _60337 + 32
                                            while _60337 + _60338 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _60338 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13622 + 32]))
                        uint256(stor1.field_1536000000000000000512) = mem[_13622 + 64]
                        address(stor1.field_1536000000000000000768) = mem[_13622 + 108 len 20]
                        uint256(stor1.field_1536000000000000001024) = mem[_13622 + 128]
                        uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13622 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    mem[_13622 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_13622 + 160] = bool(arg6)
                    idx = 0
                    while idx < stor1.length:
                        _41962 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _42006 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41962:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43177 = mem[_13622]
                                _43178 = mem[mem[_13622]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43178:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43178) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43177 + 32
                                        while _43177 + _43178 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43178 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43178:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43178) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43177 + 32
                                        while _43177 + _43178 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43178 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _43418 = mem[_13622]
                                    _43419 = mem[mem[_13622]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43419:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43419) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43418 + 32
                                            while _43418 + _43419 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43419 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43419:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43419) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43418 + 32
                                            while _43418 + _43419 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43419 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_42006 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _42006 + uint255(stor1[idx].field_1) - mem[64]]) != _41962:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _61688 = mem[_13622]
                                    _61689 = mem[mem[_13622]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61689:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61689) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61688 + 32
                                            while _61688 + _61689 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61689 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61689:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61689) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61688 + 32
                                            while _61688 + _61689 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61689 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41962:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _43421 = mem[_13622]
                                _43422 = mem[mem[_13622]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43422:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43422) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43421 + 32
                                        while _43421 + _43422 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43422 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _43422:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _43422) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _43421 + 32
                                        while _43421 + _43422 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43422 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _43665 = mem[_13622]
                                    _43666 = mem[mem[_13622]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43666:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43666) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43665 + 32
                                            while _43665 + _43666 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43666 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _43666:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _43666) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _43665 + 32
                                            while _43665 + _43666 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _43666 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_42006 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _42006 + stor1[idx].field_1 % 128 - mem[64]]) != _41962:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _61691 = mem[_13622]
                                    _61692 = mem[mem[_13622]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61692:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61692) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61691 + 32
                                            while _61691 + _61692 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61692 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _61692:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _61692) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _61691 + 32
                                            while _61691 + _61692 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _61692 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        uint8(stor1[idx].field_256) = uint8(bool(mem[_13622 + 32]))
                        stor1[idx].field_512 = mem[_13622 + 64]
                        address(stor1[idx].field_768) = mem[_13622 + 108 len 20]
                        stor1[idx].field_1024 = mem[_13622 + 128]
                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_13622 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _42063 = mem[_13622]
                    _42064 = mem[mem[_13622]]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _42064:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _42064) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _42063 + 32
                            while _42063 + _42064 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42064 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _42064:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _42064) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _42063 + 32
                            while _42063 + _42064 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _42064 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_13622 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_13622 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_13622 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_13622 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_13622 + 160]))
                else:
                    mem[0] = (6 * idx) + sha3(1)
                    s = 0
                    t = sha3(mem[0])
                    while s < stor1[idx].field_1 % 128:
                        mem[_13594 + s] = stor[t]
                        s = s + 32
                        t = t + 1
                        continue 
                    if sha3(mem[mem[64] len _13594 + stor1[idx].field_1 % 128 - mem[64]]) != _13592:
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    if idx == 10^18:
                        revert with 0, 'FOREST: Target NFT does not exist'
                    if ext_code.size(address(arg5)) <= 0:
                        revert with 0, 'FOREST: NFT Address is not a contract'
                    _27245 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_27245] = ceil32(ceil32(arg1.length)) + 97
                    mem[_27245 + 32] = bool(arg3)
                    mem[_27245 + 64] = arg4
                    mem[_27245 + 96] = address(arg5)
                    idx = 0
                    while idx < stor1.length:
                        _41960 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _42004 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _41960:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_27245 + 128] = stor1[idx].field_1024
                                mem[_27245 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57338 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57424 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57338:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62786 = mem[_27245]
                                            _62787 = mem[mem[_27245]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62787:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62787) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62786 + 32
                                                    while _62786 + _62787 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62787 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62787:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62787) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62786 + 32
                                                    while _62786 + _62787 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62787 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63011 = mem[_27245]
                                                _63012 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63012:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63012) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63011 + 32
                                                        while _63011 + _63012 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63012 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63012:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63012) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63011 + 32
                                                        while _63011 + _63012 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63012 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57424 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57424 + uint255(stor1[idx].field_1) - mem[64]]) != _57338:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77992 = mem[_27245]
                                                _77993 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77993:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77993) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77992 + 32
                                                        while _77992 + _77993 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77993 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77993:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77993) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77992 + 32
                                                        while _77992 + _77993 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77993 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57338:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _63014 = mem[_27245]
                                            _63015 = mem[mem[_27245]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _63015:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _63015) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _63014 + 32
                                                    while _63014 + _63015 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63015 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _63015:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _63015) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _63014 + 32
                                                    while _63014 + _63015 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63015 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63373 = mem[_27245]
                                                _63374 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63374:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63374) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63373 + 32
                                                        while _63373 + _63374 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63374 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63374:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63374) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63373 + 32
                                                        while _63373 + _63374 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63374 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57424 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57424 + stor1[idx].field_1 % 128 - mem[64]]) != _57338:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _77995 = mem[_27245]
                                                _77996 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77996:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77996) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77995 + 32
                                                        while _77995 + _77996 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77996 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _77996:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _77996) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _77995 + 32
                                                        while _77995 + _77996 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77996 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                    stor1[idx].field_512 = mem[_27245 + 64]
                                    address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_27245 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _59722 = mem[_27245]
                                _59723 = mem[mem[_27245]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59723:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59723) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59722 + 32
                                        while _59722 + _59723 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59723 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59723:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59723) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59722 + 32
                                        while _59722 + _59723 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59723 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27245 + 128] = stor1[idx].field_1024
                                    mem[_27245 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57340 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57426 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57340:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62790 = mem[_27245]
                                                _62791 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62791:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62791) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62790 + 32
                                                        while _62790 + _62791 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62791 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62791:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62791) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62790 + 32
                                                        while _62790 + _62791 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62791 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63025 = mem[_27245]
                                                    _63026 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63026:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63026) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63025 + 32
                                                            while _63025 + _63026 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63026 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63026:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63026) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63025 + 32
                                                            while _63025 + _63026 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63026 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57426 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57426 + uint255(stor1[idx].field_1) - mem[64]]) != _57340:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _77999 = mem[_27245]
                                                    _78000 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78000:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78000) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77999 + 32
                                                            while _77999 + _78000 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78000 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78000:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78000) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _77999 + 32
                                                            while _77999 + _78000 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78000 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57340:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63028 = mem[_27245]
                                                _63029 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63029:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63029) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63028 + 32
                                                        while _63028 + _63029 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63029 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63029:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63029) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63028 + 32
                                                        while _63028 + _63029 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63029 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63384 = mem[_27245]
                                                    _63385 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63385:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63385) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63384 + 32
                                                            while _63384 + _63385 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63385 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63385:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63385) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63384 + 32
                                                            while _63384 + _63385 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63385 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57426 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57426 + stor1[idx].field_1 % 128 - mem[64]]) != _57340:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78002 = mem[_27245]
                                                    _78003 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78003:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78003) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78002 + 32
                                                            while _78002 + _78003 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78003 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78003:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78003) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78002 + 32
                                                            while _78002 + _78003 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78003 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                        stor1[idx].field_512 = mem[_27245 + 64]
                                        address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27245 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _59725 = mem[_27245]
                                    _59726 = mem[mem[_27245]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _59726:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _59726) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _59725 + 32
                                            while _59725 + _59726 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59726 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _59726:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _59726) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _59725 + 32
                                            while _59725 + _59726 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59726 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_42004 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _42004 + uint255(stor1[idx].field_1) - mem[64]]) != _41960:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27245 + 128] = stor1[idx].field_1024
                                    mem[_27245 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _71552 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _71630 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _71552:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78386 = mem[_27245]
                                                _78387 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78387:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78387) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78386 + 32
                                                        while _78386 + _78387 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78387 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78387:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78387) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78386 + 32
                                                        while _78386 + _78387 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78387 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78461 = mem[_27245]
                                                    _78462 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78462:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78462) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78461 + 32
                                                            while _78461 + _78462 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78462 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78462:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78462) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78461 + 32
                                                            while _78461 + _78462 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78462 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_71630 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71630 + uint255(stor1[idx].field_1) - mem[64]]) != _71552:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84778 = mem[_27245]
                                                    _84779 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84779:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84779) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84778 + 32
                                                            while _84778 + _84779 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84779 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84779:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84779) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84778 + 32
                                                            while _84778 + _84779 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84779 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _71552:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78464 = mem[_27245]
                                                _78465 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78465:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78465) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78464 + 32
                                                        while _78464 + _78465 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78465 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78465:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78465) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78464 + 32
                                                        while _78464 + _78465 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78465 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78647 = mem[_27245]
                                                    _78648 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78648:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78648) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78647 + 32
                                                            while _78647 + _78648 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78648 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78648:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78648) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78647 + 32
                                                            while _78647 + _78648 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78648 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_71630 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71630 + stor1[idx].field_1 % 128 - mem[64]]) != _71552:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84781 = mem[_27245]
                                                    _84782 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84782:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84782) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84781 + 32
                                                            while _84781 + _84782 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84782 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84782:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84782) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84781 + 32
                                                            while _84781 + _84782 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84782 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                        stor1[idx].field_512 = mem[_27245 + 64]
                                        address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27245 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _75240 = mem[_27245]
                                    _75241 = mem[mem[_27245]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _75241:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _75241) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _75240 + 32
                                            while _75240 + _75241 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _75241 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _75241:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _75241) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _75240 + 32
                                            while _75240 + _75241 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _75241 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _41960:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                mem[_27245 + 128] = stor1[idx].field_1024
                                mem[_27245 + 160] = bool(arg6)
                                idx = 0
                                while idx < stor1.length:
                                    _57342 = sha3(mem[128 len mem[96]])
                                    mem[0] = 1
                                    _57428 = mem[64]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57342:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _62793 = mem[_27245]
                                            _62794 = mem[mem[_27245]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62794:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62794) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62793 + 32
                                                    while _62793 + _62794 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62794 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _62794:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _62794) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _62793 + 32
                                                    while _62793 + _62794 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62794 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63038 = mem[_27245]
                                                _63039 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63039:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63039) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63038 + 32
                                                        while _63038 + _63039 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63039 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63039:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63039) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63038 + 32
                                                        while _63038 + _63039 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63039 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < uint255(stor1[idx].field_1):
                                                    mem[_57428 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57428 + uint255(stor1[idx].field_1) - mem[64]]) != _57342:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78005 = mem[_27245]
                                                _78006 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78006:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78006) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78005 + 32
                                                        while _78005 + _78006 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78006 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78006:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78006) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78005 + 32
                                                        while _78005 + _78006 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78006 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        if not bool(stor1[idx].field_0):
                                            mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                            if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57342:
                                                if idx == -1:
                                                    revert with 'NH{q', 17
                                                idx = idx + 1
                                                continue 
                                            if idx >= stor1.length:
                                                revert with 'NH{q', 50
                                            mem[0] = 1
                                            _63041 = mem[_27245]
                                            _63042 = mem[mem[_27245]]
                                            if bool(stor1[idx].field_0):
                                                if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _63042:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _63042) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _63041 + 32
                                                    while _63041 + _63042 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63042 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                    revert with 'NH{q', 34
                                                mem[0] = (6 * idx) + sha3(1)
                                                if not _63042:
                                                    stor1[idx].field_0 = 0
                                                    s = sha3((6 * idx) + sha3(1))
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    stor1[idx].field_0 = (2 * _63042) + 1
                                                    t = sha3((6 * idx) + sha3(1))
                                                    s = _63041 + 32
                                                    while _63041 + _63042 + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63042 + 31) >> 5)
                                                    while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            if bool(stor1[idx].field_0) != 1:
                                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63394 = mem[_27245]
                                                _63395 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63395:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63395) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63394 + 32
                                                        while _63394 + _63395 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63395 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63395:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63395) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63394 + 32
                                                        while _63394 + _63395 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63395 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                mem[0] = (6 * idx) + sha3(1)
                                                s = 0
                                                t = sha3(mem[0])
                                                while s < stor1[idx].field_1 % 128:
                                                    mem[_57428 + s] = stor[t]
                                                    s = s + 32
                                                    t = t + 1
                                                    continue 
                                                if sha3(mem[mem[64] len _57428 + stor1[idx].field_1 % 128 - mem[64]]) != _57342:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78008 = mem[_27245]
                                                _78009 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78009:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78009) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78008 + 32
                                                        while _78008 + _78009 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78009 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78009:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78009) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78008 + 32
                                                        while _78008 + _78009 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78009 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                    uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                    stor1[idx].field_512 = mem[_27245 + 64]
                                    address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                    stor1[idx].field_1024 = mem[_27245 + 128]
                                    uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                if 10^18 >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _59728 = mem[_27245]
                                _59729 = mem[mem[_27245]]
                                if bool(stor1.field_1536 * 10^18):
                                    if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59729:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59729) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59728 + 32
                                        while _59728 + _59729 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59729 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                else:
                                    if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = sha3(1) + 6 * 10^18
                                    if not _59729:
                                        uint256(stor1.field_1536 * 10^18) = 0
                                        idx = sha3(sha3(1) + 6 * 10^18)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        uint256(stor1.field_1536 * 10^18) = (2 * _59729) + 1
                                        s = sha3(sha3(1) + 6 * 10^18)
                                        idx = _59728 + 32
                                        while _59728 + _59729 + 32 > idx:
                                            stor[s] = mem[idx]
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59729 + 31) >> 5)
                                        while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                            stor[idx] = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27245 + 128] = stor1[idx].field_1024
                                    mem[_27245 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _57344 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _57430 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57344:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _62797 = mem[_27245]
                                                _62798 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62798:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62798) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62797 + 32
                                                        while _62797 + _62798 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62798 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _62798:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _62798) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _62797 + 32
                                                        while _62797 + _62798 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62798 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63052 = mem[_27245]
                                                    _63053 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63053:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63053) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63052 + 32
                                                            while _63052 + _63053 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63053 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63053:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63053) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63052 + 32
                                                            while _63052 + _63053 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63053 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_57430 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57430 + uint255(stor1[idx].field_1) - mem[64]]) != _57344:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78012 = mem[_27245]
                                                    _78013 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78013:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78013) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78012 + 32
                                                            while _78012 + _78013 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78013 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78013:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78013) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78012 + 32
                                                            while _78012 + _78013 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78013 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57344:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _63055 = mem[_27245]
                                                _63056 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63056:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63056) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63055 + 32
                                                        while _63055 + _63056 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63056 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _63056:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _63056) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _63055 + 32
                                                        while _63055 + _63056 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63056 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _63405 = mem[_27245]
                                                    _63406 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63406:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63406) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63405 + 32
                                                            while _63405 + _63406 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63406 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _63406:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _63406) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _63405 + 32
                                                            while _63405 + _63406 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63406 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_57430 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _57430 + stor1[idx].field_1 % 128 - mem[64]]) != _57344:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78015 = mem[_27245]
                                                    _78016 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78016:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78016) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78015 + 32
                                                            while _78015 + _78016 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78016 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78016:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78016) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78015 + 32
                                                            while _78015 + _78016 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78016 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                        stor1[idx].field_512 = mem[_27245 + 64]
                                        address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27245 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _59731 = mem[_27245]
                                    _59732 = mem[mem[_27245]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _59732:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _59732) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _59731 + 32
                                            while _59731 + _59732 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59732 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _59732:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _59732) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _59731 + 32
                                            while _59731 + _59732 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59732 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_42004 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _42004 + stor1[idx].field_1 % 128 - mem[64]]) != _41960:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    mem[_27245 + 128] = stor1[idx].field_1024
                                    mem[_27245 + 160] = bool(arg6)
                                    idx = 0
                                    while idx < stor1.length:
                                        _71574 = sha3(mem[128 len mem[96]])
                                        mem[0] = 1
                                        _71632 = mem[64]
                                        if bool(stor1[idx].field_0):
                                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _71574:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78393 = mem[_27245]
                                                _78394 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78394:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78394) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78393 + 32
                                                        while _78393 + _78394 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78394 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78394:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78394) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78393 + 32
                                                        while _78393 + _78394 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78394 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78478 = mem[_27245]
                                                    _78479 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78479:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78479) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78478 + 32
                                                            while _78478 + _78479 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78479 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78479:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78479) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78478 + 32
                                                            while _78478 + _78479 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78479 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < uint255(stor1[idx].field_1):
                                                        mem[_71632 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71632 + uint255(stor1[idx].field_1) - mem[64]]) != _71574:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84784 = mem[_27245]
                                                    _84785 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84785:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84785) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84784 + 32
                                                            while _84784 + _84785 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84785 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84785:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84785) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84784 + 32
                                                            while _84784 + _84785 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84785 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                revert with 'NH{q', 34
                                            if not bool(stor1[idx].field_0):
                                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _71574:
                                                    if idx == -1:
                                                        revert with 'NH{q', 17
                                                    idx = idx + 1
                                                    continue 
                                                if idx >= stor1.length:
                                                    revert with 'NH{q', 50
                                                mem[0] = 1
                                                _78481 = mem[_27245]
                                                _78482 = mem[mem[_27245]]
                                                if bool(stor1[idx].field_0):
                                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78482:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78482) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78481 + 32
                                                        while _78481 + _78482 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78482 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                else:
                                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                        revert with 'NH{q', 34
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    if not _78482:
                                                        stor1[idx].field_0 = 0
                                                        s = sha3((6 * idx) + sha3(1))
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                                    else:
                                                        stor1[idx].field_0 = (2 * _78482) + 1
                                                        t = sha3((6 * idx) + sha3(1))
                                                        s = _78481 + 32
                                                        while _78481 + _78482 + 32 > s:
                                                            stor[t] = mem[s]
                                                            t = t + 1
                                                            s = s + 32
                                                            continue 
                                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78482 + 31) >> 5)
                                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                            stor[s] = 0
                                                            s = s + 1
                                                            continue 
                                            else:
                                                if bool(stor1[idx].field_0) != 1:
                                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _78677 = mem[_27245]
                                                    _78678 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78678:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78678) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78677 + 32
                                                            while _78677 + _78678 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78678 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _78678:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _78678) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _78677 + 32
                                                            while _78677 + _78678 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _78678 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[0] = (6 * idx) + sha3(1)
                                                    s = 0
                                                    t = sha3(mem[0])
                                                    while s < stor1[idx].field_1 % 128:
                                                        mem[_71632 + s] = stor[t]
                                                        s = s + 32
                                                        t = t + 1
                                                        continue 
                                                    if sha3(mem[mem[64] len _71632 + stor1[idx].field_1 % 128 - mem[64]]) != _71574:
                                                        if idx == -1:
                                                            revert with 'NH{q', 17
                                                        idx = idx + 1
                                                        continue 
                                                    if idx >= stor1.length:
                                                        revert with 'NH{q', 50
                                                    mem[0] = 1
                                                    _84787 = mem[_27245]
                                                    _84788 = mem[mem[_27245]]
                                                    if bool(stor1[idx].field_0):
                                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84788:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84788) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84787 + 32
                                                            while _84787 + _84788 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84788 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                                            revert with 'NH{q', 34
                                                        mem[0] = (6 * idx) + sha3(1)
                                                        if not _84788:
                                                            stor1[idx].field_0 = 0
                                                            s = sha3((6 * idx) + sha3(1))
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            stor1[idx].field_0 = (2 * _84788) + 1
                                                            t = sha3((6 * idx) + sha3(1))
                                                            s = _84787 + 32
                                                            while _84787 + _84788 + 32 > s:
                                                                stor[t] = mem[s]
                                                                t = t + 1
                                                                s = s + 32
                                                                continue 
                                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _84788 + 31) >> 5)
                                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                                stor[s] = 0
                                                                s = s + 1
                                                                continue 
                                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                                        stor1[idx].field_512 = mem[_27245 + 64]
                                        address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                                        stor1[idx].field_1024 = mem[_27245 + 128]
                                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                                    if 10^18 >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _75543 = mem[_27245]
                                    _75544 = mem[mem[_27245]]
                                    if bool(stor1.field_1536 * 10^18):
                                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _75544:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _75544) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _75543 + 32
                                            while _75543 + _75544 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _75544 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = sha3(1) + 6 * 10^18
                                        if not _75544:
                                            uint256(stor1.field_1536 * 10^18) = 0
                                            idx = sha3(sha3(1) + 6 * 10^18)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            uint256(stor1.field_1536 * 10^18) = (2 * _75544) + 1
                                            s = sha3(sha3(1) + 6 * 10^18)
                                            idx = _75543 + 32
                                            while _75543 + _75544 + 32 > idx:
                                                stor[s] = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _75544 + 31) >> 5)
                                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                                stor[idx] = 0
                                                idx = idx + 1
                                                continue 
                        uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_27245 + 32]))
                        uint256(stor1.field_1536000000000000000512) = mem[_27245 + 64]
                        address(stor1.field_1536000000000000000768) = mem[_27245 + 108 len 20]
                        uint256(stor1.field_1536000000000000001024) = mem[_27245 + 128]
                        uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_27245 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    mem[_27245 + 128] = uint256(stor1.field_1536000000000000001024)
                    mem[_27245 + 160] = bool(arg6)
                    idx = 0
                    while idx < stor1.length:
                        _57336 = sha3(mem[128 len mem[96]])
                        mem[0] = 1
                        _57422 = mem[64]
                        if bool(stor1[idx].field_0):
                            if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len uint255(stor1[idx].field_1)]) != _57336:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _62783 = mem[_27245]
                                _62784 = mem[mem[_27245]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62784:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62784) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62783 + 32
                                        while _62783 + _62784 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62784 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _62784:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _62784) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _62783 + 32
                                        while _62783 + _62784 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62784 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _62998 = mem[_27245]
                                    _62999 = mem[mem[_27245]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _62999:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _62999) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _62998 + 32
                                            while _62998 + _62999 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62999 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _62999:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _62999) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _62998 + 32
                                            while _62998 + _62999 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _62999 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < uint255(stor1[idx].field_1):
                                        mem[_57422 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _57422 + uint255(stor1[idx].field_1) - mem[64]]) != _57336:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _77986 = mem[_27245]
                                    _77987 = mem[mem[_27245]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77987:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77987) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77986 + 32
                                            while _77986 + _77987 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77987 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77987:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77987) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77986 + 32
                                            while _77986 + _77987 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77987 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor1[idx].field_0):
                                mem[mem[64]] = Mask(248, 8, stor1[idx].field_0)
                                if sha3(mem[mem[64] len stor1[idx].field_1 % 128]) != _57336:
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                if idx >= stor1.length:
                                    revert with 'NH{q', 50
                                mem[0] = 1
                                _63001 = mem[_27245]
                                _63002 = mem[mem[_27245]]
                                if bool(stor1[idx].field_0):
                                    if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _63002:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _63002) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _63001 + 32
                                        while _63001 + _63002 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63002 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                        revert with 'NH{q', 34
                                    mem[0] = (6 * idx) + sha3(1)
                                    if not _63002:
                                        stor1[idx].field_0 = 0
                                        s = sha3((6 * idx) + sha3(1))
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        stor1[idx].field_0 = (2 * _63002) + 1
                                        t = sha3((6 * idx) + sha3(1))
                                        s = _63001 + 32
                                        while _63001 + _63002 + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63002 + 31) >> 5)
                                        while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor1[idx].field_0) != 1:
                                    if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _63363 = mem[_27245]
                                    _63364 = mem[mem[_27245]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _63364:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _63364) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _63363 + 32
                                            while _63363 + _63364 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63364 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _63364:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _63364) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _63363 + 32
                                            while _63363 + _63364 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _63364 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    mem[0] = (6 * idx) + sha3(1)
                                    s = 0
                                    t = sha3(mem[0])
                                    while s < stor1[idx].field_1 % 128:
                                        mem[_57422 + s] = stor[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    if sha3(mem[mem[64] len _57422 + stor1[idx].field_1 % 128 - mem[64]]) != _57336:
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        continue 
                                    if idx >= stor1.length:
                                        revert with 'NH{q', 50
                                    mem[0] = 1
                                    _77989 = mem[_27245]
                                    _77990 = mem[mem[_27245]]
                                    if bool(stor1[idx].field_0):
                                        if bool(stor1[idx].field_0) == uint255(stor1[idx].field_1) < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77990:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77990) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77989 + 32
                                            while _77989 + _77990 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77990 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (uint255(stor1[idx].field_1) + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        if bool(stor1[idx].field_0) == stor1[idx].field_1 % 128 < 32:
                                            revert with 'NH{q', 34
                                        mem[0] = (6 * idx) + sha3(1)
                                        if not _77990:
                                            stor1[idx].field_0 = 0
                                            s = sha3((6 * idx) + sha3(1))
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            stor1[idx].field_0 = (2 * _77990) + 1
                                            t = sha3((6 * idx) + sha3(1))
                                            s = _77989 + 32
                                            while _77989 + _77990 + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3((6 * idx) + sha3(1)) + (Mask(251, 0, _77990 + 31) >> 5)
                                            while sha3((6 * idx) + sha3(1)) + (stor1[idx].field_1 % 128 + 31 / 32) > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        uint8(stor1[idx].field_256) = uint8(bool(mem[_27245 + 32]))
                        stor1[idx].field_512 = mem[_27245 + 64]
                        address(stor1[idx].field_768) = mem[_27245 + 108 len 20]
                        stor1[idx].field_1024 = mem[_27245 + 128]
                        uint8(stor1[idx].field_1280) = uint8(bool(mem[_27245 + 160]))
                    if 10^18 >= stor1.length:
                        revert with 'NH{q', 50
                    mem[0] = 1
                    _59719 = mem[_27245]
                    _59720 = mem[mem[_27245]]
                    if bool(stor1.field_1536 * 10^18):
                        if bool(stor1.field_1536 * 10^18) == uint255(stor1.field_1536000000000000000001) < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _59720:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _59720) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _59719 + 32
                            while _59719 + _59720 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59720 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (uint255(stor1.field_1536000000000000000001) + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor1.field_1536 * 10^18) == stor1.field_1536000000000000000001 % 128 < 32:
                            revert with 'NH{q', 34
                        mem[0] = sha3(1) + 6 * 10^18
                        if not _59720:
                            uint256(stor1.field_1536 * 10^18) = 0
                            idx = sha3(sha3(1) + 6 * 10^18)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                        else:
                            uint256(stor1.field_1536 * 10^18) = (2 * _59720) + 1
                            s = sha3(sha3(1) + 6 * 10^18)
                            idx = _59719 + 32
                            while _59719 + _59720 + 32 > idx:
                                stor[s] = mem[idx]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = sha3(sha3(1) + 6 * 10^18) + (Mask(251, 0, _59720 + 31) >> 5)
                            while sha3(sha3(1) + 6 * 10^18) + (stor1.field_1536000000000000000001 % 128 + 31 / 32) > idx:
                                stor[idx] = 0
                                idx = idx + 1
                                continue 
                    uint8(stor1.field_1536000000000000000256) = uint8(bool(mem[_27245 + 32]))
                    uint256(stor1.field_1536000000000000000512) = mem[_27245 + 64]
                    address(stor1.field_1536000000000000000768) = mem[_27245 + 108 len 20]
                    uint256(stor1.field_1536000000000000001024) = mem[_27245 + 128]
                    uint8(stor1.field_1536000000000000001280) = uint8(bool(mem[_27245 + 160]))
    revert with 0, 'FOREST: Target NFT does not exist'
}



}
